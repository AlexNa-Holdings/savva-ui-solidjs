import fs from "node:fs";
import path from "node:path";
import { pathToFileURL } from "node:url";
import dotenv from "dotenv";
import OpenAI from "openai";

// ---------- Config ----------
const ROOT = process.cwd();
dotenv.config({ path: path.join(ROOT, ".env") });

const SRC_DIR = path.join(ROOT, "src");
const I18N_DIR = path.join(SRC_DIR, "i18n");
const OPENAI_KEY = process.env.OPENAI_API_KEY || "";
const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
const BATCH_SIZE = 60; // how many keys to ask the model about per request

// ---------- Collect used keys (scan t("key") calls) ----------
const exts = [".js", ".jsx", ".ts", ".tsx"];
const usedKeys = new Set();

/**
 * Finds t('foo.bar'), t("foo.bar") and t(`foo.bar`) with static literals only.
 * (If you build keys dynamically, they wonâ€™t be picked up by any static scan.)
 */
const T_CALL = /\b(?:i18n\.)?t\(\s*([`'"])([^`'"]+)\1\s*\)/g;

function walk(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      if (entry.name === "node_modules" || entry.name === "dist") continue;
      walk(p);
    } else if (exts.includes(path.extname(entry.name))) {
      const text = fs.readFileSync(p, "utf8");
      let m;
      while ((m = T_CALL.exec(text))) {
        usedKeys.add(m[2]);
      }
    }
  }
}

walk(SRC_DIR);

// ---------- Helpers to load & write lang files ----------
function isLangFile(name) {
  return name.endsWith(".js") && !/useI18n\.js$/i.test(name);
}
function toModuleURL(filePath) {
  return pathToFileURL(filePath).href;
}
async function loadLang(filePath) {
  const mod = await import(toModuleURL(filePath));
  const dict = mod?.default || {};
  const normalized = {};
  for (const [k, v] of Object.entries(dict)) {
    normalized[k] = typeof v === "string" ? v : String(v);
  }
  return normalized;
}
function writeLang(filePath, obj) {
  const sorted = Object.keys(obj)
    .sort()
    .reduce((acc, k) => {
      acc[k] = obj[k];
      return acc;
    }, {});
  const body =
    "// Auto-generated by scripts/i18n.mjs. Do not edit by hand.\n" +
    "export default " +
    JSON.stringify(sorted, null, 2) +
    ";\n";
  fs.writeFileSync(filePath, body, "utf8");
  console.log(`[i18n] Updated ${path.relative(ROOT, filePath)} (${Object.keys(sorted).length} keys)`);
}

// ---------- OpenAI helpers ----------
let openai = null;
if (OPENAI_KEY) {
  openai = new OpenAI({ apiKey: OPENAI_KEY });
}

function chunk(arr, size) {
  const out = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

async function askJson(prompt, schemaHint = "an object mapping keys to strings") {
  if (!openai) return {};
  const res = await openai.chat.completions.create({
    model: OPENAI_MODEL,
    temperature: 0.2,
    response_format: { type: "json_object" },
    messages: [
      {
        role: "system",
        content:
          `You are a localization copywriter for a web app. ` +
          `Return ONLY valid JSON (${schemaHint}). Keep strings concise, natural, and product-quality. ` +
          `Preserve punctuation, capitalization, and any placeholders like {name}, {amount}, {n}, %s, %d exactly. ` +
          `Do not add extra keys.`,
      },
      { role: "user", content: prompt },
    ],
  });
  const text = res.choices?.[0]?.message?.content || "{}";
  try {
    return JSON.parse(text);
  } catch {
    return {};
  }
}

async function fillEnglish(keys) {
  const out = {};
  for (const group of chunk(keys, BATCH_SIZE)) {
    const prompt =
      `For each key, produce an English UI string (microcopy). ` +
      `Be terse where appropriate (button labels, placeholders) and clear for longer texts.\n\n` +
      JSON.stringify({ keys: group }, null, 2);
    const json = await askJson(prompt);
    Object.assign(out, json);
  }
  return out;
}

async function translateTo(langCode, pairs /* [{key, en}] */) {
  const out = {};
  for (const group of chunk(pairs, BATCH_SIZE)) {
    const prompt =
      `Translate the following English app strings to ${langCode}. ` +
      `Keep placeholders (like {amount}, {n}, %s, %d) unchanged. ` +
      `Use natural ${langCode} for a consumer web app (not formal/legal). ` +
      `Return a JSON object mapping "key" -> "translated string".\n\n` +
      JSON.stringify({ items: group }, null, 2);
    const json = await askJson(prompt);
    Object.assign(out, json);
  }
  return out;
}

// ---------- Main ----------
(async function main() {
  // Sanity
  if (!fs.existsSync(I18N_DIR)) {
    console.error(`[i18n] Not found: ${path.relative(ROOT, I18N_DIR)}`);
    process.exit(1);
  }

  const langFiles = fs.readdirSync(I18N_DIR).filter(isLangFile);
  if (langFiles.length === 0) {
    console.error("[i18n] No language files found in src/i18n");
    process.exit(1);
  }

  const enPath = path.join(I18N_DIR, "en.js");
  if (!fs.existsSync(enPath)) {
    console.error("[i18n] Missing src/i18n/en.js (source of truth)");
    process.exit(1);
  }

  // Load all dicts
  const dicts = {};
  for (const f of langFiles) {
    dicts[f] = await loadLang(path.join(I18N_DIR, f));
  }

  const desiredKeys = new Set(usedKeys);
  console.log(`[i18n] Used keys found: ${desiredKeys.size}`);

  // ---------- 1) Clean English (keep only used, mark missing & "???" as missing) ----------
  const enOrig = dicts["en.js"] || {};
  const enNew = {};
  const missingEn = [];

  for (const k of desiredKeys) {
    const v = enOrig[k];
    const isMissingValue =
      v == null || (typeof v === "string" && (v.trim() === "" || v.trim() === "???"));
    if (isMissingValue) {
      enNew[k] = "???";
      missingEn.push(k);
    } else {
      enNew[k] = v;
    }
  }

  writeLang(enPath, enNew);
  console.log(`[i18n] en.js cleaned. Missing or "???": ${missingEn.length}`);

  // ---------- 2) Fill English "???" via OpenAI ----------
  if (missingEn.length > 0) {
    if (!openai) {
      console.warn(
        "[i18n] OPENAI_API_KEY not set; skip filling English. Set it in .env to auto-fill."
      );
    } else {
      const filled = await fillEnglish(missingEn);
      let filledCount = 0;
      for (const k of missingEn) {
        const candidate = filled[k];
        if (typeof candidate === "string" && candidate.trim()) {
          enNew[k] = candidate.trim();
          filledCount++;
        }
      }
      writeLang(enPath, enNew);
      console.log(`[i18n] en.js: filled ${filledCount} English strings via OpenAI.`);
    }
  } else {
    console.log("[i18n] No missing English strings to fill.");
  }

  // ---------- 3) For each non-English, prune + add "???" + translate from English ----------
  for (const f of langFiles) {
    if (f === "en.js") continue;

    const langPath = path.join(I18N_DIR, f);
    const langCode = path.basename(f, ".js");
    const langDict = dicts[f] || {};

    // Prune/prepare
    const out = {};
    const toTranslate = [];
    for (const k of desiredKeys) {
      const v = langDict[k];
      const isMissing = v == null || (typeof v === "string" && (v.trim() === "" || v.trim() === "???"));
      if (isMissing) {
        out[k] = "???";
        // Only translate if we have an English source string
        if (typeof enNew[k] === "string" && enNew[k].trim()) {
          toTranslate.push({ key: k, en: enNew[k] });
        }
      } else {
        out[k] = v;
      }
    }

    writeLang(langPath, out);

    if (toTranslate.length === 0) {
      console.log(`[i18n] ${langCode}: nothing to translate.`);
      continue;
    }

    if (!openai) {
      console.warn(`[i18n] ${langCode}: OPENAI_API_KEY not set; skip translation.`);
      continue;
    }

    const translated = await translateTo(langCode, toTranslate);
    let translatedCount = 0;
    for (const { key } of toTranslate) {
      const t = translated[key];
      if (typeof t === "string" && t.trim() && out[key] === "???") {
        out[key] = t.trim();
        translatedCount++;
      }
    }
    writeLang(langPath, out);
    console.log(`[i18n] ${langCode}: translated ${translatedCount} keys.`);
  }

  console.log("[i18n] Done.");
})().catch((err) => {
  console.error(err);
  process.exit(1);
});
