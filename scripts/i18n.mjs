// scripts/i18n.mjs
import fs from "node:fs";
import path from "node:path";
import { pathToFileURL } from "node:url";
import dotenv from "dotenv";
import OpenAI from "openai";

// ---------- Config ----------
const ROOT = process.cwd();
dotenv.config({ path: path.join(ROOT, ".env") });

const SRC_DIR = path.join(ROOT, "src");
const I18N_DIR = path.join(SRC_DIR, "i18n");

// Read API key from file path
const OPENAI_KEY_PATH = process.env.OPENAI_API_KEY_PATH || "";
let OPENAI_KEY = "";
if (OPENAI_KEY_PATH) {
  try {
    OPENAI_KEY = fs.readFileSync(path.resolve(ROOT, OPENAI_KEY_PATH), "utf8").trim();
  } catch (err) {
    console.error(`[i18n] Failed to read OPENAI_API_KEY from path: ${OPENAI_KEY_PATH}`, err.message);
    OPENAI_KEY = ""; // Continue without key, warn later
  }
}

const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
const OPENAI_TEMPERATURE = parseFloat(process.env.OPENAI_TEMPERATURE || "1");
const BATCH_SIZE = 60; // how many keys to ask the model about per request
const targetLang = process.argv[2] || null;
const onlyEnglish = targetLang === "en";

// ---------- Collect used keys (scan t("key") calls) ----------
const exts = [".js", ".jsx", ".ts", ".tsx"];
const usedKeys = new Set();

/**
 * Finds t('foo.bar'), t("foo.bar") and t(`foo.bar`) with static literals only.
 * (If you build keys dynamically, they won’t be picked up by any static scan.)
 */
// const T_CALL = /\b(?:i18n\.)?t\(\s*([`'"])([^`'"]+)\1\s*\)/g;
const T_CALL = /\b(?:i18n\.)?t\(\s*([`'"])([^`'"]+)/g; //allows t(a,b..)

function walk(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      if (entry.name === "node_modules" || entry.name === "dist") continue;
      walk(p);
    } else if (exts.includes(path.extname(entry.name))) {
      const text = fs.readFileSync(p, "utf8");
      let m;
      while ((m = T_CALL.exec(text))) {
        usedKeys.add(m[2]);
      }
    }
  }
}

walk(SRC_DIR);

// ---------- Helpers to load & write lang files ----------
function isLangFile(name) {
  return name.endsWith(".js") && !/useI18n\.js$/i.test(name);
}
function toModuleURL(filePath) {
  return pathToFileURL(filePath).href;
}
async function loadLang(filePath) {
  const mod = await import(toModuleURL(filePath));
  const dict = mod?.default || {};
  const normalized = {};
  for (const [k, v] of Object.entries(dict)) {
    normalized[k] = typeof v === "string" ? v : String(v);
  }
  return normalized;
}
function writeLang(filePath, obj) {
  const sorted = Object.keys(obj)
    .sort()
    .reduce((acc, k) => {
      acc[k] = obj[k];
      return acc;
    }, {});
  const body =
    "// Auto-generated by scripts/i18n.mjs. Do not edit by hand.\n" +
    "export default " +
    JSON.stringify(sorted, null, 2) +
    ";\n";
  fs.writeFileSync(filePath, body, "utf8");
}

// ---------- OpenAI helpers ----------
let openai = null;
if (OPENAI_KEY) {
  openai = new OpenAI({ apiKey: OPENAI_KEY });
}

function chunk(arr, size) {
  const out = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

async function askJson(prompt, schemaHint = "an object mapping keys to strings") {
  if (!openai) return {};
  const res = await openai.chat.completions.create({
    model: OPENAI_MODEL,
    temperature: OPENAI_TEMPERATURE,
    response_format: { type: "json_object" },
    messages: [
      {
        role: "system",
        content:
          `You are a localization copywriter for a web app. ` +
          `Return ONLY valid JSON (${schemaHint}). Keep strings concise, natural, and product-quality. ` +
          `Preserve punctuation, capitalization, and any placeholders like {name}, {amount}, {n}, %s, %d exactly. ` +
          `Do not add extra keys.`,
      },
      { role: "user", content: prompt },
    ],
  });
  const text = res.choices?.[0]?.message?.content || "{}";
  try {
    return JSON.parse(text);
  } catch {
    return {};
  }
}

async function fillEnglish(keys) {
  const out = {};
  for (const group of chunk(keys, BATCH_SIZE)) {
    const prompt =
      `For each key, produce an English UI string (microcopy). ` +
      `Be terse where appropriate (button labels, placeholders) and clear for longer texts.\n\n` +
      JSON.stringify({ keys: group }, null, 2);
    const json = await askJson(prompt);
    Object.assign(out, json);
  }
  return out;
}

async function translateTo(langCode, englishPairs) {
  const out = {};
  const keys = Object.keys(englishPairs);
  for (const keyGroup of chunk(keys, BATCH_SIZE)) {
    const batchToTranslate = {};
    for (const k of keyGroup) {
      batchToTranslate[k] = englishPairs[k];
    }
    const prompt =
      `Translate the values in the following JSON object to ${langCode}. ` +
      `Return a JSON object with the same keys, but with translated string values. ` +
      `Keep placeholders (like {amount}, {n}, %s, %d) unchanged. ` +
      `Use natural ${langCode} for a consumer web app (not formal/legal).\n\n` +
      JSON.stringify(batchToTranslate, null, 2);
    const json = await askJson(prompt);
    Object.assign(out, json);
  }
  return out;
}

// ---------- Main ----------
(async function main() {
  // Sanity
  if (!fs.existsSync(I18N_DIR)) {
    console.error(`[i18n] Not found: ${path.relative(ROOT, I18N_DIR)}`);
    process.exit(1);
  }

  const langFiles = fs.readdirSync(I18N_DIR).filter(isLangFile);
  if (langFiles.length === 0) {
    console.error("[i18n] No language files found in src/i18n");
    process.exit(1);
  }

  const enPath = path.join(I18N_DIR, "en.js");
  if (!fs.existsSync(enPath)) {
    console.error("[i18n] Missing src/i18n/en.js (source of truth)");
    process.exit(1);
  }

  // Load all dicts
  const dicts = {};
  for (const f of langFiles) {
    dicts[f] = await loadLang(path.join(I18N_DIR, f));
  }

  const desiredKeys = new Set(usedKeys);

  // ---------- 1) Clean English (keep only used, mark missing & "???" as missing) ----------
  const enOrig = dicts["en.js"] || {};
  const enNew = {};
  const missingEn = [];

  for (const k of desiredKeys) {
    const v = enOrig[k];
    const isMissingValue =
      v == null || (typeof v === "string" && (v.trim() === "" || v.trim() === "???"));
    if (isMissingValue) {
      enNew[k] = "???";
      missingEn.push(k);
    } else {
      enNew[k] = v;
    }
  }

  writeLang(enPath, enNew);

  // ---------- 2) Fill English "???" via OpenAI ----------
  if (missingEn.length > 0) {
    if (!openai) {
      console.warn(
        "[i18n] OPENAI_API_KEY not set; skip filling English. Set it in .env to auto-fill."
      );
    } else {
      console.log(`[i18n] Filling ${missingEn.length} missing English strings...`);
      const filled = await fillEnglish(missingEn);
      let filledCount = 0;
      for (const k of missingEn) {
        const candidate = filled[k];
        if (typeof candidate === "string" && candidate.trim()) {
          enNew[k] = candidate.trim();
          filledCount++;
        }
      }
      if (filledCount > 0) {
        writeLang(enPath, enNew);
        console.log(`[i18n] Filled ${filledCount} English strings.`);
      }
    }
  } else {
    console.log("[i18n] No missing English strings to fill.");
  }

  // ---------- 2.5) Detect 'force retranslate' flags on English ('!…') ----------
  // Only applicable when NOT in en-only mode.
  const flaggedKeys = new Set();
  const cleanFlagText = {};
  if (!onlyEnglish) {
    for (const k of Object.keys(enNew)) {
      const v = enNew[k];
      if (typeof v === "string" && v.startsWith("!")) {
        flaggedKeys.add(k);
        cleanFlagText[k] = v.slice(1).trim(); // the source text to re-translate from English
      }
    }
  }

  // ---------- 3) For each non-English, prune + add "???" + translate from English ----------
  if (onlyEnglish) {
    console.log("[i18n] 'en' parameter detected. Skipping translation for other languages.");
    return;
  }

  // We'll track which flagged keys succeeded in ALL languages,
  // so we can safely strip '!' from English afterwards.
  const maybeStripBang = new Set(flaggedKeys); // remove any key that fails in a language

  for (const f of langFiles) {
    if (f === "en.js") continue;

    const langPath = path.join(I18N_DIR, f);
    const langCode = path.basename(f, ".js");
    const langDict = dicts[f] || {};

    // Prune/prepare
    const out = {};
    const toTranslate = {};

    for (const k of desiredKeys) {
      const v = langDict[k];
      const enVal = enNew[k];

      // Should we force re-translate this key (English starts with '!')?
      const forceRetranslate = flaggedKeys.has(k);

      // Missing?
      const isMissing =
        v == null ||
        (typeof v === "string" && (v.trim() === "" || v.trim() === "???"));

      if (forceRetranslate) {
        // Mark as missing to ensure we overwrite; queue clean English for translation
        out[k] = "???";
        if (cleanFlagText[k]) toTranslate[k] = cleanFlagText[k];
      } else if (isMissing) {
        out[k] = "???";
        if (typeof enVal === "string" && enVal.trim() && enVal !== "???") {
          toTranslate[k] = enVal;
        }
      } else {
        out[k] = v;
      }
    }

    writeLang(langPath, out);
    const toTranslateCount = Object.keys(toTranslate).length;

    if (toTranslateCount === 0) {
      console.log(`[i18n] ${langCode}: nothing to translate.`);
      // If there are flagged keys but nothing to translate for this lang,
      // we consider it a failure for those keys because they remained as-is.
      for (const k of flaggedKeys) {
        if (out[k] === "???") maybeStripBang.delete(k);
      }
      continue;
    }

    if (!openai) {
      console.warn(`[i18n] ${langCode}: OPENAI_API_KEY not set; skip translation.`);
      // Mark all flagged keys as failed for this language.
      for (const k of flaggedKeys) {
        if (out[k] === "???") maybeStripBang.delete(k);
      }
      continue;
    }

    console.log(`[i18n] ${langCode}: translating ${toTranslateCount} keys...`);
    const translated = await translateTo(langCode, toTranslate);
    let translatedCount = 0;

    for (const key of Object.keys(toTranslate)) {
      const t = translated[key];
      if (typeof t === "string" && t.trim()) {
        out[key] = t.trim();
        translatedCount++;
      } else {
        // translation for this key failed → don't strip '!' later
        if (flaggedKeys.has(key)) maybeStripBang.delete(key);
      }
    }

    // Any flagged key that still left as "???" is a failure for this language
    for (const k of flaggedKeys) {
      if (out[k] === "???") maybeStripBang.delete(k);
    }

    if (translatedCount > 0) {
      writeLang(langPath, out);
    }
    console.log(`[i18n] ${langCode}: translated ${translatedCount} keys.`);
  }

  // ---------- 4) If all non-English languages were updated for a flagged key, strip '!' in English ----------
  if (maybeStripBang.size > 0) {
    let changed = 0;
    for (const k of maybeStripBang) {
      const v = enNew[k];
      if (typeof v === "string" && v.startsWith("!")) {
        const cleaned = v.slice(1).trim();
        enNew[k] = cleaned || v; // don't produce empty
        changed++;
      }
    }
    if (changed > 0) {
      writeLang(enPath, enNew);
      console.log(`[i18n] Removed leading '!' from ${changed} English key(s) after successful re-translation.`);
    }
  }
})().catch((err) => {
  console.error(err);
  process.exit(1);
});
