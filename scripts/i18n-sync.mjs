#!/usr/bin/env node
/**
 * i18n sync:
 * - Scan source files for t("key") usages
 * - Keep only used keys in en.js (and other languages)
 * - Add missing keys to non-English languages with value "???"
 * - Sort keys alphabetically
 *
 * Usage:
 *   node scripts/i18n-sync.mjs           # rewrite lang files
 *   node scripts/i18n-sync.mjs --dry     # show changes only
 */
import fs from "node:fs";
import path from "node:path";
import { pathToFileURL } from "node:url";

const ROOT = process.cwd();
const SRC_DIR = path.join(ROOT, "src");
const I18N_DIR = path.join(SRC_DIR, "i18n");

const DRY = process.argv.includes("--dry");

// 1) Collect used keys from source by scanning t("...") calls
const exts = [".js", ".jsx", ".ts", ".tsx"];
const usedKeys = new Set();

function walk(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      // skip node_modules just in case someone copied examples into src
      if (entry.name === "node_modules") continue;
      walk(p);
    } else if (exts.includes(path.extname(entry.name))) {
      const text = fs.readFileSync(p, "utf8");
      // match t("foo.bar") and t('foo.bar')
      const re = /\bt\(\s*(['"])([^'"]+)\1\s*\)/g;
      let m;
      while ((m = re.exec(text))) {
        usedKeys.add(m[2]);
      }
    }
  }
}

walk(SRC_DIR);

// 2) Load language files (ESM default exports)
//    (ignore non-dictionary files like useI18n.js)
function isLangFile(name) {
  return name.endsWith(".js") && !/useI18n\.js$/i.test(name);
}

function toModuleURL(filePath) {
  return pathToFileURL(filePath).href;
}

async function loadLang(filePath) {
  const mod = await import(toModuleURL(filePath));
  const dict = mod?.default || {};
  // force string values only; non-strings converted to string
  const normalized = {};
  for (const [k, v] of Object.entries(dict)) {
    normalized[k] = typeof v === "string" ? v : String(v);
  }
  return normalized;
}

// 3) Write a sorted object as ESM export default
function writeLang(filePath, obj) {
  const sorted = Object.keys(obj).sort().reduce((acc, k) => {
    acc[k] = obj[k];
    return acc;
  }, {});
  const body =
    "// Auto-generated by i18n-sync.mjs. Do not edit by hand.\n" +
    "export default " +
    JSON.stringify(sorted, null, 2) +
    ";\n";
  if (DRY) {
    console.log(`\n[DRY] Would write ${path.relative(ROOT, filePath)}:\n${body}`);
  } else {
    fs.writeFileSync(filePath, body, "utf8");
    console.log(`[i18n] Updated ${path.relative(ROOT, filePath)} (${Object.keys(sorted).length} keys)`);
  }
}

(async function main() {
  // assert i18n dir exists
  if (!fs.existsSync(I18N_DIR)) {
    console.error(`[i18n] Not found: ${path.relative(ROOT, I18N_DIR)}`);
    process.exit(1);
  }

  // find lang files
  const langFiles = fs.readdirSync(I18N_DIR).filter(isLangFile);
  if (langFiles.length === 0) {
    console.error("[i18n] No language files found in src/i18n");
    process.exit(1);
  }

  // ensure English exists
  const enPath = path.join(I18N_DIR, "en.js");
  if (!fs.existsSync(enPath)) {
    console.error("[i18n] Missing src/i18n/en.js (source of truth)");
    process.exit(1);
  }

  // load all dictionaries
  const dicts = {};
  for (const f of langFiles) {
    dicts[f] = await loadLang(path.join(I18N_DIR, f));
  }

  const en = dicts["en.js"];
  if (!en) {
    console.error("[i18n] Failed to load en.js");
    process.exit(1);
  }

  // 4) Compute the final set of keys we actually want to keep,
  //    based on real usage in code.
  //    (Only keys referenced by t("...") are kept.)
  const desiredKeys = new Set(usedKeys);

  // 5) Prune + fill for each language
  for (const f of langFiles) {
    const langDict = dicts[f];

    // prune: drop anything not used
    const pruned = {};
    for (const k of desiredKeys) {
      if (langDict[k] != null) {
        pruned[k] = langDict[k];
      }
    }

    // For all languages (including English): add missing keys as "???"
    for (const k of desiredKeys) {
      if (pruned[k] == null) pruned[k] = "???";
    }

    // write back sorted
    writeLang(path.join(I18N_DIR, f), pruned);
  }
  // 6) Report summary
  console.log("\n[i18n] Done.");
  console.log(`[i18n] Used keys found: ${desiredKeys.size}`);
  if (DRY) console.log("[i18n] (dry run, no files were modified)");
})().catch((err) => {
  console.error(err);
  process.exit(1);
});
