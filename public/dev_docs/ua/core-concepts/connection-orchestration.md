<!-- public/dev_docs/ua/core-concepts/connection-orchestration.md -->

# Оркестрація з'єднання, зберігання `/info` та конфігурація домену

Ця сторінка пояснює, як саме застосунок завантажується, підключається до бекенду, обирає домен та як він зберігає/використовує відповідь `/info` від бекенду та конфігурацію домену. Вона написана для професійних інженерів, які потребують розширення або налагодження цього процесу.

> **TL;DR** — Існує єдиний оркестратор (`useAppOrchestrator`), який:
>
> * читає `/default_connect.yaml` (+ необов'язкове локальне переопределення),
> * конфігурує HTTP/WS кінцеві точки,
> * отримує `/info`,
> * завершує налаштування домену,
> * обирає базу активів (prod/test), завантажує пакет домену,
> * повторно підключає WebSocket, і
> * (при явному переключенні) переходить на `/`.

---

## Терміни та примітиви

* **Бекенд** — вузол SAVVA (HTTP API + WebSocket).
* **Домен** — яка мережа (брендинг, вкладки, активи) має бути відображена.
* **Пакет домену** — папка `\<assetsBase\>/\<domain\>/` з `config.yaml`, `domain.css`, i18n, зображеннями, модулями тощо. Застосунок може завантажувати пакети з **prod** (`assets_url`) або **test** (`temp_assets_url`).
* **Переопределення** — невеликий знімок `{ backendLink, domain }`, збережений у `localStorage` під ключем `connect_override`.

---

## Карта файлів (де що знаходиться)

* **Оркестратор (джерело істини):** `src/context/useAppOrchestrator.js` — логіка завантаження та перемикання, `/info`, середовище активів, пакет домену, повторне підключення WS. Відкриває `initializeOrSwitch()`, `setDomain()`, `clearConnectOverride()`, та сигнали для `config`, `info`, `assetsEnv`, `domainAssets*`.
* **Обгортка контексту застосунку:** `src/context/AppContext.jsx` — споживає оркестратор і виводить `supportedDomains`, `selectedDomain`, ланцюг/мережу, IPFS шлюзи та `assetUrl()`; також забезпечує консистентність авторизації при змінах домену.
* **HTTP/WS кінцеві точки:** `src/net/endpoints.js` — обчислює `httpBase()` та `wsUrl()` з `{ backendLink, domain }`, надсилає подію зміни при переналаштуванні та надає допоміжні функції.
* **Час виконання WebSocket:** реагує на зміни кінцевих точок і повторно підключається відповідно.
* **UI перемикання:** `src/x/modals/SwitchConnectModal.jsx` — отримує `<backend>/info`, нормалізує список доменів і застосовує зміни через API застосунку.
* **Головна оболонка:** динамічно застосовує `domain.css`, фавікони/мета, GA та прив'язує з'єднувач WS.
* **Спадкова примітка.** Ви можете побачити старий хук `useAppConnection`; продовжуйте використовувати **оркестратор** (поточний дизайн) як єдине джерело істини.

---

## 1) Послідовність завантаження — крок за кроком

Оркестратор запускається один раз при монтуванні:

1. **Завантажити стандартні налаштування сайту**
   `GET /default_connect.yaml`, розпарсити `backendLink`, `domain`, та (необов'язково) `gear`. Ці значення комбінуються з збереженим **переопределенням** (якщо є).

2. **Нормалізувати та попередньо налаштувати кінцеві точки (перед `/info`)**
   Перед `/info` ми налаштовуємо кінцеві точки, використовуючи **запитуваний** домен як єсть:
   `configureEndpoints({ backendLink, domain }, "orch:pre-info")`. Це обчислює `httpBase()` та `wsUrl()` і надсилає подію зміни, щоб час виконання міг вказати на правильний сервер.

3. **Отримати `/info`**
   `GET <backendLink>/info` (без кешу). JSON зберігається в `orchestrator.info`.

4. **Визначити остаточний домен**
   Якщо користувач явно запитав домен, він **вшановується**; в іншому випадку ми обираємо **перший** домен з `/info.domains` (якщо є). Визначене `{ backendLink, domain }` стає `config`. Якщо це було перемикання, ми **зберігаємо** переопределення.

5. **Завершити налаштування кінцевих точок (після `/info`)**
   Повторно виконуємо `configureEndpoints` з **остаточним** доменом. Усі HTTP виклики повинні використовувати `httpBase()`, а **WS URL включає** `?domain=...`.

6. **Середовище активів → завантажити пакет домену**
   Обираємо базу з `/info`: `assets_url` (prod) або `temp_assets_url` (test). Спробуйте `\<assetsBase\>/\<domain\>/config.yaml`, в іншому випадку поверніться до `/domain_default/config.yaml`. Зберігайте `domainAssetsPrefix`, `domainAssetsConfig` та джерело (`domain` проти `default`).

7. **Примусове повторне підключення WS**
   Оновіть URL клієнта ws, повторно підключіться, чекайте відкриття (до ~8 секунд). Це забезпечує синхронізацію часу виконання з новим доменом та бекендом.

8. **Навігація**
   При явному перемиканні перейдіть на `/` (зберігає стан маршрутизації в нормі після значної зміни контексту).

> Оркестратор відкриває той самий API для повторного виконання цієї послідовності в будь-який час; `setDomain()` використовує той самий шлях під капотом.

---

## 2) Обчислення кінцевих точок (HTTP та WS)

`src/net/endpoints.js` — це **єдине** місце, яке знає активну базу та URL ws:

### `configureEndpoints({ backendLink, domain }, reason)`

* Нормалізує базу (забезпечує `https://…/`).
* Зберігає **домен** (рядок).
* Виводить URL WebSocket (`ws:`/`wss:`) з `?domain=<name>&space=public`.
* Надсилає подію `ENDPOINTS_CHANGED`.

Весь інший код викликає геттери (`httpBase()`, `wsUrl()`, `wsQuery()`) та/або підписується на зміни.

### Час виконання WS реагує на зміни

Час виконання слухає зміни кінцевих точок і може повторно підключитися. Оркестратор також явно встановлює URL і викликає `reconnect`.

### HTTP виклики

Для кінцевих точок, які вимагають `domain` у запиті (авторизація, перевірки адміністратора тощо), викликачі прикріплюють його через `URLSearchParams` до `httpBase()`. (Дивіться приклади в `auth.js`.)

---

## 3) `/info` — Що ми зберігаємо і як ми це використовуємо

Сирий JSON `/info` зберігається як **сигнал**: `orchestrator.info()`.

**Типова форма (скорочена):**

```json
{
  "domains": ["savva.app", {"name":"art.savva"}],
  "blockchain_id": 369,
  "ipfs_gateways": ["https://cloudflare-ipfs.com/ipfs/"],
  "assets_url": "https://cdn…/assets/",
  "temp_assets_url": "https://cdn…/assets-test/"
}
```

**Де це використовується:**

* **Домен** — `AppContext` виводить `supportedDomains` (нормалізовані, без дублікатів) та `selectedDomain`. Якщо `config.domain` встановлено, він має перевагу; в іншому випадку використовується перший підтримуваний домен.
* **Ланцюг/мережа** — `desiredChainId = info.blockchain_id` → `desiredChain()` виводить повну метадані; `ensureWalletOnDesiredChain()` може бути викликано перед потоками tx.
* **IPFS шлюзи** — `remoteIpfsGateways` походить з `info.ipfs_gateways`, а `activeIpfsGateways` необов'язково попередньо додає **локальний** шлюз, якщо це дозволено в налаштуваннях.
* **База активів** — Оркестратор обирає `assets_url` (prod) або `temp_assets_url` (test), обчислює `\<assetsBase\>/\<domain\>/`, а потім завантажує пакет домену. Активний префікс + розпарсена конфігурація публікуються через `domainAssetsPrefix()` / `domainAssetsConfig()`.
* **Функції застосунку, що використовують `/info`** — наприклад, відображення цін токенів шукає `/info.savva_contracts.SavvaToken.address`, щоб помістити базовий токен SAVVA в таблицю цін.

---

## 4) Конфігурація домену — зберігання та споживання

Після кроку (6) у процесі завантаження застосунок має:

* `assetsEnv()` — `"prod"` або `"test"` (перемикається в налаштуваннях, використовується адміністраторами).
* `assetsBaseUrl()` — обчислено з `/info` + середовища.
* `domainAssetsPrefix()` — або `\<assetsBase\>/\<domain\>/` або `/domain_default/`.
* `domainAssetsConfig()` — розпарсений `config.yaml`.

### Що читає конфігурацію домену?

* **CSS та брендинг**

  * `DomainCssLoader` завантажує `assetUrl("domain.css")`, з кешем, що скидається з ревізією `(env|domain|assets_cid)`.
  * `FaviconLoader` читає секцію `favicon` (розміри іконок, маніфест, маска іконки, мета) та оновлює `<link rel="icon">` тощо; URL-адреси вирішуються через `assetUrl(relPath)` та скидаються з кешу.

* **Міжнародалізація (мови за доменами)**

  * При кожному завантаженні конфігурації застосунок публікує коди мов домену в систему i18n та коригує документ `<title>` на `title` поточної локалі. Він також **перевіряє** поточну мову на новий домен і переключається на підтримувану, коли це необхідно.

* **Модулі / Вкладки**

  * Головна навігаційна панель (`TabsBar`) читає `config.modules.tabs` (за замовчуванням `modules/tabs.yaml`) і завантажує YAML через **завантажувач активів** за допомогою `assetUrl()`. Вкладки локалізуються через ключі i18n та/або метадані за вкладками.

* **HTML блоки та інші активи**

  * Віджети (наприклад, `HtmlBlock`) викликають `loadAssetResource(app, relPath)`, що вирішує відносні шляхи через `assetUrl()` і отримує текст/YAML відповідно.

> Активний `assetUrl(relPath)` — це **лише** `domainAssetsPrefix()` + `relPath` (без ведучого `/`); це забезпечує консистентність усіх споживачів.

### Налаштування → Активи (діагностика)

Адміністратори можуть перемикати **prod/test**, бачити **активний префікс/джерело** та виконувати діагностику, що підтверджує наявність ключових полів (логотипи, локалі, вкладки, фавікон). Цей перегляд читає *лише* опубліковані сигнали оркестратора.

---

## 5) Як працює перемикання (бекенд/домен)

### Потік UI

1. Діалог **Перемикання бекенду / домену** приймає URL бекенду.
2. Викликає `<backend>/info`, щоб заповнити нормалізований список доменів (`[{name, …}]`).
3. Застосовує вибір, викликавши API застосунку.

### Потік оркестратора

* Якщо **бекенд** змінився, ми спочатку **виходимо**, щоб уникнути стану кук між бекендами.
* Попередньо налаштовуємо кінцеві точки (запитуваний домен), отримуємо `/info`, визначаємо остаточний домен.
* Зберігаємо переопределення, встановлюємо `config`, **завершуємо налаштування кінцевих точок**, завантажуємо пакет домену, **повторно підключаємо WS**, переходимо додому.

### Консистентність авторизації

Якщо користувач увійшов в систему, і **домен** у `config` змінюється, застосунок проактивно виходить, щоб уникнути дій у невідповідному контексті. Тост пояснює чому.

---

## 6) `AppContext` — На що може покладатися ваш код

`useApp()` відкриває стабільну поверхню, підтримувану оркестратором:

* **Стан з'єднання:** `loading()`, `error()`, `config()`, `info()` (сирий `/info`).
* **Домен:** `supportedDomains()`, `selectedDomain()`, `selectedDomainName()`.
* **Мережа:** `desiredChainId()`, `desiredChain()`, `ensureWalletOnDesiredChain()`.
* **IPFS:** `remoteIpfsGateways()`, `activeIpfsGateways()`.
* **Активи:** `assetsEnv()`, `assetsBaseUrl()`, `domainAssetsPrefix()`, `domainAssetsConfig()`, та `assetUrl(relPath)`.
* **API перемикання:** `initializeOrSwitch(newSettings)`, `setDomain(name)`, `clearConnectOverride()`.
* **Допоміжні функції i18n:** `t(key, vars?)`, `lang()`, `setLang(code)`.

### Приклад: завантаження фрагмента YAML з пакету домену

```js
// (не компонент, лише ескіз)
// Усі видимі рядки повинні бути локалізовані; тут жоден не показується користувачу.
import { useApp } from "../context/AppContext.jsx";
import { loadAssetResource } from "../utils/assetLoader.js";

async function loadDomainTabs() {
  const app = useApp();
  const rel = app.domainAssetsConfig?.()?.modules?.tabs || "modules/tabs.yaml";
  const data = await loadAssetResource(app, rel, { type: "yaml" });
  return Array.isArray(data?.tabs) ? data.tabs : [];
}
```

### Приклад: створення авторизованого виклику, що вимагає домен

```js
// Усі рядки, видимі користувачу, повинні бути локалізовані через t():
import { useApp } from "../context/AppContext.jsx";

async function fetchAdminFlag(address) {
  const { t } = useApp();
  const url = new URL(`${httpBase()}is-admin`);
  url.searchParams.set("address", address);
  url.searchParams.set("domain", useApp().selectedDomainName());
  const res = await fetch(url, { credentials: "include" });
  if (!res.ok) throw new Error(t("error.connection.message"));
  return (await res.json())?.admin === true;
}
```

---

## 7) Обробка помилок та порожні стани

Коли з'єднання не вдається під час завантаження (наприклад, неправильно сформований YAML, `/info` недоступний), `AppContext` відкриває `error()` і оболонка відображає центровану картку помилки з рядками i18n та кнопкою **Спробувати знову**.

---

## 8) Примітки щодо i18n та UX інваріантів

* **Кожен** рядок, видимий користувачу в коді UI, повинен бути `t("…")` з `useApp()` (навігація, налаштування, тости тощо).
* `document.title` походить з локалізованого `title` конфігурації домену. Зміна **домену** або **середовища** миттєво оновлює брендинг без повторної збірки.

---

## 9) Довідкові фрагменти

* Попереднє налаштування → `/info` → остаточне налаштування — основа оркестратора.
* База активів та резервний пакет домену — оркестратор.
* Кінцеві точки та URL WS (`?domain=...`) — єдине джерело.
* Час виконання WS + повторне підключення при зміні кінцевих точок — деталі часу виконання.
* Діалог перемикання `/info` отримання та нормалізація домену — деталі UI.

---

## 10) Операційний контрольний список

* Щоб змінити стандартні налаштування в розгортанні, оновіть **`/default_connect.yaml`** на веб-сервері хостингу.
* Щоб перемикати в режимі виконання, використовуйте **Діалог перемикання** (шестерня повинна бути активована YAML сайту).
* Щоб переглянути пакет домену, перемкніть **Налаштування → Активи → Середовище: Тест**. Застосунок завантажить з `temp_assets_url`.
* Якщо ви перемикаєте **бекенд**, застосунок **виходить** спочатку, щоб уникнути кук між бекендами.

---

## Додаток: Модель даних на погляд

```ts
// Спрощена концептуальна модель

type AppConfig = {
  backendLink: string;   // нормалізовано з ведучим слешем
  domain: string;        // обране ім'я домену
  gear: boolean;         // UI шестерня активована (з YAML сайту)
};

type Info = {
  domains: Array<string | { name: string; website?: string }>;
  blockchain_id?: number;
  ipfs_gateways?: string[];
  assets_url?: string;
  temp_assets_url?: string;
  // ...інші поля (наприклад, savva_contracts)
};

type Orchestrator = {
  config(): AppConfig | null;
  info(): Info | null;
  loading(): boolean;
  error(): Error | null;

  // оркестрація
  initializeOrSwitch(newSettings?: Partial<AppConfig>): Promise<void>;
  setDomain(name: string): Promise<void>;
  clearConnectOverride(): void;

  // активи
  assetsEnv(): "prod" | "test";
  setAssetsEnv(next: "prod" | "test"): void;
  assetsBaseUrl(): string;
  domainAssetsPrefix(): string;           // '/domain_default/' або '<assetsBase>/<domain>/'
  domainAssetsConfig(): any | null;       // розпарсений config.yaml
};
```

---

Це повна картина. З цими примітивами ви можете безпечно розширювати UI, впевнений, що кінцеві точки, `/info` та ресурси домену залишаються **послідовними** та **реактивними** по всьому застосунку.