# Ініціалізація додатка та підключення до бекенду

## Що таке SAVVA бекенд (SAVVA нода)?
SAVVA бекенд — це серверний компонент, який **індексує/кешує дані, отримані з активності блокчейну**, і надає швидкі, орієнтовані на інтерфейс API та WebSocket-методи. Один бекенд може обслуговувати **кілька SAVVA доменів** — уявіть «домен» як окрему SAVVA соціальну мережу (брендинг, вкладки, активи, налаштування за замовчуванням), усі вони підтримуються однією нодою.

## Що потрібно додатку при запуску
При старті вебдодатку потрібні два вхідні параметри:

1. **URL бекенду** – базовий URL SAVVA бекенду.
2. **Ім'я домену** – який домен SAVVA (соцмережу) відображати за замовчуванням.

Значення за замовчуванням беруться з невеликого YAML-файлу у корені вебсерверу:

### `/default_connect.yaml`
```yaml
# /default_connect.yaml
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
# optional:
# default_ipfs_link: ipfs://bafy.../something.json
````

* `backendLink` — базовий HTTP-ендпоінт SAVVA бекенду (додаток нормалізує його).
* `domain` — початковий домен для відображення; його можна переключити пізніше в інтерфейсі.
* `gear` — вмикає інструменти розробника в інтерфейсі (необов'язково).
* `default_ipfs_link` — необов'язковий зручний дефолт, який використовується в деяких сценаріях.

> **Примітка для продакшену**
> У продакшені цей файл зазвичай віддає ваш HTTP-сервер (наприклад, Nginx) і фактично **визначає, який домен** показуватиме розгорнутий вебдодаток за замовчуванням. Один із поширених підходів — віддати конкретний файл з диска:
>
> ```nginx
> # example: serve a static default_connect.yaml
> location = /default_connect.yaml {
>   default_type text/yaml;
>   alias /etc/savva/default_connect.yaml;
> }
> ```
>
> Налаштуйте під вашу інфраструктуру; головне — щоб додаток міг зробити `GET /default_connect.yaml`.

---

## Послідовність запуску

1. **Завантажити `/default_connect.yaml`**
   Додаток завантажує YAML-файл, перевіряє `backendLink` та зберігає `domain`. Він одразу **налаштовує кінцеві точки** (HTTP базу + WS URL) використовуючи ці значення. &#x20;

2. **Налаштування кінцевих точок**

   * `httpBase` — нормалізована версія `backendLink` (гарантовано з кінцевим слешем).
   * `ws` URL виводиться з тієї самої бази, вказує на `.../ws` (протокол змінюється на `ws:` або `wss:`) і включає `?domain=...` у рядку запиту.
     Це забезпечує **єдине джерело правди** для HTTP та WS.&#x20;

3. **Отримати `/info`**
   Після встановлення кінцевих точок додаток виконує `GET <httpBase>info` і зберігає JSON. Від цього моменту **/info керує поведінкою під час виконання** (домени, мережа, IPFS, активи).&#x20;

4. **Вивести стан виконання з `/info`**
   Використовуються такі поля (див. приклад нижче):

   * **`domains`** → Список доступних доменів. Інтерфейс віддає перевагу явно вказаному `domain` з YAML/перезапису; якщо його немає в `/info`, додаток усе одно використовує його.&#x20;
   * **`blockchain_id`** → Цільовий ID EVM-мережі. Помічник гаманця може переключити/додати цю мережу.&#x20;
   * **`ipfs_gateways`** → Віддалені IPFS-шлюзи, які слід пробувати у вказаному порядку (якщо не увімкнено локальний перезапис IPFS).&#x20;
   * **`assets_url`** та **`temp_assets_url`** → **База активів** (prod vs test). Додаток обчислює **активний префікс активів домену** як
     `(<assets base> + <domain> + "/")` з **резервним варіантом** `/domain_default/`, якщо віддалений `config.yaml` відсутній. &#x20;

5. **Завантаження активів домену та конфігурації**
   Додаток намагається завантажити `(<active prefix>/config.yaml)` з коротким таймаутом; у разі невдачі він повертається до пакета за замовчуванням на `/domain_default/config.yaml`. Розпарсений результат конфігу (логотипи, вкладки, локалі тощо) зберігається, і інтерфейс відображається відповідно.&#x20;

6. **WebSocket під час виконання**
   WS-клієнт використовує обчислений `ws` URL з кінцевих точок; коли змінюється бекенд/домен, кінцеві точки перераховуються, і WS-шар підхоплює зміни.&#x20;

---

## Приклад `/info` (ілюстративно)

```json
{
  "domains": [
    "savva.app",
    {"name": "art.savva"},
    "dev.savva"
  ],
  "blockchain_id": 369,
  "ipfs_gateways": [
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/"
  ],
  "assets_url": "https://cdn.savva.network/assets/",
  "temp_assets_url": "https://cdn.savva.network/assets-test/"
}
```

### Поле за полем (що додаток робить із цими даними)

* **domains** — список вибіркових доменів. Діалог «Переключити бекенд/домен» наповнюється з `/info`, але налаштований домен все ще має перевагу, якщо `/info` відстає. &#x20;
* **blockchain_id** — числовий ID EVM-мережі; використовується для формування метаданих для `switch/add chain` та для перевірки, що гаманець знаходиться в **потрібній мережі**. &#x20;
* **ipfs_gateways** — упорядкований список віддалених шлюзів; у поєднанні з необов'язковим перезаписом **Local IPFS** (коли увімкнено в налаштуваннях) формується **активний** порядок шлюзів.&#x20;
* **assets_url / temp_assets_url** — додаток підтримує **середовище активів** (`prod`/`test`) і обирає відповідну базу. Далі він обчислює `/<base>/<domain>/` і завантажує `config.yaml`. Якщо віддалений пакет відсутній або працює повільно, використовується **дефолтний** `/domain_default/`.&#x20;

---

## Де це зберігається в коді (для швидкого ознайомлення)

* Завантаження /boot & `/default_connect.yaml`, потім `/info`: **`src/context/AppContext.jsx`** та **`src/hooks/useConnect.js`**. &#x20;
* Джерело істини кінцевих точок (HTTP база + WS URL): **`src/net/endpoints.js`**.&#x20;
* Розв'язання списку доменів, ID ланцюга, IPFS-шлюзів, середовище активів та завантаження активів домену: **`src/context/AppContext.jsx`**.  &#x20;
* Діалог переключення, який отримує `/info` і нормалізує `domains`: **`src/x/SwitchConnectModal.jsx`**.&#x20;

---

**Далі:** у наступній главі ми розберемо **конфігурацію домену** (`config.yaml`) і як вона керує логотипами, вкладками, локалями та іншими поведінками інтерфейсу для кожного домену.