# Ініціалізація додатку та підключення до бекенду

## Що таке бекенд SAVVA (вузол SAVVA)?
Бекенд SAVVA — це серверний компонент, який **індексує/кешує дані, отримані з активності блокчейну**, та надає швидкі, зручні для користувача API та методи WebSocket. Один бекенд може обслуговувати **кілька доменів SAVVA** — уявіть собі "домен" як окрему соціальну мережу SAVVA (брендинг, вкладки, активи, значення за замовчуванням), всі з яких підтримуються одним вузлом.

## Що потрібно додатку при запуску
Під час запуску веб-додатку потрібно два параметри:

1. **URL бекенду** – базовий URL бекенду SAVVA.
2. **Ім'я домену** – який домен SAVVA (соціальна мережа) відображати за замовчуванням.

Значення за замовчуванням беруться з маленького YAML файлу в корені веб-додатку:

### `/default_connect.yaml`
```yaml
# /default_connect.yaml
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
# optional:
# default_ipfs_link: ipfs://bafy.../something.json
```

* `backendLink` — базова HTTP точка доступу бекенду SAVVA (додаток нормалізує її).
* `domain` — початковий домен для відображення; його можна змінити пізніше в інтерфейсі.
* `gear` — активує інструменти розробника в інтерфейсі (необов'язково).
* `default_ipfs_link` — необов'язкове зручне значення за замовчуванням, яке використовується в деяких потоках.

> **Примітка для виробництва**
> У виробництві цей файл зазвичай обслуговується вашим HTTP сервером (наприклад, Nginx) і фактично **вибирає, який домен** веб-додаток показує за замовчуванням. Один поширений шаблон — обслуговувати конкретний файл з диска:
>
> ```nginx
> # приклад: обслуговувати статичний default_connect.yaml
> location = /default_connect.yaml {
>   default_type text/yaml;
>   alias /etc/savva/default_connect.yaml;
> }
> ```
>
> Налаштуйте відповідно до вашої інфраструктури; ключовим є те, що додаток може `GET /default_connect.yaml`.

---

## Послідовність запуску

1. **Завантажити `/default_connect.yaml`**
   Додаток отримує YAML файл, перевіряє `backendLink` і зберігає `domain`. Він негайно **конфігурує кінцеві точки** (базовий HTTP + URL WS), використовуючи ці значення. &#x20;

2. **Конфігурувати кінцеві точки**

   * `httpBase` — це нормалізована версія `backendLink` (гарантований слеш наприкінці).
   * URL `ws` отримується з тієї ж бази, вказуючи на `.../ws` (протокол змінюється на `ws:` або `wss:`) і включає `?domain=...` в запиті.
     Це забезпечує **одне джерело правди** для HTTP та WS.&#x20;

3. **Отримати `/info`**
   З установленими кінцевими точками додаток викликає `GET <httpBase>info` і зберігає JSON. З цього моменту **/info визначає поведінку під час виконання** (домени, ланцюг, IPFS, активи).&#x20;

4. **Визначити стан під час виконання з `/info`**
   Використовуються наступні поля (див. приклад нижче):

   * **`domains`** → Список доступних доменів. Інтерфейс надає перевагу явному `domain` з YAML/перезапису; якщо його немає в `/info`, він все ще використовується.&#x20;
   * **`blockchain_id`** → Цільовий ID ланцюга EVM. Допоміжна програма гаманця може перемикати/додавати цю мережу.&#x20;
   * **`ipfs_gateways`** → Віддалені IPFS шлюзи, які потрібно спробувати в порядку (якщо не увімкнено локальне переозначення IPFS).&#x20;
   * **`assets_url`** та **`temp_assets_url`** → **база активів** (продакшн проти тесту). Додаток обчислює **префікс активів активного домену** як
     `(<assets base> + <domain> + "/")` з **резервним** варіантом на `/domain_default/`, якщо віддалений `config.yaml` відсутній. &#x20;

5. **Завантажити активи домену та конфігурацію**
   Додаток намагається `(<active prefix>/config.yaml)` з коротким таймаутом; у разі невдачі він повертається до стандартного пакету за адресою `/domain_default/config.yaml`. Результуюча розібрана конфігурація (логотипи, вкладки, локалі тощо) зберігається, і інтерфейс відображається відповідно.&#x20;

6. **Час виконання WebSocket**
   Клієнт WS використовує обчислений `ws` URL з кінцевих точок; коли бекенд/домен змінюється, кінцеві точки перераховуються, і шар WS це підхоплює.&#x20;

---

## Приклад `/info` (ілюстративний)

```json
{
  "domains": [
    "savva.app",
    {"name": "art.savva"},
    "dev.savva"
  ],
  "blockchain_id": 369,
  "ipfs_gateways": [
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/"
  ],
  "assets_url": "https://cdn.savva.network/assets/",
  "temp_assets_url": "https://cdn.savva.network/assets-test/"
}
```

### Поле за полем (що робить з ним додаток)

* **domains** — список вибиральних доменів. Діалог **Перемикання бекенду / домену** заповнюється з `/info`, але сконфігурований домен все ще має перевагу, якщо `/info` відстає. &#x20;
* **blockchain\_id** — числовий ID ланцюга EVM; використовується для створення метаданих `перемикання/додавання ланцюга` та для забезпечення того, щоб гаманець був на **необхідній мережі**. &#x20;
* **ipfs\_gateways** — впорядкований список віддалених шлюзів; в поєднанні з необов'язковим **Локальним IPFS** переозначенням (коли увімкнено в налаштуваннях) формує **активний** порядок шлюзів.&#x20;
* **assets\_url / temp\_assets\_url** — додаток підтримує **середовище активів** (`prod`/`test`) і вибирає відповідну базу. Потім він обчислює `/<base>/<domain>/` і завантажує `config.yaml`. Якщо віддалений пакет відсутній або повільний, він використовує **за замовчуванням** `/domain_default/`.&#x20;

---

## Де це знаходиться в коді (для швидкого посилання)

* Завантаження при запуску та `/default_connect.yaml`, потім `/info`: **`src/context/AppContext.jsx`** та **`src/hooks/useConnect.js`**. &#x20;
* Джерело істини для кінцевих точок (базовий HTTP + URL WS): **`src/net/endpoints.js`**.&#x20;
* Вирішення списку доменів, ID ланцюга, шлюзів IPFS, середовище активів та завантаження активів домену: **`src/context/AppContext.jsx`**.  &#x20;
* Діалог перемикання, який отримує `/info` та нормалізує `domains`: **`src/components/SwitchConnectDialog.jsx`**.&#x20;

---

**Далі:** у наступному розділі ми розглянемо **конфігурацію домену** (`config.yaml`) і як вона контролює логотипи, вкладки, локалі та інші поведінки інтерфейсу для кожного домену.