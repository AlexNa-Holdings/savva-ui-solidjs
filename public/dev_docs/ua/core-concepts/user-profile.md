# Контракт профілю користувача

Контракт `UserProfile` зберігає стан на ланцюгу, який забезпечує роботу сторінок авторів, імен та метаданих профілю в доменах SAVVA. Він поєднує глобальний реєстр імен, що легко читаються людиною, з ключово-значенним сховищем для кожного домену та легкими допоміжними функціями для аватарів і контактних даних. Ця сторінка підсумовує, як dApp взаємодіє з контрактом і JSON-об’єктами профілю, що зберігаються поруч із ним в IPFS.

## Отримання екземпляру контракту

Адреса контракту надається бекендом у відповіді `/info` під ключем `savva_contracts.UserProfile`. Фронтенд-код отримує її через спільний хелпер:

```js
const userProfile = await getSavvaContract(app, "UserProfile");
```

Усі операції читання/запису, наведені нижче, використовують цей хелпер разом із утилітами маршрутизації акторів (див. `ProfileEditPage.jsx` та `userProfileStore.js`).

## Зареєстровані імена

Імена є глобально унікальними, записаними у нижньому регістрі хендлами, які реєструються безпосередньо на адреси гаманців.

- `names(address) → string` повертає поточне ім’я для адреси.
- `owners(string) → address` визначає власника імені. Обидва хелпери використовуються при завантаженні довільного профілю (див. `fetchProfileForEdit`).

Мутації:

- `setName(string name)` реєструє або оновлює хендл викликувача. UI викликає це всередині `executeSetName()` при збереженні змін профілю.
- `removeName()` видаляє запис.
- `transferName(address to)` передає резервування іншій адресі.

Оскільки імена глобальні, UI дозволяє користувачу обрати одне зареєстроване значення, а потім виводить мовно-специфічні імена з офчейн JSON профілю (описано нижче).

## Аватари та інші основні поля

Два окремі хелпери зберігають найважливіші поля на ланцюгу:

- `setAvatar(string cid)` / `avatars(address) → string` зберігають і читають IPFS CID аватара користувача. Редактор завантажує зображення на бекенд-ендпоінт зберігання, а потім викликає `setAvatar` з отриманим CID.
- `setPubKey(string modifier, string pubKey)` опційно записує пару ключів для шифрування для функцій прямого обміну повідомленнями.

Також є зручна функція `setAll(string name, string avatar, bytes32 domain, string profile)`, яка пакетно оновлює ім’я + аватар разом із профільним навантаженням для одного домену.

## Ключово-значенне сховище в межах домену

Більшість метаданих зберігається за допомогою примітивів `setString` та `setUInt`. Обидва приймають ідентифікатор домену та ключ, закодовані як `bytes32`.

```js
await userProfile.write.setString([
  toHexBytes32(app.selectedDomainName()),
  toHexBytes32("profile_cid"),
  newProfileCid,
]);
```

Приклад вище відображає те, що робить `ProfileEditPage.jsx` після завантаження JSON профілю в IPFS – CID записується під поточним доменом і ключем `profile_cid`. Читання використовує `getString`/`getUInt` з тими ж параметрами. Контракт також надає доступ до сирих публічних мапінгів (`profileString`, `profileUInt`), якщо потрібен прямий доступ без повторного обчислення ключів.

### Загальні ключі

| Ключ | Тип | Призначення |
| --- | --- | --- |
| `profile_cid` | string | Вказує на канонічний JSON-файл профілю в IPFS для вибраного домену. |
| Користувацькі ключі | string / uint | Інтегратори можуть додавати додаткові метадані для свого домену, вибираючи нові ключі – лише зберігайте їх довжину до 32 байт перед кодуванням. |

Оскільки дані індексуються за `(користувач, домен, ключ)`, різні домени SAVVA можуть підтримувати незалежні документи профілю, одночасно спільно використовуючи глобальний реєстр імен.

## Схема JSON профілю

JSON-об’єкт, що зберігається за `profile_cid`, живить багатий UI профілю в `ProfilePage.jsx`. Коли редактор профілю зберігає зміни, він генерує документ, схожий на наступний:

```json
{
  "display_names": {
    "en": "Alice Example",
    "fr": "Alice Exemple"
  },
  "about_me": {
    "en": "Writer focused on freedom of expression.",
    "es": "Escritora centrada en la libertad de expresión."
  },
  "nsfw": "h",
  "sponsor_values": [10, 25, 100],
  "links": [
    { "title": "Website", "url": "https://alice.example" },
    { "title": "Fedi", "url": "https://fedi.social/@alice" }
  ]
}
```

Ключові поля:

- `display_names` — мовно-специфічні заміни публічного імені автора. `ProfilePage` вибирає поточну мову UI, за замовчуванням англійську, а потім ім’я, зареєстроване на ланцюгу.
- `about_me` — багатомовний текст біографії, що відображається на картці профілю. Старі документи можуть використовувати один рядок `about`; UI відповідно робить відкат.
- `nsfw` — прапорець переваг (`h`, `s` тощо), що впливає на те, які пости показуються за замовчуванням.
- `sponsor_values` — цілі числові пороги (у SAVVA), що використовуються для попереднього заповнення рівнів підписки.
- `links` — довільні об’єкти зовнішніх посилань (`title` + `url`).

Ви можете розширювати документ додатковими полями для домену; код споживача має ігнорувати ключі, які він не розпізнає.

## Читання профілів у dApp

`ProfilePage.jsx` координує три джерела:

1. Вебсокетний виклик (`get-user`), який повертає поля на ланцюгу, такі як `address`, `name`, `display_names`, кешовані бекендом, статистику стейкінгу та дані підписки.
2. Пряме отримання з IPFS за CID, що зберігається під `profile_cid`, за допомогою хелперів у `userProfileStore.js`.
3. Локальні заміни з кешів `AppContext` (`userDisplayNames`), які дозволяють миттєво показувати тимчасові зміни.

Об’єднаний результат визначає, що відображається під банером автора, мовно-специфічне ім’я та всі допоміжні віджети, як-от соціальні посилання.

## Підсумок процесу редагування

Під час редагування профілю (`ProfileEditPage.jsx`):

1. UI визначає цільову адресу за іменем (через `owners(name)`), потім завантажує CID аватара, поточне ім’я та `profile_cid`.
2. Якщо CID профілю існує, JSON отримується з IPFS і нормалізується у стан редактора.
3. Збереження завантажує новий JSON-об’єкт і виконує `setString(domain, "profile_cid", cid)` через `sendAsActor`, забезпечуючи підпис транзакції поточним активним акаунтом.
4. Хелпер `applyProfileEditResult` оновлює локальні кеші, щоб нові дані були видимі без очікування повторного індексування бекенду.

Шлях завантаження аватара повторює цей процес, викликаючи `setAvatar` з отриманим CID.

## Робота з іменами та відображуваними іменами

- **Зареєстроване ім’я (`setName`)** — унікальний ідентифікатор на рівні ланцюга. Використовується для маршрутизації через URL `/@handle` і зберігається в мапінгу `names` контракту.
- **Відображувані імена (`display_names`)** — опційні мовно-специфічні мітки всередині JSON профілю. Вони переважають зареєстроване ім’я, якщо присутні.
- **Успадкований `display_name`** — старі JSON профілі можуть містити єдине поле `display_name`; UI все ще підтримує його, якщо немає мовно-специфічних значень.

При створенні інтеграцій завжди визначайте адресу на ланцюгу, якщо приймаєте введення від користувача, і перевіряйте, що ім’я вільне, перед викликом `setName`.

## Додаткові утиліти

- `setUInt` / `getUInt` віддзеркалюють хелпери для рядків, але для числових метаданих (наприклад, для відстеження лічильників по доменах).
- `setAll` може ініціалізувати ім’я, аватар і вказівник профілю одним викликом – корисно для скриптів початкового налаштування.
- `removeName` і `transferName` забезпечують керування життєвим циклом, якщо потрібно відмовитися від хендла.

За допомогою цих примітивів ви можете додавати додаткові функції, керовані профілем (бейджі, записи верифікації, офчейн атестації), визначаючи нові ключі домену, які вказують на значення на ланцюгу або додаткові документи в IPFS.