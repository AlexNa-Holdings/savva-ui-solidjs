# Инициализация приложения и подключение к бэкенду

## Что такое бэкенд SAVVA (узел SAVVA)?
Бэкенд SAVVA — это серверный компонент, который **индексирует/кэширует данные, полученные из активности блокчейна**, и предоставляет быстрые, удобные для пользователя API и методы WebSocket. Один бэкенд может обслуживать **несколько доменов SAVVA** — рассматривайте "домен" как отдельную социальную сеть SAVVA (брендинг, вкладки, активы, настройки по умолчанию), все поддерживаемые одним узлом.

## Что нужно приложению при запуске
При старте веб-приложению нужны два входных параметра:

1. **URL бэкенда** — базовый URL бэкенда SAVVA.
2. **Имя домена** — какой домен SAVVA (социальная сеть) отображать по умолчанию.

Настройки по умолчанию берутся из небольшого YAML-файла в корне веб-приложения:

### `/default_connect.yaml`
```yaml
# /default_connect.yaml
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
# опционально:
# default_ipfs_link: ipfs://bafy.../something.json
```

* `backendLink` — базовая HTTP-точка доступа бэкенда SAVVA (приложение нормализует её).
* `domain` — начальный домен для отображения; его можно изменить позже в интерфейсе.
* `gear` — включает инструменты разработчика в интерфейсе (опционально).
* `default_ipfs_link` — опциональная настройка по умолчанию, используемая в некоторых потоках.

> **Примечание для продакшена**
> В продакшене этот файл обычно обслуживается вашим HTTP-сервером (например, Nginx) и фактически **выбирает, какой домен** веб-приложение показывает по умолчанию. Один из распространенных подходов — обслуживать конкретный файл с диска:
>
> ```nginx
> # пример: обслуживать статический default_connect.yaml
> location = /default_connect.yaml {
>   default_type text/yaml;
>   alias /etc/savva/default_connect.yaml;
> }
> ```
>
> Настройте под вашу инфраструктуру; ключевым моментом является то, что приложение может `GET /default_connect.yaml`.

---

## Последовательность загрузки

1. **Загрузить `/default_connect.yaml`**
   Приложение загружает YAML-файл, проверяет `backendLink` и сохраняет `domain`. Оно немедленно **настраивает конечные точки** (базовый HTTP + URL WS), используя эти значения. &#x20;

2. **Настроить конечные точки**

   * `httpBase` — нормализованная версия `backendLink` (гарантированная завершающая косая черта).
   * URL `ws` выводится из той же базы, указывая на `.../ws` (протокол переключается на `ws:` или `wss:`) и включает `?domain=...` в запросе.
     Это сохраняет **один источник правды** как для HTTP, так и для WS.&#x20;

3. **Получить `/info`**
   С установленными конечными точками приложение вызывает `GET <httpBase>info` и сохраняет JSON. С этого момента **/info управляет поведением во время выполнения** (домены, цепочка, IPFS, активы).&#x20;

4. **Вывести состояние во время выполнения из `/info`**
   Используются следующие поля (см. пример ниже):

   * **`domains`** → Список доступных доменов. Интерфейс предпочитает явный `domain` из YAML/переопределения; если он отсутствует в `/info`, он все равно используется.&#x20;
   * **`blockchain_id`** → Целочисленный ID целевой цепи EVM. Помощник кошелька может переключать/добавлять эту сеть.&#x20;
   * **`ipfs_gateways`** → Удаленные IPFS-шлюзы, которые следует попробовать в порядке (если не включен локальный IPFS-переопределитель).&#x20;
   * **`assets_url`** и **`temp_assets_url`** → Базовые **активы** (продакшн против теста). Приложение вычисляет **префикс активов активного домена** как
     `(<assets base> + <domain> + "/")` с **резервным вариантом** на `/domain_default/`, если удаленный `config.yaml` отсутствует. &#x20;

5. **Загрузить активы домена и конфигурацию**
   Приложение пытается `(<active prefix>/config.yaml)` с коротким тайм-аутом; в случае неудачи оно переходит к пакету по умолчанию в `/domain_default/config.yaml`. Полученная разобранная конфигурация (логотипы, вкладки, локали и т. д.) сохраняется, и интерфейс отображается соответственно.&#x20;

6. **Время выполнения WebSocket**
   Клиент WS использует вычисленный `ws` URL из конечных точек; когда бэкенд/домен изменяются, конечные точки пересчитываются, и уровень WS подхватывает это.&#x20;

---

## Пример `/info` (иллюстративный)

```json
{
  "domains": [
    "savva.app",
    {"name": "art.savva"},
    "dev.savva"
  ],
  "blockchain_id": 369,
  "ipfs_gateways": [
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/"
  ],
  "assets_url": "https://cdn.savva.network/assets/",
  "temp_assets_url": "https://cdn.savva.network/assets-test/"
}
```

### Поле за полем (что приложение с ним делает)

* **domains** — список выбираемых доменов. Диалог **Переключить бэкенд / домен** заполняется из `/info`, но настроенный домен все равно имеет приоритет, если `/info` устарело. &#x20;
* **blockchain\_id** — числовой ID цепи EVM; используется для построения метаданных `switch/add chain` и для обеспечения того, чтобы кошелек находился в **требуемой сети**. &#x20;
* **ipfs\_gateways** — упорядоченный список удаленных шлюзов; комбинируется с опциональным **Локальным IPFS** переопределителем (когда включен в настройках), чтобы сформировать **активный** порядок шлюзов.&#x20;
* **assets\_url / temp\_assets\_url** — приложение поддерживает **среду активов** (`prod`/`test`) и выбирает соответствующую базу. Затем оно вычисляет `/<base>/<domain>/` и загружает `config.yaml`. Если удаленный пакет отсутствует или медленный, используется **резервный** `/domain_default/`.&#x20;

---

## Где это находится в коде (для быстрого справочника)

* Загрузка и `/default_connect.yaml`, затем `/info`: **`src/context/AppContext.jsx`** и **`src/hooks/useConnect.js`**. &#x20;
* Источник конечных точек (базовый HTTP + URL WS): **`src/net/endpoints.js`**.&#x20;
* Разрешение списка доменов, ID цепи, IPFS-шлюзы, загрузка среды активов и активов домена: **`src/context/AppContext.jsx`**.  &#x20;
* Диалог переключения, который получает `/info` и нормализует `domains`: **`src/components/SwitchConnectDialog.jsx`**.&#x20;

---

**Далее:** в следующей главе мы разберем **конфигурацию домена** (`config.yaml`) и то, как она управляет логотипами, вкладками, локалями и другими поведениями интерфейса для каждого домена.