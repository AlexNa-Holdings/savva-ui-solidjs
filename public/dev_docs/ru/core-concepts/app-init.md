# Инициализация приложения и подключение к бэкенду

## Что такое бэкенд SAVVA (узел SAVVA)?
Бэкенд SAVVA — серверный компонент, который **индексирует/кеширует данные, полученные из активности в блокчейне**, и предоставляет быстрые, удобные для UI API и методы WebSocket. Один бэкенд может обслуживать **несколько доменов SAVVA** — представьте себе «домен» как отдельную социальную сеть SAVVA (брендинг, вкладки, ассеты, настройки по умолчанию), всё это поддерживается одним узлом.

## Что нужно приложению при запуске
При запуске веб‑приложению требуются два входных параметра:

1. **URL бэкенда** – базовый URL бэкенда SAVVA.
2. **Имя домена** – какой домен SAVVA (социальная сеть) рендерить по умолчанию.

Значения по умолчанию берутся из небольшого YAML‑файла в корне веба:

### `/default_connect.yaml`
```yaml
# /default_connect.yaml
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
# optional:
# default_ipfs_link: ipfs://bafy.../something.json
````

* `backendLink` — базовый HTTP‑эндпоинт бэкенда SAVVA (приложение нормализует его).
* `domain` — начальный домен для рендеринга; позже его можно сменить в UI.
* `gear` — включает инструменты для разработчика в UI (опционально).
* `default_ipfs_link` — необязательное удобство по умолчанию, используемое в некоторых сценариях.

> **Примечание для продакшна**
> В продакшне этот файл обычно отдаёт ваш HTTP‑сервер (например, Nginx) и фактически **определяет, какой домен** будет показывать развернутое веб‑приложение по умолчанию. Одна распространённая схема — отдавать конкретный файл с диска:
>
> ```nginx
> # example: serve a static default_connect.yaml
> location = /default_connect.yaml {
>   default_type text/yaml;
>   alias /etc/savva/default_connect.yaml;
> }
> ```
>
> Настройте под свою инфраструктуру; главное — чтобы приложение могло сделать `GET /default_connect.yaml`.

---

## Последовательность загрузки

1. **Загрузить `/default_connect.yaml`**  
   Приложение запрашивает YAML‑файл, проверяет `backendLink` и сохраняет `domain`. Сразу же оно **конфигурирует конечные точки** (HTTP‑базу + WS URL), используя эти значения. &#x20;

2. **Настроить конечные точки**

   * `httpBase` — нормализованная версия `backendLink` (гарантированно с завершающим слэшем).
   * URL `ws` выводится из той же базы, указывая на `.../ws` (протокол переключается на `ws:` или `wss:`) и включает `?domain=...` в query.
     Это обеспечивает **единственный источник правды** для HTTP и WS.&#x20;

3. **Запросить `/info`**  
   С установленными эндпоинтами приложение делает `GET <httpBase>info` и сохраняет JSON. С этого момента **/info управляет поведением во время выполнения** (домены, цепочка, IPFS, ассеты).&#x20;

4. **Сформировать состояние рантайма из `/info`**  
   Используются следующие поля (см. пример ниже):

   * **`domains`** → список доступных доменов. UI предпочитает явный `domain` из YAML/переопределения; если он отсутствует в `/info`, всё равно используется настроенный домен.&#x20;
   * **`blockchain_id`** → целевой ID EVM‑цепочки. Хелпер кошелька может переключить/добавить эту сеть.&#x20;
   * **`ipfs_gateways`** → удалённые IPFS‑шлюзы, которые будут пробоваться по порядку (если не включён локальный IPFS‑оверрайд).&#x20;
   * **`assets_url`** и **`temp_assets_url`** → база для **ассетов** (прод/тест). Приложение вычисляет **префикс ассетов активного домена** как
     `(<assets base> + <domain> + "/")` с **фолбеком** на `/domain_default/`, если удалённый `config.yaml` отсутствует. &#x20;

5. **Загрузить ассеты и конфиг домена**  
   Приложение пытается получить `(<active prefix>/config.yaml)` с коротким таймаутом; в случае неудачи оно откатывается к паку по умолчанию `/domain_default/config.yaml`. Полученный распарсенный конфиг (логотипы, вкладки, локали и т.д.) сохраняется, и UI рендерится соответственно.&#x20;

6. **WebSocket во время работы**  
   WS‑клиент использует вычисленный `ws` URL из эндпоинтов; при смене бэкенда/домена эндпоинты пересчитываются, и слой WS подхватывает изменения.&#x20;

---

## Пример `/info` (иллюстративно)

```json
{
  "domains": [
    "savva.app",
    {"name": "art.savva"},
    "dev.savva"
  ],
  "blockchain_id": 369,
  "ipfs_gateways": [
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/"
  ],
  "assets_url": "https://cdn.savva.network/assets/",
  "temp_assets_url": "https://cdn.savva.network/assets-test/"
}
```

### Поле за полем (как приложение их использует)

* **domains** — список выбираемых доменов. Диалог **«Сменить бэкенд / домен»** наполняется из `/info`, но настроенный домен по‑прежнему имеет приоритет, если `/info` отстаёт. &#x20;
* **blockchain_id** — числовой ID EVM‑цепочки; используется для формирования метаданных `switch/add chain` и чтобы убедиться, что кошелёк находится в **требуемой сети**. &#x20;
* **ipfs_gateways** — упорядоченный список удалённых шлюзов; в сочетании с опциональным оверрайдом **Локальный IPFS** (когда включён в настройках) формирует **активный** порядок шлюзов.&#x20;
* **assets_url / temp_assets_url** — приложение поддерживает **среду ассетов** (`prod`/`test`) и выбирает соответствующую базу. Затем оно вычисляет `/<base>/<domain>/` и загружает `config.yaml`. Если удалённый пакет отсутствует или медленный, используется **дефолт** `/domain_default/`.&#x20;

---

## Где это находится в коде (для быстрой справки)

* Загрузка при старте & `/default_connect.yaml`, затем `/info`: **`src/context/AppContext.jsx`** и **`src/hooks/useConnect.js`**. &#x20;
* Источник правды эндпоинтов (HTTP‑база + WS URL): **`src/net/endpoints.js`**.&#x20;
* Разрешение списка доменов, ID цепочки, IPFS‑шлюзы, среда ассетов и загрузка ассетов домена: **`src/context/AppContext.jsx`**.  &#x20;
* Диалог переключения, который запрашивает `/info` и нормализует `domains`: **`src/x/SwitchConnectModal.jsx`**.&#x20;

---

**Далее:** в следующей главе мы разберём **конфигурацию домена** (`config.yaml`) и как она управляет логотипами, вкладками, локалями и другими поведениями UI для каждого домена.