<!-- public/dev_docs/ru/core-concepts/connection-orchestration.md -->

# Оркестрация соединений, хранилище `/info` и конфигурация домена

Эта страница объясняет, как приложение запускается, подключается к бэкенду, выбирает домен и как оно хранит/использует ответ `/info` бэкенда и конфигурацию домена. Она написана для профессиональных инженеров, которым нужно расширить или отладить поток.

> **Кратко** — Существует единственный оркестратор (`useAppOrchestrator`), который:
>
> * читает `/default_connect.yaml` (+ необязательный локальный переопределение),
> * настраивает HTTP/WS конечные точки,
> * получает `/info`,
> * завершает выбор домена,
> * выбирает базу активов (prod/test), загружает пакет домена,
> * переподключает WebSocket, и
> * (при явном переключении) переходит к `/`.

---

## Термины и примитивы

* **Бэкенд** — узел SAVVA (HTTP API + WebSocket).
* **Домен** — какая сеть (брендинг, вкладки, активы) будет отображаться.
* **Пакет домена** — папка `\<assetsBase\>/\<domain\>/` с `config.yaml`, `domain.css`, i18n, изображениями, модулями и т.д. Приложение может загружать пакеты из **prod** (`assets_url`) или **test** (`temp_assets_url`).
* **Переопределение** — небольшой снимок `{ backendLink, domain }`, сохраненный в `localStorage` под ключом `connect_override`.

---

## Карта файлов (где что находится)

* **Оркестратор (источник правды):** `src/context/useAppOrchestrator.js` — логика запуска и переключения, `/info`, окружение активов, пакет домена, переподключение WS. Экспонирует `initializeOrSwitch()`, `setDomain()`, `clearConnectOverride()`, и сигналы для `config`, `info`, `assetsEnv`, `domainAssets*`.
* **Обертка контекста приложения:** `src/context/AppContext.jsx` — использует оркестратор и выводит `supportedDomains`, `selectedDomain`, цепочку/сеть, IPFS шлюзы и `assetUrl()`; также обеспечивает согласованность аутентификации при изменениях домена.
* **HTTP/WS конечные точки:** `src/net/endpoints.js` — вычисляет `httpBase()` и `wsUrl()` из `{ backendLink, domain }`, отправляет событие изменения при переконфигурации и предоставляет вспомогательные функции.
* **Время выполнения WebSocket:** отслеживает изменения конечных точек и переподключается соответственно.
* **UI переключения:** `src/x/modals/SwitchConnectModal.jsx` — получает `<backend>/info`, нормализует список доменов и применяет изменения через API приложения.
* **Основная оболочка:** динамически применяет `domain.css`, фавиконы/мета, GA и связывает WS соединитель.
* **Примечание о наследии.** Вы можете увидеть более старый хук `useAppConnection`; продолжайте использовать **оркестратор** (текущий дизайн) как единственный источник правды.

---

## 1) Последовательность запуска — шаг за шагом

Оркестратор запускается один раз при монтировании:

1. **Загрузка значений по умолчанию**
   `GET /default_connect.yaml`, парсит `backendLink`, `domain` и (по желанию) `gear`. Эти значения комбинируются с сохраненным **переопределением** (если присутствует).

2. **Нормализация и предварительная настройка конечных точек (предварительно к /info)**
   Перед `/info` мы настраиваем конечные точки, используя **запрашиваемый** домен как есть:
   `configureEndpoints({ backendLink, domain }, "orch:pre-info")`. Это вычисляет `httpBase()` и `wsUrl()` и отправляет событие изменения, чтобы время выполнения могло указывать на правильный сервер.

3. **Получение `/info`**
   `GET <backendLink>/info` (без кэша). JSON сохраняется в `orchestrator.info`.

4. **Определение окончательного домена**
   Если пользователь явно запросил домен, он **уважается**; в противном случае мы выбираем **первый** домен из `/info.domains` (если есть). Разрешенный `{ backendLink, domain }` становится `config`. Если это было переключение, мы **сохраняем** переопределение.

5. **Завершение настройки конечных точек (после /info)**
   Повторно запускаем `configureEndpoints` с **окончательным** доменом. Все HTTP вызовы должны использовать `httpBase()`, а **WS URL включает** `?domain=...`.

6. **Окружение активов → загрузка пакета домена**
   Выбираем базу из `/info`: `assets_url` (prod) или `temp_assets_url` (test). Пытаемся `\<assetsBase\>/\<domain\>/config.yaml`, в противном случае возвращаемся к `/domain_default/config.yaml`. Сохраняем `domainAssetsPrefix`, `domainAssetsConfig` и источник (`domain` против `default`).

7. **Принудительное переподключение WS**
   Обновляем URL клиента ws, переподключаем, ждем открытия (до ~8 секунд). Это гарантирует, что время выполнения синхронизировано с новым доменом и бэкендом.

8. **Навигация**
   При явном переключении переходим к `/` (сохраняет состояние маршрутизации в порядке после значительного изменения контекста).

> Оркестратор предоставляет тот же API для повторного запуска этой последовательности в любое время; `setDomain()` использует тот же путь под капотом.

---

## 2) Вычисление конечных точек (HTTP и WS)

`src/net/endpoints.js` — это **единственное** место, которое знает активную базу и URL ws:

### `configureEndpoints({ backendLink, domain }, reason)`

* Нормализует базу (обеспечивает `https://…/`).
* Сохраняет **домен** (строка).
* Выводит URL WebSocket (`ws:`/`wss:`) с `?domain=<name>&space=public`.
* Отправляет событие `ENDPOINTS_CHANGED`.

Весь остальной код вызывает геттеры (`httpBase()`, `wsUrl()`, `wsQuery()`) и/или подписывается на изменения.

### Время выполнения WS реагирует на изменения

Время выполнения слушает изменения конечных точек и может переподключиться. Оркестратор также явно устанавливает URL и вызывает `reconnect`.

### HTTP вызовы

Для конечных точек, которые требуют `domain` в запросе (аутентификация, проверки администратора и т.д.), вызывающие добавляют его через `URLSearchParams` к `httpBase()`. (Смотрите примеры в `auth.js`.)

---

## 3) `/info` — Что мы храним и как мы это используем

Сырой JSON `/info` хранится как **сигнал**: `orchestrator.info()`.

**Типичная структура (сокращенная):**

```json
{
  "domains": ["savva.app", {"name":"art.savva"}],
  "blockchain_id": 369,
  "ipfs_gateways": ["https://cloudflare-ipfs.com/ipfs/"],
  "assets_url": "https://cdn…/assets/",
  "temp_assets_url": "https://cdn…/assets-test/"
}
```

**Где это используется:**

* **Домены** — `AppContext` выводит `supportedDomains` (нормализованные, без дубликатов) и `selectedDomain`. Если `config.domain` установлен, он предпочтителен; в противном случае используется первый поддерживаемый домен.
* **Цепочка/сеть** — `desiredChainId = info.blockchain_id` → `desiredChain()` выводит полные метаданные; `ensureWalletOnDesiredChain()` может быть вызван до потоков tx.
* **IPFS шлюзы** — `remoteIpfsGateways` берется из `info.ipfs_gateways`, а `activeIpfsGateways` опционально добавляет **локальный** шлюз, если он включен в настройках.
* **База активов** — Оркестратор выбирает `assets_url` (prod) или `temp_assets_url` (test), вычисляет `\<assetsBase\>/\<domain\>/`, затем загружает пакет домена. Активный префикс + разобранная конфигурация публикуются через `domainAssetsPrefix()` / `domainAssetsConfig()`.
* **Функции приложения, использующие `/info`** — например, отображение цен токенов ищет `/info.savva_contracts.SavvaToken.address`, чтобы поместить базовый токен SAVVA в таблицу цен.

---

## 4) Конфигурация домена — Хранение и потребление

После шага (6) в процессе загрузки приложение имеет:

* `assetsEnv()` — `"prod"` или `"test"` (переключение в настройках, используется администраторами).
* `assetsBaseUrl()` — вычисляется из `/info` + окружение.
* `domainAssetsPrefix()` — либо `\<assetsBase\>/\<domain\>/`, либо `/domain_default/`.
* `domainAssetsConfig()` — разобранный `config.yaml`.

### Что читает конфигурацию домена?

* **CSS и брендинг**

  * `DomainCssLoader` загружает `assetUrl("domain.css")`, сбрасывая кэш с ревизией `(env|domain|assets_cid)`.
  * `FaviconLoader` читает раздел `favicon` (размеры иконок, манифест, маска иконки, мета) и обновляет `<link rel="icon">` и т.д.; URL разрешаются через `assetUrl(relPath)` и сбрасываются кэш.

* **Международализация (языки по доменам)**

  * При каждой загрузке конфигурации приложение публикует языковые коды домена в систему i18n и корректирует документ `<title>` в соответствии с `title` текущей локали. Оно также **валидирует** текущий язык по сравнению с новым доменом и переключается на поддерживаемый, когда это необходимо.

* **Модули / Вкладки**

  * Основная навигационная панель (`TabsBar`) читает `config.modules.tabs` (по умолчанию `modules/tabs.yaml`) и загружает YAML через **загрузчик активов**, используя `assetUrl()`. Вкладки локализуются через ключи i18n и/или метаданные по вкладкам.

* **HTML блоки и другие активы**

  * Виджеты (например, `HtmlBlock`) вызывают `loadAssetResource(app, relPath)`, который разрешает относительные пути через `assetUrl()` и получает текст/YAML соответственно.

> Активный `assetUrl(relPath)` — это **просто** `domainAssetsPrefix()` + `relPath` (без начального `/`); это сохраняет всех потребителей в согласованности.

### Настройки → Активы (диагностика)

Администраторы могут переключать **prod/test**, видеть **активный префикс/источник** и запускать диагностику, которая подтверждает наличие ключевых полей (логотипы, локали, вкладки, фавикон). Этот вид читает *только* опубликованные сигналы оркестратора.

---

## 5) Как работает переключение (бэкенд/домен)

### Поток UI

1. Диалог **Переключить бэкенд / домен** принимает URL бэкенда.
2. Вызывает `<backend>/info`, чтобы заполнить нормализованный список доменов (`[{name, …}]`).
3. Применяет выбор, вызывая API приложения.

### Поток оркестратора

* Если **бэкенд** изменился, мы **выходим** сначала, чтобы избежать состояния кук между бэкендами.
* Предварительно настраиваем конечные точки (запрашиваемый домен), получаем `/info`, определяем окончательный домен.
* Сохраняем переопределение, устанавливаем `config`, **завершаем конечные точки**, загружаем пакет домена, **переподключаем WS**, переходим на главную.

### Согласованность аутентификации

Если пользователь вошел в систему и **домен** в `config` изменяется, приложение проактивно выходит из системы, чтобы избежать действий в несоответствующем контексте. Тост объясняет, почему.

---

## 6) `AppContext` — На что может полагаться ваш код

`useApp()` предоставляет стабильный интерфейс, поддерживаемый оркестратором:

* **Состояние соединения:** `loading()`, `error()`, `config()`, `info()` (сырой `/info`).
* **Домены:** `supportedDomains()`, `selectedDomain()`, `selectedDomainName()`.
* **Сеть:** `desiredChainId()`, `desiredChain()`, `ensureWalletOnDesiredChain()`.
* **IPFS:** `remoteIpfsGateways()`, `activeIpfsGateways()`.
* **Активы:** `assetsEnv()`, `assetsBaseUrl()`, `domainAssetsPrefix()`, `domainAssetsConfig()`, и `assetUrl(relPath)`.
* **API переключения:** `initializeOrSwitch(newSettings)`, `setDomain(name)`, `clearConnectOverride()`.
* **Помощники i18n:** `t(key, vars?)`, `lang()`, `setLang(code)`.

### Пример: загрузка фрагмента YAML из пакета домена

```js
// (не компонент, просто эскиз)
// Все видимые строки ДОЛЖНЫ быть локализованы; здесь ничего не показывается пользователю.
import { useApp } from "../context/AppContext.jsx";
import { loadAssetResource } from "../utils/assetLoader.js";

async function loadDomainTabs() {
  const app = useApp();
  const rel = app.domainAssetsConfig?.()?.modules?.tabs || "modules/tabs.yaml";
  const data = await loadAssetResource(app, rel, { type: "yaml" });
  return Array.isArray(data?.tabs) ? data.tabs : [];
}
```

### Пример: создание аутентифицированного вызова, который требует домен

```js
// Все строки, видимые пользователю, должны быть локализованы через t():
import { useApp } from "../context/AppContext.jsx";

async function fetchAdminFlag(address) {
  const { t } = useApp();
  const url = new URL(`${httpBase()}is-admin`);
  url.searchParams.set("address", address);
  url.searchParams.set("domain", useApp().selectedDomainName());
  const res = await fetch(url, { credentials: "include" });
  if (!res.ok) throw new Error(t("error.connection.message"));
  return (await res.json())?.admin === true;
}
```

---

## 7) Обработка ошибок и пустые состояния

Когда соединение не удается при запуске (например, неверный YAML, `/info` недоступен), `AppContext` предоставляет `error()`, и оболочка отображает центрированную карточку ошибки с i18n строками и кнопкой **Повторить**.

---

## 8) Примечания по i18n и UX инвариантам

* **Каждая** строка, видимая пользователю в коде UI, должна быть `t("…")` из `useApp()` (навигация, настройки, тосты и т.д.).
* `document.title` выводится из локализованного `title` конфигурации домена. Изменение **домена** или **окружения** обновляет брендинг немедленно без перестройки.

---

## 9) Справочные фрагменты

* Предварительная настройка → `/info` → окончательная настройка — ядро оркестратора.
* База активов и запасной пакет домена — оркестратор.
* Конечные точки и WS URL (`?domain=...`) — единственный источник.
* Время выполнения WS + переподключение при изменении конечной точки — детали времени выполнения.
* Диалог переключения `/info` получение и нормализация домена — детали UI.

---

## 10) Операционный контрольный список

* Чтобы изменить значения по умолчанию в развертывании, обновите **`/default_connect.yaml`** на веб-сервере хостинга.
* Чтобы переключить во время выполнения, используйте **Диалог переключения** (шестеренка должна быть включена в YAML сайта).
* Чтобы просмотреть пакет домена, переключите **Настройки → Активы → Окружение: Тест**. Приложение будет загружаться из `temp_assets_url`.
* Если вы переключаете **бэкенд**, приложение **выходит** сначала, чтобы избежать кук между бэкендами.

---

## Приложение: Модель данных на первый взгляд

```ts
// Упрощенная концептуальная модель

type AppConfig = {
  backendLink: string;   // нормализованный с завершающим слэшем
  domain: string;        // выбранное имя домена
  gear: boolean;         // UI шестеренка включена (из YAML сайта)
};

type Info = {
  domains: Array<string | { name: string; website?: string }>;
  blockchain_id?: number;
  ipfs_gateways?: string[];
  assets_url?: string;
  temp_assets_url?: string;
  // ...другие поля (например, savva_contracts)
};

type Orchestrator = {
  config(): AppConfig | null;
  info(): Info | null;
  loading(): boolean;
  error(): Error | null;

  // оркестрация
  initializeOrSwitch(newSettings?: Partial<AppConfig>): Promise<void>;
  setDomain(name: string): Promise<void>;
  clearConnectOverride(): void;

  // активы
  assetsEnv(): "prod" | "test";
  setAssetsEnv(next: "prod" | "test"): void;
  assetsBaseUrl(): string;
  domainAssetsPrefix(): string;           // '/domain_default/' или '<assetsBase>/<domain>/'
  domainAssetsConfig(): any | null;       // разобранный config.yaml
};
```

---

Это полная картина. С этими примитивами вы можете безопасно расширять UI, уверенные, что конечные точки, `/info` и ресурсы домена остаются **последовательными** и **реактивными** по всему приложению.