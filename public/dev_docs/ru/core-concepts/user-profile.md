# Контракт пользовательского профиля

Контракт `UserProfile` хранит состояние в блокчейне, которое обеспечивает работу страниц авторов, имён и метаданных профиля в доменах SAVVA. Он объединяет глобальный реестр читаемых человеком имён с хранением ключ/значение для каждого домена и лёгкими помощниками для аватаров и контактных данных. Эта страница резюмирует, как dApp взаимодействует с контрактом и JSON-объектами профиля, которые хранятся рядом с ним в IPFS.

## Получение экземпляра контракта

Адрес контракта предоставляется бэкендом в ответе `/info` в поле `savva_contracts.UserProfile`. Фронтенд-код получает его через общий хелпер:

```js
const userProfile = await getSavvaContract(app, "UserProfile");
```

Все операции чтения/записи, показанные ниже, используют этот хелпер вместе с утилитами маршрутизации акторов (см. `ProfileEditPage.jsx` и `userProfileStore.js`).

## Зарегистрированные имена

Имена уникальны глобально, это строчные хэндлы, зарегистрированные напрямую на адреса кошельков.

- `names(address) → string` возвращает текущее имя для адреса.
- `owners(string) → address` разрешает имя обратно к его владельцу. Оба хелпера используются при загрузке произвольного профиля (см. `fetchProfileForEdit`).

Мутации:

- `setName(string name)` регистрирует или обновляет хэндл вызывающего. UI вызывает это внутри `executeSetName()` при сохранении изменений профиля.
- `removeName()` удаляет запись.
- `transferName(address to)` передаёт резервирование другому адресу.

Поскольку имена глобальны, UI позволяет пользователю выбрать одно зарегистрированное значение, а затем выводит языко-специфичные отображаемые имена из JSON профиля вне цепочки (описано ниже).

## Аватары и другие основные поля

Два отдельные хелпера хранят самые важные поля в блокчейне:

- `setAvatar(string cid)` / `avatars(address) → string` сохраняют и читают CID IPFS для аватара пользователя. Редактор загружает изображение на бэкенд и затем вызывает `setAvatar` с возвращённым CID.
- `setPubKey(string modifier, string pubKey)` опционально записывает пару ключей для шифрования для функций прямых сообщений.

Также есть удобный метод `setAll(string name, string avatar, bytes32 domain, string profile)`, который пакетно обновляет имя + аватар вместе с профилем для одного домена.

## Хранение ключ/значение в рамках домена

Большинство метаданных хранится с помощью примитивов `setString` и `setUInt`. Оба принимают идентификатор домена и ключ, закодированные как `bytes32`.

```js
await userProfile.write.setString([
  toHexBytes32(app.selectedDomainName()),
  toHexBytes32("profile_cid"),
  newProfileCid,
]);
```

Пример выше повторяет то, что делает `ProfileEditPage.jsx` после загрузки JSON профиля в IPFS — CID записывается под текущим доменом и ключом `profile_cid`. Чтение происходит через `getString`/`getUInt` с теми же параметрами. Контракт также предоставляет прямой доступ к публичным отображениям (`profileString`, `profileUInt`), если нужен доступ без повторного вычисления ключей.

### Общие ключи

| Ключ           | Тип     | Назначение                                                                                  |
| -------------- | ------- | ------------------------------------------------------------------------------------------- |
| `profile_cid`  | string  | Указывает на канонический JSON-файл профиля в IPFS для выбранного домена.                   |
| Пользовательские ключи | string / uint | Интеграторы могут добавлять дополнительные метаданные для своего домена, выбирая новые ключи — главное, чтобы они были не длиннее 32 байт до кодирования. |

Поскольку данные индексируются по `(user, domain, key)`, разные домены SAVVA могут поддерживать независимые документы профиля, при этом используя общий глобальный реестр имён.

## Схема JSON профиля

JSON-объект, хранящийся по адресу `profile_cid`, обеспечивает работу расширенного UI профиля в `ProfilePage.jsx`. Когда редактор профиля сохраняет изменения, он генерирует документ, похожий на следующий:

```json
{
  "display_names": {
    "en": "Alice Example",
    "fr": "Alice Exemple"
  },
  "about_me": {
    "en": "Writer focused on freedom of expression.",
    "es": "Escritora centrada en la libertad de expresión."
  },
  "nsfw": "h",
  "sponsor_values": [10, 25, 100],
  "links": [
    { "title": "Website", "url": "https://alice.example" },
    { "title": "Fedi", "url": "https://fedi.social/@alice" }
  ]
}
```

Ключевые поля:

- `display_names` — языковые переопределения публичного имени автора. `ProfilePage` выбирает текущий язык UI, затем английский, и, наконец, имя, зарегистрированное в цепочке.
- `about_me` — многоязычный текст биографии, отображаемый на карточке профиля. В старых документах может использоваться одно строковое поле `about`; UI делает соответствующий fallback.
- `nsfw` — флаг предпочтений (`h`, `s` и т.п.), влияющий на то, какие посты показываются по умолчанию.
- `sponsor_values` — целочисленные пороги (в SAVVA), используемые для предварительного заполнения уровней подписки.
- `links` — произвольные объекты внешних ссылок (`title` + `url`).

Вы можете расширять документ дополнительными полями для домена; потребительский код должен игнорировать неизвестные ключи.

## Чтение профилей в dApp

`ProfilePage.jsx` объединяет три источника:

1. Вебсокетный вызов (`get-user`), который возвращает поля из цепочки, такие как `address`, `name`, `display_names`, кэшированные бэкендом, статистику стекинга и данные подписок.
2. Прямой запрос к IPFS для CID, сохранённого под `profile_cid`, используя хелперы из `userProfileStore.js`.
3. Локальные переопределения из кэшей `AppContext` (`userDisplayNames`), позволяющие сразу показывать временные изменения.

Объединённый результат определяет, что показывается под баннером автора, языко-специфичное имя и все вспомогательные виджеты, например, социальные ссылки.

## Резюме процесса редактирования

При редактировании профиля (`ProfileEditPage.jsx`):

1. UI разрешает целевой адрес по имени (через `owners(name)`), затем загружает CID аватара, текущее имя и `profile_cid`.
2. Если CID профиля существует, JSON загружается из IPFS и нормализуется в состояние редактора.
3. При сохранении загружается новый JSON и вызывается `setString(domain, "profile_cid", cid)` через `sendAsActor`, обеспечивая подпись транзакции текущим аккаунтом.
4. Хелпер `applyProfileEditResult` обновляет локальные кэши, чтобы новые данные были видны без ожидания переиндексации бэкенда.

Путь загрузки аватара аналогичен, вызывая `setAvatar` с возвращённым CID.

## Работа с именами и отображаемыми именами

- **Зарегистрированное имя (`setName`)** — уникальный идентификатор на уровне цепочки. Используется для маршрутизации через URL `/@handle` и хранится в отображении `names` контракта.
- **Отображаемые имена (`display_names`)** — опциональные языко-специфичные метки внутри JSON профиля. Они переопределяют зарегистрированное имя, если присутствуют.
- **Устаревшее `display_name`** — в старых JSON профилях может быть одно поле `display_name`; UI учитывает его, если нет языко-специфичных значений.

При разработке интеграций всегда разрешайте адрес в цепочке, если принимаете ввод от человека, и проверяйте, что имя свободно, перед вызовом `setName`.

## Дополнительные утилиты

- `setUInt` / `getUInt` зеркально повторяют строковые хелперы для числовых метаданных (например, для отслеживания счётчиков по доменам).
- `setAll` может установить имя, аватар и указатель профиля за один вызов — полезно для скриптов начальной загрузки.
- `removeName` и `transferName` обеспечивают управление жизненным циклом, если нужно отказаться от хэндла.

С помощью этих примитивов вы можете добавлять дополнительные функции, основанные на профиле (значки, записи верификации, внецепочные аттестации), определяя новые ключи домена, указывающие либо на значения в цепочке, либо на дополнительные документы в IPFS.