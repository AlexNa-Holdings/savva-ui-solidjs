This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
assets/
  icons/
    arrow-back.svg
  ethereum.svg
  puilsechain-test--v4.svg
  pulsechain.svg
public/
  default_connect.yaml
  vite.svg
scripts/
  i18n-sync.mjs
src/
  assets/
    solid.svg
  blockchain/
    chainLogos.js
    chains.js
    wallet.js
  components/
    settings/
      LocalIpfsSection.jsx
    ui/
      BackIconButton.jsx
    Header.jsx
    RightPane.jsx
    SwitchConnectDialog.jsx
    Toaster.jsx
  context/
    AppContext.jsx
  hooks/
    useConnect.js
    useTheme.js
  i18n/
    en.js
    ru.js
    useI18n.js
  ipfs/
    index.js
  pages/
    Settings.jsx
  routing/
    hashRouter.js
  ux/
    toast.js
  App.jsx
  index.css
  index.jsx
  vite-env.d.js
.gitignore
index.html
package.json
postcss.config.js
README.md
tailwind.config.js
tsconfig.app.json
tsconfig.node.json
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="assets/icons/arrow-back.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path fill="none" stroke="#000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"/>
  <path fill="none" stroke="#000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M4 12h14"/>
</svg>
</file>

<file path="assets/ethereum.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 540 879.4">
  <path d="m269.9 325.2-269.9 122.7 269.9 159.6 270-159.6z" opacity=".6"/>
  <path d="m0.1 447.8 269.9 159.6v-607.4z" opacity=".45"/>
  <path d="m270 0v607.4l269.9-159.6z" opacity=".8"/>
  <path d="m0 499 269.9 380.4v-220.9z" opacity=".45"/>
  <path d="m269.9 658.5v220.9l270.1-380.4z" opacity=".8"/>
</svg>
</file>

<file path="assets/puilsechain-test--v4.svg">
<svg width="433" height="402" viewBox="0 0 433 402" xmlns="http://www.w3.org/2000/svg">
  <title>PulseChain Logo · Testnet (monochrome)</title>
  <g fill="#000000" fill-rule="evenodd" transform="translate(-133, -149)">
    <path d="M565.598765,372.951028 C565.598765,375.002407 565.123895,376.952504 564.22332,378.644848 L471.558363,539.145156 C467.628442,545.95198 460.365648,550.145156 452.505805,550.145156 L246.592961,550.145156 C238.733118,550.145156 231.470323,545.95198 227.540402,539.145156 L134.86679,378.629552 C133.968844,376.940022 133.5,374.999302 133.5,372.951028 C133.5,366.307901 138.885318,360.922583 145.528445,360.922583 L247.199342,360.922583 L272.965382,404.687949 L273.123755,404.949452 C276.56213,410.470142 283.796681,412.269462 289.433324,408.951035 L289.725027,408.773687 C292.323961,407.142692 294.205446,404.576775 294.976025,401.597905 L327.807505,274.677705 L355.998349,479.011885 C357.082331,485.72482 363.072426,490.1783 369.557845,489.283548 L369.85245,489.239203 C374.548041,488.473143 378.362876,485.004494 379.559058,480.380352 L419.133013,327.39653 L435.381735,354.996566 C437.735954,358.77701 441.59028,360.922583 445.747249,360.922583 L553.57032,360.922583 C560.213447,360.922583 565.598765,366.307901 565.598765,372.951028 Z M452.505805,149.493649 C460.365648,149.493649 467.628442,153.686825 471.558363,160.493649 L564.229106,321.001259 C565.125282,322.691832 565.598765,324.640838 565.598765,326.687777 C565.598765,333.330904 560.213447,338.716222 553.57032,338.716222 L451.566328,338.716222 L425.800288,294.950856 C423.991945,292.060218 421.426028,290.178734 418.447158,289.408155 L418.167463,289.339295 C411.826545,287.85703 405.429227,291.702682 403.789645,298.040901 L370.95724,424.960175 L342.767321,220.62692 C341.956916,215.636723 338.488267,211.821889 333.864125,210.625707 C327.432698,208.962014 320.870306,212.827026 319.206612,219.258453 L279.631731,372.24135 L263.383935,344.64224 C261.029716,340.861796 257.17539,338.716222 253.018421,338.716222 L145.528445,338.716222 C138.885318,338.716222 133.5,333.330904 133.5,326.687777 C133.5,324.65653 133.956256,322.735416 134.837658,321.056157 L227.540402,160.493649 C231.470323,153.686825 238.733118,149.493649 246.592961,149.493649 L452.505805,149.493649 Z"/>
  </g>
</svg>
</file>

<file path="assets/pulsechain.svg">
<svg width="433px" height="402px" viewBox="0 0 433 402" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>PulseChain Logo Shape</title>
    <defs>
        <linearGradient x1="76.2262818%" y1="7.45934826%" x2="23.6511094%" y2="92.5655852%" id="linearGradient-1">
            <stop stop-color="#00EAFF" offset="0%"></stop>
            <stop stop-color="#0080FF" offset="25.2530882%"></stop>
            <stop stop-color="#8000FF" offset="49.7394282%"></stop>
            <stop stop-color="#E619E6" offset="74.9912298%"></stop>
            <stop stop-color="#FF0000" offset="99.9136118%"></stop>
        </linearGradient>
    </defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Logo" transform="translate(-133.000000, -149.000000)" fill="url(#linearGradient-1)">
            <path d="M565.598765,372.951028 C565.598765,375.002407 565.123895,376.952504 564.22332,378.644848 L471.558363,539.145156 C467.628442,545.95198 460.365648,550.145156 452.505805,550.145156 L246.592961,550.145156 C238.733118,550.145156 231.470323,545.95198 227.540402,539.145156 L134.86679,378.629552 C133.968844,376.940022 133.5,374.999302 133.5,372.951028 C133.5,366.307901 138.885318,360.922583 145.528445,360.922583 L247.199342,360.922583 L272.965382,404.687949 L273.123755,404.949452 C276.56213,410.470142 283.796681,412.269462 289.433324,408.951035 L289.433324,408.951035 L289.725027,408.773687 C292.323961,407.142692 294.205446,404.576775 294.976025,401.597905 L294.976025,401.597905 L327.807505,274.677705 L355.998349,479.011885 L356.041062,479.296747 C357.082331,485.72482 363.072426,490.1783 369.557845,489.283548 L369.557845,489.283548 L369.85245,489.239203 C374.548041,488.473143 378.362876,485.004494 379.559058,480.380352 L379.559058,480.380352 L419.133013,327.39653 L435.381735,354.996566 L435.543066,355.262694 C437.735954,358.77701 441.59028,360.922583 445.747249,360.922583 L445.747249,360.922583 L553.57032,360.922583 L553.57032,360.922583 C560.213447,360.922583 565.598765,366.307901 565.598765,372.951028 Z M452.505805,149.493649 C460.365648,149.493649 467.628442,153.686825 471.558363,160.493649 L564.229106,321.001259 C565.125282,322.691832 565.598765,324.640838 565.598765,326.687777 C565.598765,333.330904 560.213447,338.716222 553.57032,338.716222 L451.566328,338.716222 L425.800288,294.950856 L425.62294,294.659153 C423.991945,292.060218 421.426028,290.178734 418.447158,289.408155 L418.447158,289.408155 L418.167463,289.339295 C411.826545,287.85703 405.429227,291.702682 403.789645,298.040901 L403.789645,298.040901 L370.95724,424.960175 L342.767321,220.62692 L342.722976,220.332314 C341.956916,215.636723 338.488267,211.821889 333.864125,210.625707 C327.432698,208.962014 320.870306,212.827026 319.206612,219.258453 L319.206612,219.258453 L279.631731,372.24135 L263.383935,344.64224 L263.222604,344.376112 C261.029716,340.861796 257.17539,338.716222 253.018421,338.716222 L253.018421,338.716222 L145.528445,338.716222 L145.528445,338.716222 C138.885318,338.716222 133.5,333.330904 133.5,326.687777 C133.5,324.65653 133.956256,322.735416 134.837658,321.056157 L227.540402,160.493649 C231.470323,153.686825 238.733118,149.493649 246.592961,149.493649 L452.505805,149.493649 Z" id="PulseChain-Logo-Shape"></path>
        </g>
    </g>
</svg>
</file>

<file path="public/default_connect.yaml">
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="scripts/i18n-sync.mjs">
#!/usr/bin/env node
/**
 * i18n sync:
 * - Scan source files for t("key") usages
 * - Keep only used keys in en.js (and other languages)
 * - Add missing keys to non-English languages with value "???"
 * - Sort keys alphabetically
 *
 * Usage:
 *   node scripts/i18n-sync.mjs           # rewrite lang files
 *   node scripts/i18n-sync.mjs --dry     # show changes only
 */
import fs from "node:fs";
import path from "node:path";
import { pathToFileURL } from "node:url";

const ROOT = process.cwd();
const SRC_DIR = path.join(ROOT, "src");
const I18N_DIR = path.join(SRC_DIR, "i18n");

const DRY = process.argv.includes("--dry");

// 1) Collect used keys from source by scanning t("...") calls
const exts = [".js", ".jsx", ".ts", ".tsx"];
const usedKeys = new Set();

function walk(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      // skip node_modules just in case someone copied examples into src
      if (entry.name === "node_modules") continue;
      walk(p);
    } else if (exts.includes(path.extname(entry.name))) {
      const text = fs.readFileSync(p, "utf8");
      // match t("foo.bar") and t('foo.bar')
      const re = /\bt\(\s*(['"])([^'"]+)\1\s*\)/g;
      let m;
      while ((m = re.exec(text))) {
        usedKeys.add(m[2]);
      }
    }
  }
}

walk(SRC_DIR);

// 2) Load language files (ESM default exports)
//    (ignore non-dictionary files like useI18n.js)
function isLangFile(name) {
  return name.endsWith(".js") && !/useI18n\.js$/i.test(name);
}

function toModuleURL(filePath) {
  return pathToFileURL(filePath).href;
}

async function loadLang(filePath) {
  const mod = await import(toModuleURL(filePath));
  const dict = mod?.default || {};
  // force string values only; non-strings converted to string
  const normalized = {};
  for (const [k, v] of Object.entries(dict)) {
    normalized[k] = typeof v === "string" ? v : String(v);
  }
  return normalized;
}

// 3) Write a sorted object as ESM export default
function writeLang(filePath, obj) {
  const sorted = Object.keys(obj).sort().reduce((acc, k) => {
    acc[k] = obj[k];
    return acc;
  }, {});
  const body =
    "// Auto-generated by i18n-sync.mjs. Do not edit by hand.\n" +
    "export default " +
    JSON.stringify(sorted, null, 2) +
    ";\n";
  if (DRY) {
    console.log(`\n[DRY] Would write ${path.relative(ROOT, filePath)}:\n${body}`);
  } else {
    fs.writeFileSync(filePath, body, "utf8");
    console.log(`[i18n] Updated ${path.relative(ROOT, filePath)} (${Object.keys(sorted).length} keys)`);
  }
}

(async function main() {
  // assert i18n dir exists
  if (!fs.existsSync(I18N_DIR)) {
    console.error(`[i18n] Not found: ${path.relative(ROOT, I18N_DIR)}`);
    process.exit(1);
  }

  // find lang files
  const langFiles = fs.readdirSync(I18N_DIR).filter(isLangFile);
  if (langFiles.length === 0) {
    console.error("[i18n] No language files found in src/i18n");
    process.exit(1);
  }

  // ensure English exists
  const enPath = path.join(I18N_DIR, "en.js");
  if (!fs.existsSync(enPath)) {
    console.error("[i18n] Missing src/i18n/en.js (source of truth)");
    process.exit(1);
  }

  // load all dictionaries
  const dicts = {};
  for (const f of langFiles) {
    dicts[f] = await loadLang(path.join(I18N_DIR, f));
  }

  const en = dicts["en.js"];
  if (!en) {
    console.error("[i18n] Failed to load en.js");
    process.exit(1);
  }

  // 4) Compute the final set of keys we actually want to keep,
  //    based on real usage in code.
  //    (Only keys referenced by t("...") are kept.)
  const desiredKeys = new Set(usedKeys);

  // 5) Prune + fill for each language
  for (const f of langFiles) {
    const langDict = dicts[f];

    // prune: drop anything not used
    const pruned = {};
    for (const k of desiredKeys) {
      if (langDict[k] != null) {
        pruned[k] = langDict[k];
      }
    }

    // For all languages (including English): add missing keys as "???"
    for (const k of desiredKeys) {
      if (pruned[k] == null) pruned[k] = "???";
    }

    // write back sorted
    writeLang(path.join(I18N_DIR, f), pruned);
  }
  // 6) Report summary
  console.log("\n[i18n] Done.");
  console.log(`[i18n] Used keys found: ${desiredKeys.size}`);
  if (DRY) console.log("[i18n] (dry run, no files were modified)");
})().catch((err) => {
  console.error(err);
  process.exit(1);
});
</file>

<file path="src/assets/solid.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 166 155.3"><path d="M163 35S110-4 69 5l-3 1c-6 2-11 5-14 9l-2 3-15 26 26 5c11 7 25 10 38 7l46 9 18-30z" fill="#76b3e1"/><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="27.5" y1="3" x2="152" y2="63.5"><stop offset=".1" stop-color="#76b3e1"/><stop offset=".3" stop-color="#dcf2fd"/><stop offset="1" stop-color="#76b3e1"/></linearGradient><path d="M163 35S110-4 69 5l-3 1c-6 2-11 5-14 9l-2 3-15 26 26 5c11 7 25 10 38 7l46 9 18-30z" opacity=".3" fill="url(#a)"/><path d="M52 35l-4 1c-17 5-22 21-13 35 10 13 31 20 48 15l62-21S92 26 52 35z" fill="#518ac8"/><linearGradient id="b" gradientUnits="userSpaceOnUse" x1="95.8" y1="32.6" x2="74" y2="105.2"><stop offset="0" stop-color="#76b3e1"/><stop offset=".5" stop-color="#4377bb"/><stop offset="1" stop-color="#1f3b77"/></linearGradient><path d="M52 35l-4 1c-17 5-22 21-13 35 10 13 31 20 48 15l62-21S92 26 52 35z" opacity=".3" fill="url(#b)"/><linearGradient id="c" gradientUnits="userSpaceOnUse" x1="18.4" y1="64.2" x2="144.3" y2="149.8"><stop offset="0" stop-color="#315aa9"/><stop offset=".5" stop-color="#518ac8"/><stop offset="1" stop-color="#315aa9"/></linearGradient><path d="M134 80a45 45 0 00-48-15L24 85 4 120l112 19 20-36c4-7 3-15-2-23z" fill="url(#c)"/><linearGradient id="d" gradientUnits="userSpaceOnUse" x1="75.2" y1="74.5" x2="24.4" y2="260.8"><stop offset="0" stop-color="#4377bb"/><stop offset=".5" stop-color="#1a336b"/><stop offset="1" stop-color="#1a336b"/></linearGradient><path d="M114 115a45 45 0 00-48-15L4 120s53 40 94 30l3-1c17-5 23-21 13-34z" fill="url(#d)"/></svg>
</file>

<file path="src/blockchain/chainLogos.js">
// src/blockchain/chainLogos.js
export const CHAIN_LOGOS = {
  1: "/assets/ethereum.svg", // Ethereum Mainnet
  943: "/assets/pulsechain-test-v4.svg", // PulseChain Testnet
  369: "/assets/pulsechain.svg", // PulseChain Mainnet
  // Add more as you need
};

export function getChainLogo(chainId) {
  return CHAIN_LOGOS[chainId] || null;
}
</file>

<file path="src/blockchain/chains.js">
// src/blockchain/chains.js
export const CHAINS = {
  943: {
    id: 943,
    name: "PulseChain Testnet v4",
    rpcUrls: ["https://rpc.v4.testnet.pulsechain.com"],
    nativeCurrency: { name: "tPLS", symbol: "tPLS", decimals: 18 },
    blockExplorers: [{ name: "Scan", url: "https://scan.v4.testnet.pulsechain.com" }],
  },
  369: {
    id: 369,
    name: "PulseChain",
    rpcUrls: ["https://rpc.v4.testnet.pulsechain.com"],
    nativeCurrency: { name: "tPLS", symbol: "tPLS", decimals: 18 },
    blockExplorers: [{ name: "Scan", url: "https://scan.v4.testnet.pulsechain.com" }],
  },
  // Add more chains as needed
};

export function getChainMeta(chainId) {
  return CHAINS[chainId] || null;
}
</file>

<file path="src/components/settings/LocalIpfsSection.jsx">
// src/components/settings/LocalIpfsSection.jsx
import { createSignal, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

export default function LocalIpfsSection() {
  const app = useApp(); // exposes t, local IPFS signals, actions
  const { t } = app;

  const [testing, setTesting] = createSignal(false);
  const [apiUrl, setApiUrl] = createSignal(app.localIpfsApiUrl() || "http://localhost:5001");
  const [showIpfsHelp, setShowIpfsHelp] = createSignal(false);

  async function onEnableLocal() {
    setTesting(true);
    try {
      await app.enableLocalIpfs(apiUrl().trim());
    } finally {
      setTesting(false);
    }
  }

  return (
    <section class="bg-white dark:bg-gray-800 rounded-lg shadow p-4 space-y-3">
      <h3 class="text-lg font-medium">{t("settings.localIpfs.title")}</h3>

      <label class="flex items-center gap-2">
        <input
          type="checkbox"
          checked={app.localIpfsEnabled()}
          onInput={(e) => {
            const checked = e.currentTarget.checked;
            if (!checked) app.disableLocalIpfs();
          }}
        />
        <span>{t("settings.localIpfs.enableCheckbox")}</span>
      </label>

      {/* Input + button row (aligned bottoms); hint on its own row */}
      <div class="grid grid-cols-1 md:grid-cols-[minmax(0,1fr)_auto] gap-2 md:items-end">
        {/* Left: label + input */}
        <label class="block">
          <span class="text-sm text-gray-700 dark:text-gray-300">
            {t("settings.localIpfs.apiUrl.label")}
          </span>
          <input
            class="mt-1 w-full px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100"
            value={apiUrl()}
            onInput={(e) => {
              const val = e.currentTarget.value;
              setApiUrl(val);
              app.setLocalIpfsApiUrl?.(val);
            }}
            placeholder="http://localhost:5001"
            spellcheck={false}
          />
        </label>

        {/* Right: action button, bottom-aligned to the input */}
        <div class="flex md:self-end">
          <Show
            when={!app.localIpfsEnabled()}
            fallback={
              <button
                class="h-10 px-3 rounded bg-red-600 text-white hover:bg-red-700"
                onClick={() => app.disableLocalIpfs()}
              >
                {t("settings.localIpfs.disable")}
              </button>
            }
          >
            <button
              class="h-10 px-3 rounded bg-blue-600 text-white hover:bg-blue-700 disabled:opacity-60"
              onClick={onEnableLocal}
              disabled={testing()}
              title={t("settings.localIpfs.testEnable")}
            >
              {testing() ? t("common.checking") : t("settings.localIpfs.testEnable")}
            </button>
          </Show>
        </div>

        {/* Hint line */}
        <p class="text-xs text-gray-500 mt-1 md:col-span-2">
          {t("settings.localIpfs.apiUrl.help")} <code>/api/v0/config/show</code>.
        </p>
      </div>

      {/* Status */}
      <div class="text-sm text-gray-600 dark:text-gray-300">
        {t("settings.localIpfs.status.label")}:{" "}
        <span
          class={
            app.localIpfsStatus() === "ok"
              ? "text-emerald-600"
              : app.localIpfsStatus() === "down"
              ? "text-red-500"
              : "opacity-70"
          }
        >
          {app.localIpfsStatus()}
        </span>
        <Show when={app.localIpfsEnabled() && app.localIpfsGateway()}>
          <span class="ml-2 opacity-70">
            • {t("settings.localIpfs.gateway.label")}: {app.localIpfsGateway()}
          </span>
        </Show>
      </div>

      {/* Help toggle */}
      <div class="pt-2">
        <button
          class="text-sm underline text-blue-600 dark:text-blue-400 hover:opacity-80"
          onClick={() => setShowIpfsHelp(!showIpfsHelp())}
        >
          {showIpfsHelp()
            ? t("settings.localIpfs.help.toggle.hide")
            : t("settings.localIpfs.help.toggle.show")}
        </button>
      </div>

      {/* Collapsible help content */}
      <Show when={showIpfsHelp()}>
        <div class="mt-3 rounded border border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900 p-3 space-y-3 text-sm">
          <p class="opacity-90">
            {t("settings.localIpfs.help.intro")} <code>/api/v0/*</code>
          </p>

          <div>
            <p class="font-medium mb-1">{t("settings.localIpfs.help.api.title")}</p>
            <pre class="bg-black/70 text-white p-2 rounded overflow-x-auto text-xs">{`ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["http://localhost:5173","http://127.0.0.1:5173"]'
ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods '["GET","POST","PUT","OPTIONS"]'
ipfs config --json API.HTTPHeaders.Access-Control-Allow-Headers '["Content-Type","Authorization"]'`}</pre>
            <p class="opacity-75 mt-1">{t("settings.localIpfs.help.api.tip")}</p>
          </div>

          <div>
            <p class="font-medium mb-1">{t("settings.localIpfs.help.gateway.title")}</p>
            <pre class="bg-black/70 text-white p-2 rounded overflow-x-auto text-xs">{`ipfs config --json Gateway.HTTPHeaders.Access-Control-Allow-Origin '["http://localhost:5173","http://127.0.0.1:5173"]'
ipfs config --json Gateway.HTTPHeaders.Access-Control-Allow-Methods '["GET","HEAD","OPTIONS"]'`}</pre>
            <p class="opacity-75 mt-1">{t("settings.localIpfs.help.gateway.note")}</p>
          </div>

          <div>
            <p class="font-medium mb-1">{t("settings.localIpfs.help.restart.title")}</p>
            <pre class="bg-black/70 text-white p-2 rounded overflow-x-auto text-xs">{`ipfs shutdown 2>/dev/null || true
ipfs daemon`}</pre>
          </div>

          <div>
            <p class="font-medium mb-1">{t("settings.localIpfs.help.verify.title")}</p>
            <pre class="bg-black/70 text-white p-2 rounded overflow-x-auto text-xs">{`curl -X POST http://localhost:5001/api/v0/id
curl -X POST http://localhost:5001/api/v0/config/show | jq -r '.Addresses.Gateway'`}</pre>
            <p class="opacity-75 mt-1">
              {t("settings.localIpfs.help.verify.note")} <code>/ip4/127.0.0.1/tcp/8080</code>.
            </p>
          </div>

          <div>
            <p class="font-medium mb-1">{t("settings.localIpfs.help.proxy.title")}</p>
            <p class="opacity-90">{t("settings.localIpfs.help.proxy.text")}</p>
            <pre class="bg-black/70 text-white p-2 rounded overflow-x-auto text-xs">{`// vite.config.js
export default {
  server: {
    proxy: {
      "/ipfs-api": {
        target: "http://localhost:5001",
        changeOrigin: true,
        rewrite: p => p.replace(/^\\/ipfs-api/, "")
      }
    }
  }
};`}</pre>
            <p class="opacity-75 mt-1">
              {t("settings.localIpfs.help.proxy.note")} <code>http://localhost:5173/ipfs-api</code>.
            </p>
          </div>
        </div>
      </Show>
    </section>
  );
}
</file>

<file path="src/components/ui/BackIconButton.jsx">
<button
  class="p-2 h-9 w-9 flex items-center justify-center rounded 
         hover:bg-gray-200 dark:hover:bg-gray-700 
         text-gray-900 dark:text-gray-100
         focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500"
  /* ... */
>
  <svg viewBox="0 0 24 24" class="w-5 h-5" aria-hidden="true">
    <path
      d="M9 15L3 9m0 0l6-6M3 9h11a4 4 0 014 4v7"
      fill="none" stroke="currentColor" stroke-width="2.5"
      stroke-linecap="round" stroke-linejoin="round"
    />
  </svg>
</button>
</file>

<file path="src/components/SwitchConnectDialog.jsx">
import { createSignal, createEffect, Show, createMemo } from "solid-js";
import { useI18n } from "../i18n/useI18n";

function ensureSlash(s) {
  if (!s) return "";
  return s.endsWith("/") ? s : s + "/";
}

async function fetchInfoJSON(baseUrl, { signal } = {}) {
  const url = ensureSlash(baseUrl) + "info";
  const res = await fetch(url, { headers: { Accept: "application/json" }, signal });
  if (!res.ok) throw new Error(`/info failed: ${res.status}`);
  return await res.json();
}

export default function SwitchConnectDialog(props) {
  const { t } = useI18n();

  // Form state
  const [backendUrl, setBackendUrl] = createSignal(props.backendLink ?? "");
  const [domain, setDomain] = createSignal(props.domain ?? "");
  const [domains, setDomains] = createSignal([]); // array of { name, ... }
  const [fetching, setFetching] = createSignal(false);
  const [localError, setLocalError] = createSignal("");

  // Helper: current domain object
  const selectedDomainObj = createMemo(() =>
    (domains() || []).find((d) => d?.name === domain()) || null
  );

  // On open: fetch /info and populate domains (from info.domains[].name)
  createEffect(async () => {
    if (!props.open) return;

    setLocalError("");
    setBackendUrl(props.backendLink ?? "");
    setDomain(props.domain ?? "");
    setDomains([]);

    // Validate URL; if invalid, show a tip and skip autopopulate
    try {
      const u = new URL(ensureSlash(backendUrl()));
      if (!/^https?:$/.test(u.protocol)) throw new Error("bad protocol");
    } catch {
      setLocalError(t("rightPane.switch.validation.protocol"));
      return;
    }

    const controller = new AbortController();
    setFetching(true);
    try {
      const info = await fetchInfoJSON(backendUrl(), { signal: controller.signal });
      const list = Array.isArray(info?.domains) ? info.domains.filter(Boolean) : [];

      // Expect objects with a .name string; fallback to []
      const normalized = list
        .map((d) => (typeof d === "string" ? { name: d } : d))
        .filter((d) => d && typeof d.name === "string" && d.name.trim().length > 0);

      setDomains(normalized);

      if (normalized.length > 0) {
        if (props.domain && normalized.some((d) => d.name === props.domain)) {
          setDomain(props.domain);
        } else {
          setDomain(normalized[0].name);
        }
      } else {
        setLocalError(t("rightPane.switch.noDomains"));
      }
    } catch (e) {
      setLocalError(e.message || String(e));
    } finally {
      setFetching(false);
    }

    return () => controller.abort();
  });

  async function handleReload() {
    setLocalError("");
    try {
      const u = new URL(ensureSlash(backendUrl()));
      if (!/^https?:$/.test(u.protocol)) throw new Error(t("rightPane.switch.validation.protocol"));
    } catch (e) {
      setLocalError(e.message || t("rightPane.switch.validation.protocol"));
      return;
    }

    setFetching(true);
    try {
      const info = await fetchInfoJSON(backendUrl());
      const list = Array.isArray(info?.domains) ? info.domains.filter(Boolean) : [];
      const normalized = list
        .map((d) => (typeof d === "string" ? { name: d } : d))
        .filter((d) => d && typeof d.name === "string" && d.name.trim().length > 0);

      setDomains(normalized);

      if (normalized.length > 0 && !normalized.some((d) => d.name === domain())) {
        setDomain(normalized[0].name);
      }
      if (normalized.length === 0) setLocalError(t("rightPane.switch.noDomains"));
    } catch (e) {
      setLocalError(e.message || String(e));
    } finally {
      setFetching(false);
    }
  }

  async function onApply() {
    setLocalError("");
    try {
      const u = new URL(ensureSlash(backendUrl()));
      if (!/^https?:$/.test(u.protocol)) throw new Error(t("rightPane.switch.validation.protocol"));
      const chosen = (domain() || "").trim();
      if (!chosen) throw new Error(t("rightPane.switch.validation.domain"));

      await props.onApply({
        backendLink: ensureSlash(backendUrl().trim()),
        domain: chosen,
      });
    } catch (e) {
      setLocalError(e.message || String(e));
    }
  }

  return (
    <Show when={props.open}>
      <div class="fixed inset-0 z-40 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/40" onClick={props.onClose} />

        <div class="relative bg-white dark:bg-gray-800 rounded-lg shadow-lg w-[34rem] max-w-[95vw] p-4">
          <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-3">
            {t("rightPane.switch.title")}
          </h3>

          {/* Backend URL first */}
          <label class="block mb-3">
            <span class="text-sm text-gray-700 dark:text-gray-300">{t("rightPane.switch.backend.label")}</span>
            <div class="mt-1 flex gap-2">
              <input
                class="flex-1 px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100"
                value={backendUrl()}
                onInput={(e) => setBackendUrl(e.currentTarget.value)}
                placeholder="https://ui.savva.app/api/"
                spellcheck={false}
              />
              <button
                class="px-3 py-2 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-900 dark:text-gray-100 disabled:opacity-60"
                onClick={handleReload}
                disabled={fetching()}
                title={t("rightPane.switch.reload.title")}
              >
                {fetching() ? t("common.loading") : t("rightPane.switch.reload")}
              </button>
            </div>
            <p class="text-xs text-gray-500 mt-1">{t("rightPane.switch.backend.help")}</p>
          </label>

          {/* Domain depends on backend /info */}
          <label class="block mb-1">
            <span class="text-sm text-gray-700 dark:text-gray-300">{t("rightPane.switch.domain.label")}</span>
          </label>
          <select
            class="w-full px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 disabled:opacity-60"
            value={domain()}
            onChange={(e) => setDomain(e.currentTarget.value)}
            disabled={fetching() || domains().length === 0}
          >
            {domains().map((d) => (
              <option value={d.name}>{d.name}</option>
            ))}
          </select>

          {/* Small details for selected domain (optional, helpful) */}
          <Show when={selectedDomainObj()}>
            <div class="mt-2 text-xs text-gray-600 dark:text-gray-300 space-y-1">
              <Show when={selectedDomainObj().website}>
                <div>
                  {t("rightPane.switch.domain.website")}:{" "}
                  <a class="underline" href={selectedDomainObj().website} target="_blank" rel="noreferrer">
                    {selectedDomainObj().website}
                  </a>
                </div>
              </Show>

            </div>
          </Show>

          {/* Errors */}
          <Show when={localError() || props.error}>
            <p class="mt-2 text-sm text-red-500">
              {t("common.error")}: {localError() || props.error?.message}
            </p>
          </Show>

          {/* Actions */}
          <div class="mt-4 flex gap-2 justify-end">
            <button
              class="px-3 py-2 rounded bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-900 dark:text-gray-100"
              onClick={props.onClose}
            >
              {t("common.cancel")}
            </button>
            <button
              class="px-3 py-2 rounded bg-red-500 text-white hover:bg-red-600"
              onClick={props.onReset}
              title={t("rightPane.switch.reset.title")}
            >
              {t("rightPane.switch.reset")}
            </button>
            <button
              class="px-3 py-2 rounded bg-blue-600 text-white hover:bg-blue-700 disabled:opacity-60"
              onClick={onApply}
              disabled={props.loading || fetching()}
            >
              {props.loading || fetching() ? t("common.applying") : t("common.apply")}
            </button>
          </div>
        </div>
      </div>
    </Show>
  );
}
</file>

<file path="src/hooks/useConnect.js">
import { createSignal, onMount } from "solid-js";
import { parse } from "yaml";

export function useConnect() {
  const [config, setConfig] = createSignal(null);
  const [info, setInfo] = createSignal(null);
  const [error, setError] = createSignal(null);
  const [loading, setLoading] = createSignal(true);

  onMount(async () => {
    try {
      const res = await fetch("/default_connect.yaml", { cache: "no-store" });
      if (!res.ok) throw new Error(`YAML load failed: ${res.status}`);
      const text = await res.text();
      const data = parse(text);
      if (!data.backendLink) throw new Error("Missing backendLink in config");

      const backend = data.backendLink.endsWith("/")
        ? data.backendLink
        : data.backendLink + "/";

      const cfg = {
        domain: data.domain || "",
        backendLink: backend,
        default_ipfs_link: data.default_ipfs_link || ""
      };
      setConfig(cfg);

      const infoRes = await fetch(cfg.backendLink + "info");
      if (!infoRes.ok) throw new Error(`/info failed: ${infoRes.status}`);
      setInfo(await infoRes.json());
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  });

  return { config, info, error, loading };
}
</file>

<file path="src/i18n/useI18n.js">
// src/i18n/useI18n.js
import { createSignal } from "solid-js";
import en from "./en";
import ru from "./ru";

const DICTS = { en, ru };
const DEFAULT_LANG = "en";
const LANG_KEY = "lang";
const SHOW_KEYS_KEY = "i18n_show_keys";

let i18nSingleton;

function resolveKey(lang, key) {
  const dict = DICTS[lang] || {};
  if (dict[key] != null) return dict[key];
  if (DICTS[DEFAULT_LANG] && DICTS[DEFAULT_LANG][key] != null) return DICTS[DEFAULT_LANG][key];
  return `[${key}]`;
}

export const LANG_INFO = {
  en: { code: "EN", name: "English" },
  ru: { code: "RU", name: "Русский" }
};


export function useI18n() {
  if (!i18nSingleton) {
    const initialLang = (() => {
      try {
        const saved = localStorage.getItem(LANG_KEY);
        return saved && DICTS[saved] ? saved : DEFAULT_LANG;
      } catch { return DEFAULT_LANG; }
    })();

    const initialShowKeys = (() => {
      try {
        return localStorage.getItem(SHOW_KEYS_KEY) === "1";
      } catch { return false; }
    })();

    const [lang, setLangSignal] = createSignal(initialLang);
    const [showKeys, setShowKeysSignal] = createSignal(initialShowKeys);

    const setLang = (next) => {
      const value = DICTS[next] ? next : DEFAULT_LANG;
      setLangSignal(value);
      try { localStorage.setItem(LANG_KEY, value); } catch {}
    };

    const setShowKeys = (on) => {
      setShowKeysSignal(!!on);
      try { localStorage.setItem(SHOW_KEYS_KEY, on ? "1" : "0"); } catch {}
    };

    const t = (key) => {
      const base = resolveKey(lang(), key);
      return showKeys() ? `${base} [${key}]` : base;
    };

    i18nSingleton = {
      t,
      lang,
      setLang,
      showKeys,
      setShowKeys,
      available: Object.keys(DICTS),
    };
  }
  return i18nSingleton;
}
</file>

<file path="src/routing/hashRouter.js">
import { createSignal, onCleanup, onMount } from "solid-js";

function readHashPath() {
  const raw = window.location.hash || "";
  return raw.replace(/^#/, "") || "/";
}

const [route, setRoute] = createSignal(readHashPath());

function setFromHash() {
  setRoute(readHashPath());
}

export function navigate(path, { replace = false } = {}) {
  const target = path.startsWith("#") ? path : `#${path}`;
  if (replace) window.location.replace(target);
  else window.location.hash = path.startsWith("#") ? path.slice(1) : path;
}

export function useHashRouter() {
  onMount(() => {
    window.addEventListener("hashchange", setFromHash);
  });
  onCleanup(() => {
    window.removeEventListener("hashchange", setFromHash);
  });
  return { route, navigate };
}
</file>

<file path="src/ux/toast.js">
import { createSignal } from "solid-js";

export const [toasts, setToasts] = createSignal([]); // {id, type, message, details, expanded}

let counter = 0;

export function pushToast({ type = "info", message = "", details = null, autohideMs = 5000 }) {
  const id = ++counter;
  const item = { id, type, message: String(message || ""), details, expanded: false };
  setToasts((curr) => [...curr, item]);
  if (autohideMs > 0 && type !== "error") {
    setTimeout(() => dismissToast(id), autohideMs);
  }
  return id;
}

export function dismissToast(id) {
  setToasts((curr) => curr.filter((t) => t.id !== id));
}

export function toggleToast(id) {
  setToasts((curr) =>
    curr.map((t) => (t.id === id ? { ...t, expanded: !t.expanded } : t))
  );
}

/** Convenience: turn any Error (or unknown) into a compact, useful details object */
export function errorDetails(err, extra = {}) {
  if (!err) return extra || {};
  const base = {
    name: err.name,
    message: err.message,
    code: err.code,
    type: err.type,
    status: err.status,
    stack: err.stack,
    cause: err.cause && typeof err.cause === "object" ? {
      name: err.cause.name,
      message: err.cause.message,
      code: err.cause.code,
      status: err.cause.status,
    } : undefined,
  };
  // Some of our code throws {causes: Error[]} arrays (e.g., IPFS gateway fallbacks)
  if (Array.isArray(err.causes)) {
    base.causes = err.causes.map((e) => ({
      name: e?.name,
      message: e?.message,
      code: e?.code,
      status: e?.status,
    }));
  }
  // Merge caller-provided context (like URL, gateway, endpoint)
  return { ...base, ...extra };
}

/** push an error toast with extracted details */
export function pushErrorToast(err, context = {}) {
  return pushToast({
    type: "error",
    message: err?.message || "Unexpected error",
    details: errorDetails(err, context),
    autohideMs: 0, // errors stay until closed
  });
}
</file>

<file path="src/vite-env.d.js">
/// <reference types="vite/client" />
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="README.md">
## Usage

```bash
$ npm install # or pnpm install or yarn install
```

### Learn more on the [Solid Website](https://solidjs.com) and come chat with us on our [Discord](https://discord.com/invite/solidjs)

## Available Scripts

In the project directory, you can run:

### `npm run dev`

Runs the app in the development mode.<br>
Open [http://localhost:5173](http://localhost:5173) to view it in the browser.

### `npm run build`

Builds the app for production to the `dist` folder.<br>
It correctly bundles Solid in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br>
Your app is ready to be deployed!

## Deployment

Learn more about deploying your application with the [documentations](https://vite.dev/guide/static-deploy.html)
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.js"]
}
</file>

<file path="src/blockchain/wallet.js">
// src/blockchain/wallet.js
import { createSignal } from "solid-js";

const [walletAccount, setWalletAccount] = createSignal(null);
const [walletChainId, setWalletChainId] = createSignal(null);

export function isWalletAvailable() {
  return typeof window !== "undefined" && !!window.ethereum;
}

function hexChainId(n) {
  const id = Number(n);
  if (!Number.isFinite(id)) throw new Error(`Invalid chain id: ${n}`);
  return "0x" + id.toString(16);
}

let listenersReady = false;
function setupListeners() {
  const eth = window.ethereum;
  if (!eth || listenersReady) return;
  eth.on?.("accountsChanged", (accs) => {
    setWalletAccount(accs?.[0] || null);
  });
  eth.on?.("chainChanged", (id) => {
    const n = typeof id === "string" ? parseInt(id, 16) : +id;
    setWalletChainId(Number.isFinite(n) ? n : null);
  });
  listenersReady = true;
}

export async function eagerConnect() {
  const eth = window.ethereum;
  if (!eth) return false;
  setupListeners();
  try {
    const [accounts, chainIdHex] = await Promise.all([
      eth.request({ method: "eth_accounts" }),
      eth.request({ method: "eth_chainId" }).catch(() => null),
    ]);
    if (chainIdHex) {
      const n = parseInt(chainIdHex, 16);
      setWalletChainId(Number.isFinite(n) ? n : null);
    }
    if (accounts && accounts[0]) {
      setWalletAccount(accounts[0]);
      return true;
    }
    setWalletAccount(null);
    return false;
  } catch {
    return false;
  }
}

export async function connectWallet() {
  const eth = window.ethereum;
  if (!eth) throw new Error("No Ethereum wallet found");
  setupListeners();
  const accounts = await eth.request({ method: "eth_requestAccounts" });
  const chainIdHex = await eth.request({ method: "eth_chainId" }).catch(() => null);
  if (chainIdHex) {
    const n = parseInt(chainIdHex, 16);
    setWalletChainId(Number.isFinite(n) ? n : null);
  }
  setWalletAccount(accounts?.[0] || null);
}

/**
 * Switch to a chain; if the wallet doesn't know it, try to add it.
 * meta = {
 *   chainId: number,
 *   name: string,
 *   nativeCurrency: { name, symbol, decimals },
 *   rpcUrls: string[],
 *   blockExplorers?: string[]
 * }
 */
export async function switchOrAddChain(meta) {
  const eth = window.ethereum;
  if (!eth) throw new Error("No Ethereum wallet found");
  if (!meta || !meta.chainId) throw new Error("Missing chain metadata");

  const chainIdHexVal = hexChainId(meta.chainId);
  try {
    await eth.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: chainIdHexVal }],
    });
  } catch (e) {
    // 4902 = Unrecognized chain
    const code = e?.code ?? e?.data?.originalError?.code;
    if (code === 4902) {
      await eth.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: chainIdHexVal,
            chainName: meta.name || `Chain ${meta.chainId}`,
            nativeCurrency: meta.nativeCurrency || { name: "ETH", symbol: "ETH", decimals: 18 },
            rpcUrls: meta.rpcUrls || [],
            blockExplorerUrls: meta.blockExplorers || [],
          },
        ],
      });
    } else {
      throw e;
    }
  }

  // update signal with the (new) chain id
  try {
    const cid = await eth.request({ method: "eth_chainId" });
    if (cid) {
      const n = parseInt(cid, 16);
      setWalletChainId(Number.isFinite(n) ? n : null);
    }
  } catch { /* ignore */ }
}

export { walletAccount, walletChainId };
</file>

<file path="src/components/Toaster.jsx">
// src/components/Toaster.jsx
import { For, Show } from "solid-js";
import { toasts, dismissToast, toggleToast } from "../ux/toast";

const typeStyles = {
  info:    "bg-blue-600",
  success: "bg-emerald-600",
  warning: "bg-amber-600",
  error:   "bg-red-600",
};

function pretty(obj) {
  try { return JSON.stringify(obj, null, 2); } catch { return String(obj); }
}

async function copy(text) {
  try { await navigator.clipboard.writeText(text); } catch {}
}

export default function Toaster() {
  return (
    // Full-width bottom bar container; toasts align right when compact.
    // We disable pointer events on the container so it doesn't block the page,
    // and re-enable them on each toast.
    <div class="fixed inset-x-0 bottom-0 z-[1000] p-3 pointer-events-none">
      <div class="flex flex-col gap-2 items-end">
        <For each={toasts()}>
          {(t) => {
            const headerColor = typeStyles[t.type] || typeStyles.info;
            return (
              // When expanded: stretch to full width; when compact: hug right (max ~28rem)
              <div
                class={`pointer-events-auto w-full ${
                  t.expanded ? "" : "sm:w-[28rem] max-w-[92vw]"
                }`}
              >
                <div class="text-white rounded shadow overflow-hidden">
                  {/* Header bar */}
                  <div class={`flex items-center justify-between px-3 py-2 ${headerColor}`}>
                    <span class="text-sm font-medium">{t.message}</span>
                    <div class="flex items-center gap-1">
                      <Show when={t.details}>
                        <button
                          class="px-2 py-1 rounded bg-black/20 hover:bg-black/30 text-xs"
                          onClick={() => toggleToast(t.id)}
                          aria-expanded={t.expanded}
                          title={t.expanded ? "Hide details" : "Show details"}
                        >
                          {t.expanded ? "Hide" : "Details"}
                        </button>
                      </Show>
                      <button
                        class="px-2 py-1 rounded bg-black/20 hover:bg-black/30"
                        onClick={() => dismissToast(t.id)}
                        aria-label="Close notification"
                      >
                        ×
                      </button>
                    </div>
                  </div>

                  {/* Details panel — takes full width, tall & scrollable */}
                  <Show when={t.expanded && t.details}>
                    <div class="bg-gray-900 text-gray-100 px-4 py-3 max-h-[60vh] overflow-auto">
                      <pre class="whitespace-pre-wrap break-words text-[12px] leading-tight">
{pretty(t.details)}
                      </pre>
                      <div class="mt-2 flex justify-end">
                        <button
                          class="px-2 py-1 rounded bg-gray-700 hover:bg-gray-600 text-xs"
                          onClick={() => copy(pretty(t.details))}
                          title="Copy details to clipboard"
                        >
                          Copy
                        </button>
                      </div>
                    </div>
                  </Show>
                </div>
              </div>
            );
          }}
        </For>
      </div>
    </div>
  );
}
</file>

<file path="src/hooks/useTheme.js">
// src/hooks/useTheme.js
import { createSignal, onMount } from "solid-js";

export function useTheme() {
  const [theme, setTheme] = createSignal("light");

  onMount(() => {
    const savedTheme = localStorage.getItem("theme") || "light";
    setTheme(savedTheme);
    document.documentElement.classList.toggle("dark", savedTheme === "dark");
    console.log("Initial theme:", savedTheme, "dark class:", document.documentElement.classList.contains("dark")); // Debug
  });

  const toggleTheme = () => {
    const next = theme() === "dark" ? "light" : "dark";
    setTheme(next);
    document.documentElement.classList.toggle("dark", next === "dark");
    try { localStorage.setItem("theme", next); } catch {}
    console.log("Toggled to:", next, "dark class:", document.documentElement.classList.contains("dark")); // Debug
  };

  // Expose theme signal for external use
  useTheme.theme = theme;

  return [theme, toggleTheme];
}
</file>

<file path="src/i18n/ru.js">
// Auto-generated by i18n-sync.mjs. Do not edit by hand.
export default {
  "app.title": "SAVVA · SolidJS",
  "card.tailwindWorks": "Tailwind работает?",
  "debug.rightOpen": "???",
  "debug.theme": "???",
  "greeting.hello": "Привет, Алекс 👋",
  "rightPane.language": "Язык",
  "rightPane.option1": "Опция 1",
  "rightPane.option2": "Опция 2",
  "rightPane.option3": "Опция 3",
  "rightPane.showKeys": "Показывать ключи",
  "ui.mode.dark": "Тёмная тема",
  "ui.mode.light": "Светлая тема",
  "settings.title": "Настройки",
  "settings.close": "Закрыть",
  "settings.debug.title": "Отладка",
  "settings.debug.showKeys.label": "Показывать ключи переводов",
  "settings.debug.showKeys.help":
    "Если включено, каждая строка добавит в конец свой ключ в квадратных скобках.",
};
</file>

<file path="src/ipfs/index.js">
// Minimal IPFS client with gateway fallback.
// Usage:
//   import { ipfs } from "../ipfs";
//   const res = await ipfs.fetch("Qm.../file.json", { gateways: myGateways });
//   const json = await ipfs.getJSON("ipfs://Qm.../file.json", { gateways: myGateways });

function ensureSlash(s) { return s.endsWith("/") ? s : s + "/"; }
function stripPrefix(s, p) { return s.startsWith(p) ? s.slice(p.length) : s; }

function normalizeInput(input) {
  // Accepts: "ipfs://CID/path", "/ipfs/CID/path", "CID[/path]"
  let s = String(input || "").trim();
  if (!s) throw new Error("ipfs: empty input");
  s = stripPrefix(s, "ipfs://");
  s = stripPrefix(s, "/ipfs/");
  s = stripPrefix(s, "ipfs/");
  return s; // "CID[/path]"
}

function buildUrl(baseGateway, cidPath) {
  const base = normalizeGatewayBase(baseGateway).replace(/\/+$/g, "");
  const hasIpfs = /\/ipfs$/i.test(base);
  const prefix = hasIpfs ? base + "/" : base + "/ipfs/";
  return prefix + cidPath.replace(/^\/+/g, "");
}


async function fetchWithTimeout(url, { timeoutMs, signal, ...init }) {
  const controller = new AbortController();
  const tid = setTimeout(() => controller.abort(new DOMException("Timeout", "TimeoutError")), timeoutMs);
  const compositeSignal = signal
    ? new AbortController()
    : null;

  // If a signal was provided, abort our controller when it aborts.
  if (signal && compositeSignal) {
    signal.addEventListener("abort", () => controller.abort(signal.reason), { once: true });
  }

  try {
    const res = await fetch(url, { ...init, signal: controller.signal });
    return res;
  } finally {
    clearTimeout(tid);
  }
}

async function tryGateways(cidPath, gateways, { timeoutMs = 8000, init = {} } = {}) {
  const errors = [];
  for (const gw of gateways) {
    const url = buildUrl(gw, cidPath);
    try {
      const res = await fetchWithTimeout(url, { timeoutMs, ...init });
      if (res && res.ok) return { res, url, gateway: gw };
      // Treat non-2xx as failure and continue
      errors.push(new Error(`Gateway ${gw} -> HTTP ${res.status}`));
    } catch (e) {
      errors.push(new Error(`Gateway ${gw} -> ${e?.name || "Error"}: ${e?.message || e}`));
    }
  }
  const err = new Error("All IPFS gateways failed");
  err.causes = errors;
  throw err;
}

async function fetchIpfs(input, opts = {}) {
  const {
    gateways = [],
    timeoutMs = 8000,
    signal,
    cache = "default",
    headers,
    method = "GET",
  } = opts;

  if (!gateways || gateways.length === 0) {
    throw new Error("ipfs.fetch: no gateways provided");
  }
  const cidPath = normalizeInput(input);
  const { res, url, gateway } = await tryGateways(cidPath, gateways, {
    timeoutMs,
    init: { method, headers, cache, signal }
  });
  return { response: res, url, gateway };
}

async function getJSON(input, opts) {
  const { response, url, gateway } = await fetchIpfs(input, { ...opts, headers: { Accept: "application/json", ...(opts?.headers || {}) } });
  return { data: await response.json(), url, gateway };
}

async function getText(input, opts) {
  const { response, url, gateway } = await fetchIpfs(input, opts);
  return { data: await response.text(), url, gateway };
}

async function getBlob(input, opts) {
  const { response, url, gateway } = await fetchIpfs(input, opts);
  return { data: await response.blob(), url, gateway };
}

async function getArrayBuffer(input, opts) {
  const { response, url, gateway } = await fetchIpfs(input, opts);
  return { data: await response.arrayBuffer(), url, gateway };
}

export const ipfs = {
  fetch: fetchIpfs,
  getJSON,
  getText,
  getBlob,
  getArrayBuffer,
  // Utils you may want in other places:
  normalizeInput,
  buildUrl,
};
</file>

<file path="src/index.jsx">
import { render } from "solid-js/web";
import "./index.css";
import App from "./App";
import { AppProvider } from "./context/AppContext.jsx";

const root = document.getElementById("root");

render(() => (
  <AppProvider>
    <App />
  </AppProvider>
), root);
</file>

<file path="index.html">
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SAVVA · SolidJS</title>

  <!-- Preload theme to avoid flash -->
  <script>
    (function () {
      try {
        const saved = localStorage.getItem("theme");
        const systemDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const theme = saved || (systemDark ? "dark" : "light");
        document.documentElement.classList.toggle("dark", theme === "dark");
      } catch { }
    })();
  </script>

  <script>
    (function () {
      // If there is a real path (e.g., /settings) but no hash, rewrite to hash form: /#/settings
      if (!location.hash && location.pathname !== "/") {
        var newHash = "#" + location.pathname + location.search + location.hash;
        history.replaceState(null, "", "/" + newHash);
      }
    })();
  </script>


  <!-- Load app after theme class is set -->
  <script type="module" src="/src/index.jsx"></script>
</head>

<body>
  <div id="root"></div>
</body>

</html>
</file>

<file path="postcss.config.js">
// postcss.config.js
export default {
  plugins: {
    '@tailwindcss/postcss': { config: './tailwind.config.js' },
    autoprefixer: {},
  },
};
</file>

<file path="vite.config.js">
// vite.config.js
import { defineConfig } from 'vite';
import solid from 'vite-plugin-solid';

export default defineConfig({
  plugins: [solid()],
  server: {
    port: 5173,
  },
  build: {
    target: 'esnext',
  },
});
</file>

<file path="src/pages/Settings.jsx">
// src/pages/Settings.jsx
import { For } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import LocalIpfsSection from "../components/settings/LocalIpfsSection.jsx";
import BackButton from "../components/ui/BackIconButton.jsx";
import BackIconButton from "../components/ui/BackIconButton.jsx";

export default function Settings() {
  const app = useApp();
  const { t } = app;

  return (
    <main class="p-4 max-w-3xl mx-auto space-y-6">
  {/* Title left, back icon right */}
  <div class="flex items-center justify-between">
    <h2 class="text-2xl font-semibold">{t("settings.title")}</h2>
    <BackIconButton title={t("settings.back")} />
  </div>

      {/* Local IPFS (separate component) */}
      < LocalIpfsSection />

      {/* Developer */}
      < section class="bg-white dark:bg-gray-800 rounded-lg shadow p-4 space-y-3">
        <h3 class="text-lg font-medium">{t("settings.developer.title")}</h3>

        <label class="flex items-center gap-2">
          <input
            type="checkbox"
            checked={app.showKeys()}
            onInput={(e) => app.setShowKeys(e.currentTarget.checked)}
          />
          <span>{t("settings.developer.showKeys")}</span>
        </label>

        <div class="bg-white/60 dark:bg-black/30 rounded p-3">
          <h4 class="font-medium mb-2">{t("settings.debug.gateways.title")}</h4>
          <ul class="list-disc pl-6 text-sm">
            <For each={app.activeIpfsGateways()}>
              {(g) => <li>{g}</li>}
            </For>
          </ul>
        </div>
      </section>
    </main >
  );
}
</file>

<file path="src/index.css">
/* src/index.css */
@import "tailwindcss";

@custom-variant dark (&:where(.dark, .dark *));
</file>

<file path="tailwind.config.js">
// tailwind.config.js
export default {
  darkMode: "class",
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: { extend: {} },
  plugins: [],
};
</file>

<file path="src/components/Header.jsx">
// src/components/Header.jsx
import { Show, createSignal, onMount } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import {
  connectWallet,
  walletAccount,
  walletChainId,
  isWalletAvailable,
  eagerConnect,             // ← NEW
} from "../blockchain/wallet";
import { getChainLogo } from "../blockchain/chainLogos";

function shortAddr(addr) {
  if (!addr) return "";
  return addr.slice(0, 6) + "…" + addr.slice(-4);
}

export default function Header({ onTogglePane }) {
  const app = useApp();
  const [copyState, setCopyState] = createSignal("");
  const [eagerDone, setEagerDone] = createSignal(false);   // ← NEW

  const desiredId = () => app.desiredChainId();
  const mismatched = () =>
    walletChainId() != null &&
    desiredId() != null &&
    walletChainId() !== desiredId();

  onMount(async () => {
    if (isWalletAvailable()) {
      // Try rehydrate silently (no prompt)
      await eagerConnect();
      // (Do NOT auto-switch network on eager connect; we only hint via UI.)
    }
    setEagerDone(true);
  });

  async function onConnect() {
    try {
      await connectWallet();
      // After manual connect, we can try switching to backend’s chain
      if (desiredId()) {
        try { await app.ensureWalletOnDesiredChain(); } catch {}
      }
    } catch (e) {
      console.error(e);
      alert(e?.message || String(e));
    }
  }

  async function copyAddress() {
    try {
      await navigator.clipboard.writeText(walletAccount());
      setCopyState("copied");
      setTimeout(() => setCopyState(""), 1200);
    } catch {}
  }

  async function onSwitchChain() {
    try {
      await app.ensureWalletOnDesiredChain();
    } catch (e) {
      console.error(e);
      alert(e?.message || String(e));
    }
  }

  const chainLogoSrc = () => {
    const id = desiredId();
    return id ? getChainLogo(id) : null;
  };

  return (
    <header class="bg-white dark:bg-gray-800 shadow flex items-center justify-between p-2 sticky top-0 z-10 h-12">
      <h1 class="text-xl font-bold text-gray-900 dark:text-gray-100 ml-2">
        {app.config()?.domain || "…"}
      </h1>

      <div class="flex items-center gap-2 mr-2">
        {/* Wallet area */}
        <Show
          when={walletAccount()}
          fallback={
            // Only show Connect after we *tried* eager connect; hide if no wallet installed
            <Show when={eagerDone() && isWalletAvailable()}>
              <button
                class="px-3 py-1 rounded bg-emerald-500 text-white hover:bg-emerald-600"
                onClick={onConnect}
                title="Connect your wallet"
              >
                Connect wallet
              </button>
            </Show>
          }
        >
          <div class="flex items-center gap-2">
            {/* Address pill */}
            <button
              class="px-2 py-1 rounded bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-gray-100 hover:bg-gray-200 dark:hover:bg-gray-600"
              onClick={copyAddress}
              title="Click to copy address"
            >
              {shortAddr(walletAccount())}
            </button>

            {/* If chain is correct → logo only; if wrong → red Change chain button */}
            <Show
              when={!mismatched()}
              fallback={
                <button
                  class="px-2 py-1 rounded bg-red-600 text-white hover:bg-red-700"
                  onClick={onSwitchChain}
                  title="Switch to the required network"
                >
                  Change chain
                </button>
              }
            >
              <Show when={chainLogoSrc()}>
                <img
                  src={chainLogoSrc()}
                  alt="chain"
                  class="w-5 h-5"
                  title="Connected to the required network"
                />
              </Show>
            </Show>

            {/* tiny copied hint */}
            <Show when={copyState() === "copied"}>
              <span class="text-xs text-emerald-600">Copied</span>
            </Show>
          </div>
        </Show>

        {/* Right menu toggle */}
        <button
          class="p-1 text-gray-600 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700 rounded transition"
          onClick={onTogglePane}
          aria-label="Open menu"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
          </svg>
        </button>
      </div>
    </header>
  );
}
</file>

<file path="src/context/AppContext.jsx">
import { createContext, useContext, createSignal, onMount, createMemo, onCleanup } from "solid-js";
import { parse } from "yaml";
import { getChainMeta } from "../blockchain/chains";
import { switchOrAddChain } from "../blockchain/wallet";
import { pushToast, pushErrorToast, errorDetails } from "../ux/toast";
import { useI18n } from "../i18n/useI18n";



// ---------- helpers ----------
function ensureSlash(s) { if (!s) return ""; return s.endsWith("/") ? s : s + "/"; }
function trimSlash(s) { return (s || "").replace(/\/+$/g, ""); }
async function fetchWithTimeout(url, { timeoutMs = 7000, method = "GET", headers, signal, body } = {}) {
  const controller = new AbortController();
  const tid = setTimeout(() => controller.abort(new DOMException("Timeout", "TimeoutError")), timeoutMs);
  if (signal) signal.addEventListener("abort", () => controller.abort(signal.reason), { once: true });
  try {
    const res = await fetch(url, { method, headers, body, signal: controller.signal, cache: "no-store" });
    return res;
  } finally {
    clearTimeout(tid);
  }
}

// ---------- context ----------
const AppContext = createContext();
const OVERRIDE_KEY = "connect_override_v1";
const IPFS_LOCAL_KEY = "ipfs_local_enabled_v1";
const IPFS_LOCAL_API_KEY = "ipfs_local_api_v1";
const IPFS_LOCAL_GATEWAY_KEY = "ipfs_local_gateway_v1";

function pickPersistable(cfg) {
  if (!cfg) return null;
  return {
    domain: cfg.domain || "",
    backendLink: ensureSlash(cfg.backendLink || "")
  };
}

function loadOverride() {
  try { const raw = localStorage.getItem(OVERRIDE_KEY); if (!raw) return null; return pickPersistable(JSON.parse(raw)); } catch { return null; }
}
function saveOverride(obj) {
  try { if (!obj) localStorage.removeItem(OVERRIDE_KEY); else localStorage.setItem(OVERRIDE_KEY, JSON.stringify(pickPersistable(obj))); } catch { }
}

export function AppProvider(props) {
  const i18n = useI18n();
  const [config, setConfig] = createSignal(null);
  const [info, setInfo] = createSignal(null);
  const [error, setError] = createSignal(null);
  const [loading, setLoading] = createSignal(true);
  const [lastUpdatedAt, setLastUpdatedAt] = createSignal(null);

  // Local IPFS prefs/state
  const [localIpfsEnabled, setLocalIpfsEnabled] = createSignal(localStorage.getItem(IPFS_LOCAL_KEY) === "1");
  const [localIpfsApiUrl, setLocalIpfsApiUrl] = createSignal(localStorage.getItem(IPFS_LOCAL_API_KEY) || "http://localhost:5001");
  const [localIpfsGateway, setLocalIpfsGateway] = createSignal(localStorage.getItem(IPFS_LOCAL_GATEWAY_KEY) || "");
  const [localIpfsStatus, setLocalIpfsStatus] = createSignal("unknown"); // "unknown" | "ok" | "down"
  let ipfsMonitorTid = null;

  async function fetchInfo(cfg) {
    const res = await fetch(cfg.backendLink + "info", { headers: { Accept: "application/json" } });
    if (!res.ok) throw new Error(`/info failed: ${res.status}`);
    return await res.json();
  }

  async function applyConfig(nextCfg) {
    setConfig(nextCfg);
    const data = await fetchInfo(nextCfg);
    setInfo(data);
    setLastUpdatedAt(Date.now());
  }

  async function init() {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch("/default_connect.yaml", { cache: "no-store" });
      if (!res.ok) throw new Error(`YAML load failed: ${res.status}`);
      const text = await res.text();
      const data = parse(text) || {};
      if (!data.backendLink) throw new Error("Missing backendLink in config");

      const baseCfg = {
        domain: data.domain || "",
        backendLink: ensureSlash(data.backendLink),
        gear: !!data.gear,
      };
      const ovr = loadOverride();
      const merged = { ...baseCfg, ...(ovr ? { ...ovr } : {}) };
      await applyConfig(merged);

      // kick off local IPFS monitor if enabled
      if (localIpfsEnabled() && localIpfsApiUrl()) startLocalIpfsMonitor();
    } catch (e) {
      setError(e);
    } finally {
      setLoading(false);
    }
  }

  // ----- Connect changes -----
  async function updateConnect(partial) {
    try {
      setLoading(true);
      setError(null);
      const cur = config() || {};
      const next = {
        ...cur,
        ...partial,
        backendLink: ensureSlash(partial?.backendLink ?? cur.backendLink),
      };
      const backendChanged = next.backendLink !== cur.backendLink;
      if (backendChanged) {
        await applyConfig(next);
      } else {
        setConfig(next);
        setLastUpdatedAt(Date.now());
      }
      saveOverride(next);
    } catch (e) {
      setError(e);
    } finally {
      setLoading(false);
    }
  }

  function setDomain(nextDomain) {
    const cur = config() || {};
    const next = { ...cur, domain: nextDomain || "" };
    setConfig(next);
    saveOverride(next);
    setLastUpdatedAt(Date.now());
  }

  async function clearConnectOverride() {
    saveOverride(null);
    await init();
  }

  onMount(init);
  onCleanup(() => stopLocalIpfsMonitor());

  // ----- Derived helpers from /info -----
  const supportedDomains = createMemo(() => {
    const data = info();
    const list = Array.isArray(data?.domains) ? data.domains : [];
    return list.map((d) => (typeof d === "string" ? d : d?.name)).filter((name) => typeof name === "string" && name.trim().length > 0);
  });

  const selectedDomain = createMemo(() => {
    const data = info();
    const cur = config();
    if (!data || !cur) return null;
    const list = Array.isArray(data.domains) ? data.domains : [];
    return list.find((d) => (typeof d === "string" ? d === cur.domain : d?.name === cur.domain)) || null;
  });

  const desiredChainId = createMemo(() => (typeof info()?.blockchain_id === "number" ? info().blockchain_id : null));
  const desiredChain = createMemo(() => { const id = desiredChainId(); return id ? getChainMeta(id) : null; });
  async function ensureWalletOnDesiredChain() {
    const meta = desiredChain();
    if (!meta) throw new Error("Unknown target chain");
    await switchOrAddChain(meta);
  }

  const remoteIpfsGateways = createMemo(() => {
    const arr = info()?.ipfs_gateways;
    return Array.isArray(arr) ? arr.filter(Boolean).map((s) => ensureSlash(s.trim())).filter(Boolean) : [];
  });

const activeIpfsGateways = createMemo(() => {
  // STRICT MODE: if local IPFS is enabled, use ONLY the local gateway
  if (localIpfsEnabled() && localIpfsGateway()) {
    return [ensureSlash(localIpfsGateway())];
  }
  // otherwise use the remote list from /info
  return remoteIpfsGateways();
});


  // ----- Local IPFS: probe + monitor -----
  async function probeLocalIpfs(apiUrl) {
    const base = trimSlash(apiUrl || "");
    if (!base) throw new Error("Local IPFS API URL is empty");
    // CORS note: browser needs CORS on local node
    const url = `${base}/api/v0/config/show`;
    const res = await fetchWithTimeout(url, { method: "POST", timeoutMs: 7000 });
    if (!res.ok) throw new Error(`IPFS RPC error: ${res.status}`);
    const cfg = await res.json();
    let gw = cfg?.Addresses?.Gateway || cfg?.Addresses?.["Gateway"];
    if (!gw || typeof gw !== "string") throw new Error("Gateway not found in IPFS config");
    return ensureSlash(gw);
  }

async function enableLocalIpfs(apiUrl) {
  try {
    const gw = await probeLocalIpfs(apiUrl);  // already normalized to http://.../
    setLocalIpfsEnabled(true);
    setLocalIpfsApiUrl(apiUrl);
    setLocalIpfsGateway(gw);
    localStorage.setItem(IPFS_LOCAL_KEY, "1");
    localStorage.setItem(IPFS_LOCAL_API_KEY, apiUrl);
    localStorage.setItem(IPFS_LOCAL_GATEWAY_KEY, gw);
    setLocalIpfsStatus("ok");
    pushToast({ type: "success", message: `Local IPFS enabled. Gateway: ${gw}` });
    startLocalIpfsMonitor();
    return gw;
  } catch (e) {
    setLocalIpfsEnabled(false);
    setLocalIpfsStatus("down");
    pushErrorToast(e, { op: "enableLocalIpfs", apiUrl });
    throw e;
  }
}

function multiaddrToHttp(ma) {
  if (typeof ma !== "string" || !ma.startsWith("/")) return ma;
  const parts = ma.split("/").filter(Boolean);
  let host = null, port = null;
  for (let i = 0; i < parts.length; i += 2) {
    const k = parts[i], v = parts[i+1];
    if (k === "ip4" || k === "dns4" || k === "dns6") host = v;
    else if (k === "ip6") host = v && v.includes(":") ? `[${v}]` : v;
    else if (k === "tcp") port = v;
  }
  if (!host || !port) return ma;
  return `http://${host}:${port}/`;
}

function normalizeGatewayBase(g) {
  const base = g.startsWith("/") ? multiaddrToHttp(g) : g;
  return ensureSlash(base);
}


  async function probeLocalIpfs(apiUrl) {
  const base = trimSlash(apiUrl || "");
  if (!base) throw new Error("Local IPFS API URL is empty");
  const url = `${base}/api/v0/config/show`;
  const res = await fetchWithTimeout(url, { method: "POST", timeoutMs: 7000 });
  if (!res.ok) throw new Error(`IPFS RPC error: ${res.status}`);
  const cfg = await res.json();
  let gw = cfg?.Addresses?.Gateway || cfg?.Addresses?.["Gateway"];
  if (!gw || typeof gw !== "string") throw new Error("Gateway not found in IPFS config");
  const httpGw = gw.startsWith("/") ? multiaddrToHttp(gw) : gw; // <-- normalize
  return ensureSlash(httpGw);
}

  function disableLocalIpfs() {
    stopLocalIpfsMonitor();
    setLocalIpfsEnabled(false);
    setLocalIpfsGateway("");
    setLocalIpfsStatus("unknown");
    localStorage.setItem(IPFS_LOCAL_KEY, "0");
    localStorage.removeItem(IPFS_LOCAL_GATEWAY_KEY);
    pushToast({ type: "info", message: "Local IPFS disabled" });
  }

  async function pingLocalIpfs() {
    try {
      const base = trimSlash(localIpfsApiUrl());
      if (!base) throw new Error("No API URL");
      const res = await fetchWithTimeout(`${base}/api/v0/id`, { method: "POST", timeoutMs: 5000 });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      setLocalIpfsStatus("ok");
      return true;
    } catch (e) {                      // <-- add (e)
      setLocalIpfsStatus("down");
      pushErrorToast(e, { op: "pingLocalIpfs", apiUrl: localIpfsApiUrl() });
      return false;
    }
  }

  function startLocalIpfsMonitor() {
    stopLocalIpfsMonitor();
    // first immediate ping (don’t spam toasts on the very first success)
    pingLocalIpfs();
    ipfsMonitorTid = setInterval(pingLocalIpfs, 20000);
  }
  function stopLocalIpfsMonitor() {
    if (ipfsMonitorTid) { clearInterval(ipfsMonitorTid); ipfsMonitorTid = null; }
  }

  const value = {
    // state
    config, info, error, loading, lastUpdatedAt,

    // preferences/state: local IPFS
    localIpfsEnabled,
    localIpfsApiUrl,
    localIpfsGateway,
    localIpfsStatus,

    // convenience
    supportedDomains,
    selectedDomain,
    desiredChainId,
    desiredChain,
    remoteIpfsGateways,
    activeIpfsGateways,

    // actions
    reload: init,
    updateConnect,
    clearConnectOverride,
    setDomain,
    ensureWalletOnDesiredChain,

    // local IPFS actions
    enableLocalIpfs,
    disableLocalIpfs,
    setLocalIpfsApiUrl, // so Settings can update the URL field live

    // i18n (now globally available through AppContext)
    t: i18n.t,
    lang: i18n.lang,
    setLang: i18n.setLang,
    showKeys: i18n.showKeys,
    setShowKeys: i18n.setShowKeys,
    i18nAvailable: i18n.available,
  };

  return <AppContext.Provider value={value}>{props.children}</AppContext.Provider>;
}

export function useApp() {
  const ctx = useContext(AppContext);
  if (!ctx) throw new Error("useApp must be used inside <AppProvider>");
  return ctx;
}
</file>

<file path="src/i18n/en.js">
// Auto-generated by i18n-sync.mjs. Do not edit by hand.
export default {
  "app.title": "SAVVA · SolidJS",
  "card.tailwindWorks": "Tailwind works?",
  "debug.rightOpen": "???",
  "debug.theme": "???",
  "greeting.hello": "Hello, Alex 👋",
  "rightPane.language": "Language",
  "rightPane.option1": "Option 1",
  "rightPane.option2": "Option 2",
  "rightPane.option3": "Option 3",
  "rightPane.showKeys": "Show translation keys",
  "ui.mode.dark": "Dark mode",
  "ui.mode.light": "Light mode",
  "settings.title": "Settings",
  "settings.close": "Close",
  "settings.debug.title": "Debug",
  "settings.debug.showKeys.label": "Show translation keys",
  "settings.debug.showKeys.help":
    "When enabled, every translated string will append its key in square brackets.",
      "rightPane.close": "Close menu",
  "rightPane.settings": "Settings",
  "rightPane.switch.open": "Switch backend / domain",
  "rightPane.switch.title": "Switch backend / domain",
  "rightPane.switch.domain.label": "Domain",
  "rightPane.switch.backend.label": "Backend URL (ends with /)",
  "rightPane.switch.reset": "Reset to defaults",
  "rightPane.switch.reset.title": "Clear local override and reload defaults from default_connect.yaml",

  "init.title": "SAVVA · Init",
  "init.loading": "Loading configuration…",

  "common.cancel": "Cancel",
  "common.apply": "Apply",
  "common.applying": "Applying…",
  "common.error": "Error",
  "common.retry": "Retry",
    "rightPane.switch.backend.help": "The app will fetch /info from this URL to list supported domains.",
  "rightPane.switch.reload": "Load domains",
  "rightPane.switch.reload.title": "Fetch /info and refresh the domain list",

  "rightPane.switch.domain.help": "Choose the domain from the backend reporting supported list.",
  "rightPane.switch.domain.empty": "No domains available. Check backend URL and try loading again.",
  "rightPane.switch.noDomains": "Backend returned no domains. You can still apply, but the domain will be empty.",
  "rightPane.switch.validation.domain": "Domain cannot be empty.",
  "rightPane.switch.validation.protocol": "Backend URL must start with http:// or https://",
  "rightPane.switch.domain.website": "Website",

  "settings.title": "Settings",

  "settings.localIpfs.title": "Local IPFS",
  "settings.localIpfs.enableCheckbox": "Use local IPFS node",
  "settings.localIpfs.apiUrl.label": "Local IPFS API URL",
  "settings.localIpfs.apiUrl.help": "We will call",
  "settings.localIpfs.testEnable": "Test & enable",
  "settings.localIpfs.disable": "Disable",
  "settings.localIpfs.status.label": "Status",
  "settings.localIpfs.gateway.label": "Gateway",

  "settings.localIpfs.help.toggle.show": "How to enable Local IPFS (CORS)",
  "settings.localIpfs.help.toggle.hide": "Hide help",
  "settings.localIpfs.help.intro": "Your browser must be allowed to call the local IPFS API endpoints",
  "settings.localIpfs.help.api.title": "1) Allow your app origin on the API (required)",
  "settings.localIpfs.help.api.tip": "Tip: keep this strict in dev; avoid \"*\" for production setups.",
  "settings.localIpfs.help.gateway.title": "2) (Optional) Allow your app on the Gateway (for direct asset fetches)",
  "settings.localIpfs.help.gateway.note": "Only needed if the app loads files straight from the local gateway origin.",
  "settings.localIpfs.help.restart.title": "3) Restart the daemon",
  "settings.localIpfs.help.verify.title": "4) Verify",
  "settings.localIpfs.help.verify.note": "The gateway is usually",
  "settings.localIpfs.help.proxy.title": "Alternative for dev (no IPFS config changes)",
  "settings.localIpfs.help.proxy.text": "Proxy the API through Vite so it’s same-origin:",
  "settings.localIpfs.help.proxy.note": "Then set “Local IPFS API URL” to and click “Test & enable”.",

  "settings.developer.title": "Developer",
  "settings.developer.preview": "Preview:",

  "settings.debug.gateways.title": "IPFS Gateways (active order)",

  "common.checking": "Checking…",

  "common.loading": "Loading…",
    "settings.developer.title": "Developer",
  "settings.developer.showKeys": "Show translation keys", 
  "settings.debug.gateways.title": "IPFS Gateways (active order)",  

}
</file>

<file path="package.json">
{
  "name": "savva-ui-solidjs",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@solidjs/router": "^0.15.3",
    "solid-js": "^1.9.8",
    "viem": "^2.33.3",
    "yaml": "^2.8.1"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.12",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.12",
    "vite": "^7.1.2",
    "vite-plugin-solid": "^2.11.8"
  }
}
</file>

<file path="src/components/RightPane.jsx">
// src/components/RightPane.jsx
import { createEffect, createSignal, Show } from "solid-js";
import { useTheme } from "../hooks/useTheme";
import { useI18n, LANG_INFO } from "../i18n/useI18n";
import { navigate } from "../routing/hashRouter";
import { useApp } from "../context/AppContext.jsx";
import SwitchConnectDialog from "./SwitchConnectDialog.jsx";

export default function RightPane({ isOpen, onClose }) {
  const [theme, toggleTheme] = useTheme();
  const { t, lang, setLang, available } = useI18n();
  const app = useApp();

  createEffect(() => {
    console.log("RightPane: isOpen changed to:", isOpen());
  });

  const handlePanelClick = (e) => {
    if (e.target === e.currentTarget) onClose();
  };

  RightPane.theme = theme;

  const [showSwitch, setShowSwitch] = createSignal(false);

  async function applySwitch(values) {
    await app.updateConnect(values);
    setShowSwitch(false);
  }

  async function resetDefaults() {
    await app.clearConnectOverride();
    setShowSwitch(false);
  }

  return (
    <>
      <div
        class={`fixed top-0 right-0 w-64 h-full bg-white dark:bg-gray-800 shadow-lg z-30 ${
          isOpen() ? "right-0" : "right-[-256px]"
        } transition-all duration-300`}
        onClick={handlePanelClick}
        data-testid="right-pane"
      >
        <div class="p-4 space-y-3">
          <button
            class="p-2 text-gray-600 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700 rounded"
            onClick={onClose}
            aria-label={t("rightPane.close")}
          >
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>

          <button
            onClick={() => { toggleTheme(); console.log("Theme toggled:", theme()); }}
            class="w-full text-left px-4 py-2 bg-blue-500 dark:bg-blue-700 text-white rounded hover:bg-blue-600 dark:hover:bg-blue-800 transition"
          >
            {theme() === "dark" ? t("ui.mode.dark") : t("ui.mode.light")}
            <span class="ml-2">{theme() === "dark" ? "🌙" : "☀️"}</span>
          </button>

          <div class="pt-1">
            <label class="block text-gray-900 dark:text-gray-100 mb-1">{t("rightPane.language")}</label>
            <select
              class="w-full px-4 py-2 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 border border-gray-200 dark:border-gray-700"
              value={lang()}
              onInput={(e) => setLang(e.currentTarget.value)}
            >
              {available.map((code) => {
                const info = LANG_INFO[code] || { code: code.toUpperCase(), name: code };
                return (
                  <option value={code}>
                    [{info.code}] {info.name}
                  </option>
                );
              })}
            </select>
          </div>

          {/* Menu list */}
          <nav class="pt-2">
            <ul class="space-y-1">
              <li>
                <div
                  class="px-4 py-2 rounded hover:bg-gray-200 dark:hover:bg-gray-700 cursor-pointer text-gray-900 dark:text-gray-100"
                  role="button"
                  tabIndex={0}
                  onClick={() => { navigate("/settings"); onClose(); }}
                  onKeyDown={(e) => {
                    if (e.key === "Enter" || e.key === " ") {
                      e.preventDefault();
                      navigate("/settings"); onClose();
                    }
                  }}
                >
                  {t("rightPane.settings")}
                </div>
              </li>

              <Show when={app.config()?.gear}>
                <li>
                  <div
                    class="px-4 py-2 rounded hover:bg-gray-200 dark:hover:bg-gray-700 cursor-pointer text-gray-900 dark:text-gray-100"
                    role="button"
                    tabIndex={0}
                    onClick={() => setShowSwitch(true)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter" || e.key === " ") {
                        e.preventDefault();
                        setShowSwitch(true);
                      }
                    }}
                  >
                    {t("rightPane.switch.open")}
                  </div>
                </li>
              </Show>
            </ul>
          </nav>
        </div>
      </div>

      {isOpen() && (
        <div
          class="fixed inset-0 bg-black opacity-20 z-20"
          style={{ backgroundColor: "rgba(0, 0, 0, 0.2)" }}
          data-testid="overlay"
          onClick={onClose}
        />
      )}

      <SwitchConnectDialog
        open={showSwitch()}
        domain={app.config()?.domain}
        backendLink={app.config()?.backendLink}
        loading={app.loading()}
        error={app.error()}
        onApply={applySwitch}
        onReset={resetDefaults}
        onClose={() => setShowSwitch(false)}
      />
    </>
  );
}
</file>

<file path="src/App.jsx">
import { createSignal, onMount, Show } from "solid-js";
import Header from "./components/Header";
import RightPane from "./components/RightPane";
import Settings from "./pages/Settings";
import { useHashRouter } from "./routing/hashRouter";
import { useApp } from "./context/AppContext.jsx";
import { useI18n } from "./i18n/useI18n";
import Toaster from "./components/Toaster";

export default function App() {
  const [isPaneOpen, setIsPaneOpen] = createSignal(false);
  const { route } = useHashRouter();
  const app = useApp();
  const { t } = useI18n();

  onMount(() => {
    const handleKeydown = (e) => { if (e.key === "Escape") setIsPaneOpen(false); };
    document.addEventListener("keydown", handleKeydown);
    return () => document.removeEventListener("keydown", handleKeydown);
  });

  const togglePane = () => setIsPaneOpen(!isPaneOpen());

  return (
    <div class="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300">
      <Header onTogglePane={togglePane} />
      <RightPane isOpen={isPaneOpen} onClose={togglePane} />

      <Show when={route() === "/settings"} fallback={
        <main class="p-4 max-w-7xl mx-auto">
          <h2 class="text-xl">{t("init.title")}</h2>

          <Show when={app.loading()}>
            <p>{t("init.loading")}</p>
          </Show>

          <Show when={app.error()}>
            <div class="text-red-500">
              {t("common.error")}: {app.error().message}
              <button
                class="ml-3 px-2 py-1 rounded bg-blue-500 text-white"
                onClick={app.reload}
              >
                {t("common.retry")}
              </button>
            </div>
          </Show>

          <Show when={!app.loading() && !app.error()}>
            <div class="space-y-2 text-sm">
              <div><span class="opacity-60">domain:</span> {app.config()?.domain}</div>
              <div><span class="opacity-60">backend:</span> {app.config()?.backendLink}</div>
            </div>

            <pre class="mt-3 text-xs bg-black/10 p-3 rounded overflow-auto">
              {JSON.stringify(app.info(), null, 2)}
            </pre>
          </Show>
        </main>
      }>
        <Settings />
      </Show>
      <Toaster />
    </div>
  );
}
</file>

</files>
