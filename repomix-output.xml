This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
assets/
  chain_logos/
    ethereum.svg
    puilsechain-test-v4.svg
    pulsechain.svg
  icons/
    arrow-back.svg
public/
  dev_docs/
    en/
      core-concepts/
        app-init.md
        auth.md
        config-contract.md
        domain.md
        index.md
        publishing-posts.md
        showing-posts.md
      getting-started.md
      index.md
      sidebar.yaml
    fr/
      core-concepts/
        app-init.md
        auth.md
        config-contract.md
        domain.md
        index.md
        publishing-posts.md
        showing-posts.md
      .i18n-docs-state.json
      getting-started.md
      index.md
      sidebar.yaml
    ru/
      core-concepts/
        app-init.md
        auth.md
        config-contract.md
        domain.md
        index.md
        publishing-posts.md
        showing-posts.md
      .i18n-docs-state.json
      getting-started.md
      index.md
      sidebar.yaml
    sr/
      core-concepts/
        app-init.md
        auth.md
        config-contract.md
        domain.md
        index.md
        publishing-posts.md
        showing-posts.md
      .i18n-docs-state.json
      getting-started.md
      index.md
      sidebar.yaml
    ua/
      core-concepts/
        app-init.md
        auth.md
        config-contract.md
        domain.md
        index.md
        publishing-posts.md
        showing-posts.md
      .i18n-docs-state.json
      getting-started.md
      index.md
      sidebar.yaml
  domain_default/
    favicon/
      browserconfig.xml
      safari-pinned-tab.svg
      site.webmanifest
    html/
      info_block_en.html
      info_block_fr.html
      info_block_ru.html
      info_block_ua.html
      info_block.html
    modules/
      categories.yaml
      content_lists.yaml
      staker_levels.yaml
      tabs.yaml
    config.yaml
    domain.css
  default_connect.yaml
scripts/
  i18n-docs.mjs
  i18n.mjs
  release.mjs
src/
  alerts/
    AlertManager.jsx
    handlers.js
    registry.js
  assets/
    solid.svg
  blockchain/
    abi/
      AuthorOfTheMonth.json
      AuthorsClubs.json
      BuyBurn.json
      Config.json
      ContentFund.json
      ContentNFT.json
      ContentRegistry.json
      Fundraiser.json
      Governance.json
      IContentFund.json
      IPulseXFactory.json
      IPulseXRouter.json
      IStaking.json
      IWPLS.json
      ListMarket.json
      NFTAuction.json
      NFTMarketplace.json
      Promo.json
      RandomOracle.json
      SafeERC20.json
      SavvaFaucet.json
      SavvaNPO.json
      SavvaNPOEvents.json
      SavvaNPOFactory.json
      SavvaSwap.json
      SavvaToken.json
      Staking.json
      UserProfile.json
      utils.json
    auth.js
    chainLogos.js
    chains.js
    config.js
    contracts.js
    utils.js
    wallet.js
  components/
    auth/
      AuthorizedUser.jsx
      SwitchAccountModal.jsx
    comments/
      CommentThread.jsx
    docs/
      DocsContent.jsx
      DocsIndex.jsx
      DocsPager.jsx
      MarkdownView.jsx
    editor/
      wizard_steps/
        StepCheckRights.jsx
        StepPublish.jsx
        StepUploadDescriptor.jsx
        StepUploadIPFS.jsx
        StepValidate.jsx
      ChapterManager.jsx
      CommentEditor.jsx
      EditorChapterSelector.jsx
      EditorFilesButton.jsx
      EditorFilesDrawer.jsx
      EditorFullPreview.jsx
      EditorSidebar.jsx
      EditorTocButton.jsx
      EditorToolbar.jsx
      FileContextMenu.jsx
      FileGridItem.jsx
      MarkdownInput.jsx
      PostComments.jsx
      PostSubmissionWizard.jsx
      ToolbarIcons.jsx
      UploadFromUrlModal.jsx
    feed/
      ContentFeed.jsx
      PostCard.jsx
      PostInfo.jsx
      PostListView.jsx
    layout/
      Container.jsx
      RightRail.jsx
      TwoColumn.jsx
    main/
      ConnectionError.jsx
      MainView.jsx
      NewContentBanner.jsx
      NewPostButton.jsx
      TabsBar.jsx
      TokenPrice.jsx
    net/
      WsConnector.jsx
    post/
      ChapterPager.jsx
      ChapterSelector.jsx
      CommentCard.jsx
      PostComments.jsx
      PostControls.jsx
      PostTags.jsx
      ReactionInput.jsx
    profile/
      PostsTab.jsx
      SubscribersTab.jsx
      SubscriptionsTab.jsx
      TagList.jsx
      WalletTab.jsx
    settings/
      Assets.jsx
      DeveloperSection.jsx
      LocalIpfsSection.jsx
      PinningServiceModal.jsx
      PinningServicesSection.jsx
    tabs/
      ActualTab.jsx
      CommentsTab.jsx
      ForYouTab.jsx
      index.js
      LeadersTab.jsx
      NewTab.jsx
      NILRightPanel.jsx
      NILTab.jsx
      RightRailLayout.jsx
      TabPanelScaffold.jsx
    ui/
      icons/
        ActionIcons.jsx
        CopyIcon.jsx
        FishIcons.jsx
        NftBadge.jsx
        ProfileIcons.jsx
        ReactionIcon.jsx
        RefreshIcon.jsx
        SavvaTokenIcon.jsx
        TabIcons.jsx
        UnknownUserIcon.jsx
        VerifiedBadge.jsx
      Address.jsx
      BrandLogo.jsx
      ClosePageButton.jsx
      ConfirmModal.jsx
      ContextMenu.jsx
      IpfsImage.jsx
      LangSelector.jsx
      PostFundBadge.jsx
      PostReactions.jsx
      PostTime.jsx
      Spinner.jsx
      StakerLevelIcon.jsx
      Tabs.jsx
      ThemeToggle.jsx
      TokenValue.jsx
      ToTopButton.jsx
      UserCard.jsx
      ViewModeToggle.jsx
    widgets/
      ContentListBlock.jsx
      HtmlBlock.jsx
    App.jsx
    Header.jsx
    RightPane.jsx
    RightPaneFooter.jsx
    SwitchConnectDialog.jsx
    Toaster.jsx
  context/
    AppContext.jsx
    useAppAuth.js
    useAppConnection.js
    useDomainAssets.js
    useTokenPrices.js
  dev/
    AssetDebugTap.jsx
  docs/
    rehype-media-players.js
    rehype-resolve-draft-urls.js
    rehype-rewrite-links.js
  editor/
    postImporter.js
    preview-utils.js
    storage.js
    text-utils.js
  hooks/
    useConnect.js
    useDeleteAction.js
    useDomainCategories.js
    useLocalIpfs.js
    useTheme.js
  i18n/
    en.js
    fr.js
    ru.js
    sr.js
    static_keys.jsx
    ua.js
    useI18n.js
  ipfs/
    pinning/
      manager.js
      storage.js
    index.js
    utils.js
  net/
    endpoints.js
    index.js
    wsApi.js
    wsBus.js
    WsClient.js
    wsRuntime.js
    wsUrl.js
  pages/
    Docs.jsx
    EditorPage.jsx
    PostPage.jsx
    ProfilePage.jsx
    Settings.jsx
  routing/
    hashRouter.js
    tabRoutes.js
  styles/
    layout.css
    tabs.css
    themed-controls.css
  theme/
    DomainCssLoader.jsx
    FaviconLoader.jsx
    GoogleAnalyticsLoader.jsx
  ui/
    contextMenuBuilder.js
    toast.js
  utils/
    assetLoader.js
    assetsDiagnostics.js
    debug.js
    format.js
    net.js
  index.css
  index.jsx
  version.js
  vite-env.d.js
.gitignore
index.html
package.json
postcss.config.js
README.md
tailwind.config.js
tsconfig.app.json
tsconfig.node.json
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="assets/chain_logos/ethereum.svg">
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 540 879.4">
  <path d="m269.9 325.2-269.9 122.7 269.9 159.6 270-159.6z" opacity=".6"/>
  <path d="m0.1 447.8 269.9 159.6v-607.4z" opacity=".45"/>
  <path d="m270 0v607.4l269.9-159.6z" opacity=".8"/>
  <path d="m0 499 269.9 380.4v-220.9z" opacity=".45"/>
  <path d="m269.9 658.5v220.9l270.1-380.4z" opacity=".8"/>
</svg>
</file>

<file path="assets/chain_logos/puilsechain-test-v4.svg">
<svg width="433" height="402" viewBox="0 0 433 402" xmlns="http://www.w3.org/2000/svg">
  <title>PulseChain Logo · Testnet (monochrome)</title>
  <g fill="#000000" fill-rule="evenodd" transform="translate(-133, -149)">
    <path d="M565.598765,372.951028 C565.598765,375.002407 565.123895,376.952504 564.22332,378.644848 L471.558363,539.145156 C467.628442,545.95198 460.365648,550.145156 452.505805,550.145156 L246.592961,550.145156 C238.733118,550.145156 231.470323,545.95198 227.540402,539.145156 L134.86679,378.629552 C133.968844,376.940022 133.5,374.999302 133.5,372.951028 C133.5,366.307901 138.885318,360.922583 145.528445,360.922583 L247.199342,360.922583 L272.965382,404.687949 L273.123755,404.949452 C276.56213,410.470142 283.796681,412.269462 289.433324,408.951035 L289.725027,408.773687 C292.323961,407.142692 294.205446,404.576775 294.976025,401.597905 L327.807505,274.677705 L355.998349,479.011885 C357.082331,485.72482 363.072426,490.1783 369.557845,489.283548 L369.85245,489.239203 C374.548041,488.473143 378.362876,485.004494 379.559058,480.380352 L419.133013,327.39653 L435.381735,354.996566 C437.735954,358.77701 441.59028,360.922583 445.747249,360.922583 L553.57032,360.922583 C560.213447,360.922583 565.598765,366.307901 565.598765,372.951028 Z M452.505805,149.493649 C460.365648,149.493649 467.628442,153.686825 471.558363,160.493649 L564.229106,321.001259 C565.125282,322.691832 565.598765,324.640838 565.598765,326.687777 C565.598765,333.330904 560.213447,338.716222 553.57032,338.716222 L451.566328,338.716222 L425.800288,294.950856 C423.991945,292.060218 421.426028,290.178734 418.447158,289.408155 L418.167463,289.339295 C411.826545,287.85703 405.429227,291.702682 403.789645,298.040901 L370.95724,424.960175 L342.767321,220.62692 C341.956916,215.636723 338.488267,211.821889 333.864125,210.625707 C327.432698,208.962014 320.870306,212.827026 319.206612,219.258453 L279.631731,372.24135 L263.383935,344.64224 C261.029716,340.861796 257.17539,338.716222 253.018421,338.716222 L145.528445,338.716222 C138.885318,338.716222 133.5,333.330904 133.5,326.687777 C133.5,324.65653 133.956256,322.735416 134.837658,321.056157 L227.540402,160.493649 C231.470323,153.686825 238.733118,149.493649 246.592961,149.493649 L452.505805,149.493649 Z"/>
  </g>
</svg>
</file>

<file path="assets/chain_logos/pulsechain.svg">
<svg width="433px" height="402px" viewBox="0 0 433 402" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>PulseChain Logo Shape</title>
    <defs>
        <linearGradient x1="76.2262818%" y1="7.45934826%" x2="23.6511094%" y2="92.5655852%" id="linearGradient-1">
            <stop stop-color="#00EAFF" offset="0%"></stop>
            <stop stop-color="#0080FF" offset="25.2530882%"></stop>
            <stop stop-color="#8000FF" offset="49.7394282%"></stop>
            <stop stop-color="#E619E6" offset="74.9912298%"></stop>
            <stop stop-color="#FF0000" offset="99.9136118%"></stop>
        </linearGradient>
    </defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Logo" transform="translate(-133.000000, -149.000000)" fill="url(#linearGradient-1)">
            <path d="M565.598765,372.951028 C565.598765,375.002407 565.123895,376.952504 564.22332,378.644848 L471.558363,539.145156 C467.628442,545.95198 460.365648,550.145156 452.505805,550.145156 L246.592961,550.145156 C238.733118,550.145156 231.470323,545.95198 227.540402,539.145156 L134.86679,378.629552 C133.968844,376.940022 133.5,374.999302 133.5,372.951028 C133.5,366.307901 138.885318,360.922583 145.528445,360.922583 L247.199342,360.922583 L272.965382,404.687949 L273.123755,404.949452 C276.56213,410.470142 283.796681,412.269462 289.433324,408.951035 L289.433324,408.951035 L289.725027,408.773687 C292.323961,407.142692 294.205446,404.576775 294.976025,401.597905 L294.976025,401.597905 L327.807505,274.677705 L355.998349,479.011885 L356.041062,479.296747 C357.082331,485.72482 363.072426,490.1783 369.557845,489.283548 L369.557845,489.283548 L369.85245,489.239203 C374.548041,488.473143 378.362876,485.004494 379.559058,480.380352 L379.559058,480.380352 L419.133013,327.39653 L435.381735,354.996566 L435.543066,355.262694 C437.735954,358.77701 441.59028,360.922583 445.747249,360.922583 L445.747249,360.922583 L553.57032,360.922583 L553.57032,360.922583 C560.213447,360.922583 565.598765,366.307901 565.598765,372.951028 Z M452.505805,149.493649 C460.365648,149.493649 467.628442,153.686825 471.558363,160.493649 L564.229106,321.001259 C565.125282,322.691832 565.598765,324.640838 565.598765,326.687777 C565.598765,333.330904 560.213447,338.716222 553.57032,338.716222 L451.566328,338.716222 L425.800288,294.950856 L425.62294,294.659153 C423.991945,292.060218 421.426028,290.178734 418.447158,289.408155 L418.447158,289.408155 L418.167463,289.339295 C411.826545,287.85703 405.429227,291.702682 403.789645,298.040901 L403.789645,298.040901 L370.95724,424.960175 L342.767321,220.62692 L342.722976,220.332314 C341.956916,215.636723 338.488267,211.821889 333.864125,210.625707 C327.432698,208.962014 320.870306,212.827026 319.206612,219.258453 L319.206612,219.258453 L279.631731,372.24135 L263.383935,344.64224 L263.222604,344.376112 C261.029716,340.861796 257.17539,338.716222 253.018421,338.716222 L253.018421,338.716222 L145.528445,338.716222 L145.528445,338.716222 C138.885318,338.716222 133.5,333.330904 133.5,326.687777 C133.5,324.65653 133.956256,322.735416 134.837658,321.056157 L227.540402,160.493649 C231.470323,153.686825 238.733118,149.493649 246.592961,149.493649 L452.505805,149.493649 Z" id="PulseChain-Logo-Shape"></path>
        </g>
    </g>
</svg>
</file>

<file path="assets/icons/arrow-back.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path fill="none" stroke="#000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"/>
  <path fill="none" stroke="#000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M4 12h14"/>
</svg>
</file>

<file path="public/domain_default/favicon/browserconfig.xml">
<?xml version="1.0" encoding="utf-8"?>
<browserconfig>
    <msapplication>
        <tile>
            <square150x150logo src="/mstile-150x150.png"/>
            <TileColor>#da532c</TileColor>
        </tile>
    </msapplication>
</browserconfig>
</file>

<file path="public/domain_default/favicon/safari-pinned-tab.svg">
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"
 "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
 width="700.000000pt" height="700.000000pt" viewBox="0 0 700.000000 700.000000"
 preserveAspectRatio="xMidYMid meet">
<metadata>
Created by potrace 1.14, written by Peter Selinger 2001-2017
</metadata>
<g transform="translate(0.000000,700.000000) scale(0.100000,-0.100000)"
fill="#000000" stroke="none">
<path d="M3249 6996 c-2 -2 -37 -7 -78 -10 -113 -10 -269 -33 -351 -52 -14 -3
-38 -7 -55 -10 -111 -19 -539 -150 -570 -174 -5 -4 -21 -11 -35 -15 -14 -4
-51 -20 -82 -36 -32 -15 -58 -25 -58 -22 0 3 -6 1 -12 -5 -7 -5 -66 -37 -131
-71 -65 -33 -131 -70 -147 -81 -15 -11 -31 -20 -34 -20 -10 0 -242 -156 -311
-209 -194 -148 -421 -364 -561 -532 -93 -112 -220 -286 -281 -385 -202 -327
-327 -612 -424 -969 -24 -89 -24 -88 9 -80 15 4 34 8 42 10 29 6 135 36 155
45 11 4 43 16 70 25 204 71 507 216 947 456 70 38 130 69 133 69 3 0 23 11 44
24 21 14 133 72 247 129 181 90 246 121 409 192 215 94 558 186 785 213 85 9
407 9 490 -1 53 -6 221 -39 317 -62 101 -24 343 -127 463 -197 169 -98 385
-302 493 -464 153 -230 225 -449 233 -709 l4 -130 -23 38 c-109 188 -158 265
-217 342 -63 84 -195 222 -265 277 -193 155 -441 266 -679 304 -21 3 -48 8
-60 11 -11 3 -104 7 -206 9 -214 3 -283 -4 -462 -51 -262 -68 -566 -230 -905
-483 -91 -68 -401 -307 -698 -540 -25 -19 -64 -48 -81 -60 -11 -7 -57 -40
-104 -73 -399 -285 -780 -458 -1218 -555 -22 -4 -23 -8 -18 -52 12 -91 17
-127 22 -157 3 -16 7 -39 8 -50 2 -11 6 -33 10 -50 3 -16 8 -39 10 -51 16 -83
63 -259 97 -364 298 -907 926 -1634 1774 -2057 99 -49 188 -90 215 -98 3 -1
19 -7 35 -14 95 -40 325 -117 405 -136 8 -2 56 -13 105 -25 282 -67 450 -85
790 -85 245 0 414 10 520 29 11 2 38 7 60 11 874 149 1654 616 2196 1315 182
235 359 543 471 820 68 168 167 485 155 497 -15 14 -328 -90 -512 -170 -156
-68 -496 -238 -665 -334 -55 -30 -133 -73 -285 -153 -182 -97 -438 -222 -565
-275 -123 -52 -389 -146 -450 -159 -14 -3 -52 -12 -85 -21 -74 -18 -220 -44
-300 -53 -126 -14 -537 -4 -565 13 -3 2 -26 6 -50 10 -25 3 -53 8 -62 11 -9 3
-25 6 -35 8 -126 25 -348 107 -476 177 -38 22 -71 39 -73 39 -6 0 -134 90
-184 129 -79 62 -234 225 -292 307 -161 229 -241 460 -255 727 -4 86 -3 127 5
127 5 0 15 -12 21 -27 21 -56 119 -215 192 -314 151 -203 324 -354 529 -461
47 -24 87 -44 90 -45 3 0 23 -8 45 -17 69 -29 208 -67 300 -81 117 -19 178
-23 310 -23 209 0 360 26 565 100 195 70 363 163 664 368 45 31 296 222 451
344 258 204 453 348 606 451 256 170 323 207 621 343 111 51 314 113 517 158
22 5 23 8 16 57 -4 29 -9 68 -11 87 -5 39 -5 41 -28 165 -92 493 -320 1013
-626 1423 -481 645 -1161 1103 -1935 1302 -82 21 -170 41 -195 45 -24 4 -47 8
-50 10 -3 1 -27 6 -54 9 -27 4 -52 9 -55 11 -3 1 -37 6 -76 10 -38 3 -83 8
-100 11 -34 6 -590 15 -596 10z m412 -2701 c239 -50 445 -207 562 -427 31 -59
62 -153 78 -236 15 -78 6 -255 -16 -337 -42 -157 -130 -299 -250 -404 -271
-237 -668 -267 -968 -74 -465 298 -508 951 -86 1306 102 86 237 150 366 173
15 3 29 7 31 8 9 10 227 3 283 -9z"/>
</g>
</svg>
</file>

<file path="public/domain_default/favicon/site.webmanifest">
{
    "name": "",
    "short_name": "",
    "icons": [
        {
            "src": "./android-chrome-192x192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "./android-chrome-512x512.png",
            "sizes": "512x512",
            "type": "image/png"
        }
    ],
    "theme_color": "#ffffff",
    "background_color": "#ffffff",
    "display": "standalone"
}
</file>

<file path="public/domain_default/html/info_block_en.html">
<div style="text-align: center;">
    <h1>Welcome to SAVVA, your affinity network</h1>
    <p>No registration is needed—having a PulseChain address is enough.</p>
    <p>Feel free to explore, read, and support the authors you like. If you'd like to post content, just stake 5000 SAVVA tokens.</p>
    <p>Remember, SAVVA is an open platform, which means you can create your own site like this one. It's completely free.</p>
    <p>Let us know if you're interested in running your own site!</p>
  </div>
</file>

<file path="public/domain_default/html/info_block_fr.html">
<div style="text-align: center;">
    <h1>Bienvenue sur la plateforme SAVVA, votre réseau par centres d'intérêt</h1>
    <p>Aucune inscription n'est requise — il suffit d'avoir une adresse PulseChain.</p>
    <p>Sentez-vous libre : explorez, lisez et soutenez les auteurs qui vous plaisent. Si vous souhaitez publier du contenu, il suffit de staker 5000 tokens SAVVA.</p>
    <p>N'oubliez pas que la plateforme SAVVA est ouverte, et que vous pouvez créer votre propre site, comme celui-ci. C'est complètement gratuit.</p>
    <p>Faites-nous savoir si vous êtes intéressé par le lancement de votre propre site !</p>
</div>
</file>

<file path="public/domain_default/html/info_block_ru.html">
<div style="text-align: center;">
    <h1>Добро пожаловать на платформу SAVVA, вашу сеть по интересам</h1>
    <p>Регистрация не требуется — достаточно иметь адрес PulseChain.</p>
    <p>Чувствуйте себя свободно: изучайте, читайте и поддерживайте авторов, которые вам нравятся. Если хотите публиковать контент, достаточно застейкать 5000 токенов SAVVA.</p>
    <p>Помните, что платформа SAVVA открыта, и вы можете создать свой собственный сайт, как этот. Это абсолютно бесплатно.</p>
    <p>Дайте нам знать, если вы заинтересованы в запуске своего сайта!</p>
  </div>
</file>

<file path="public/domain_default/html/info_block_ua.html">
<div style="text-align: center;">
    <h1>Ласкаво просимо на платформу SAVVA, вашу мережу за інтересами</h1>
    <p>Реєстрація не потрібна — достатньо мати адресу PulseChain.</p>
    <p>Почувайтесь вільно: досліджуйте, читайте та підтримуйте авторів, які вам подобаються. Якщо бажаєте публікувати контент, достатньо застейкати 5000 токенів SAVVA.</p>
    <p>Пам’ятайте, що платформа SAVVA відкрита, і ви можете створити власний сайт, як цей. Це абсолютно безкоштовно.</p>
    <p>Дайте нам знати, якщо ви зацікавлені у запуску власного сайту!</p>
</div>
</file>

<file path="public/domain_default/html/info_block.html">
<div>
    Some text about the project.
</div>

<div class="icons-container">
    <a href="https://t.me/savvaapp">
        <svg width="44" height="44" viewBox="0 0 44 44" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M22 43C33.598 43 43 33.598 43 22C43 10.402 33.598 1 22 1C10.402 1 1 10.402 1 22C1 33.598 10.402 43 22 43Z"
                stroke="black" stroke-width="2"></path>
            <path fill-rule="evenodd" clip-rule="evenodd"
                d="M14.9581 19.2048C12.8968 20.1103 10.779 21.0408 8.84231 22.1141C7.83107 22.8591 9.17507 23.3861 10.436 23.8804C10.6365 23.959 10.8348 24.0368 11.0212 24.1144C11.1764 24.1625 11.3342 24.213 11.4941 24.2643C12.8965 24.7138 14.4601 25.2151 15.8216 24.461C18.0581 23.1683 20.1687 21.6738 22.2777 20.1804C22.9686 19.6911 23.6594 19.202 24.3544 18.7201C24.387 18.6991 24.4237 18.6752 24.4639 18.649C25.0559 18.2628 26.3874 17.3944 25.8949 18.5911C24.7303 19.8726 23.4827 21.0071 22.2285 22.1478C21.3831 22.9165 20.5347 23.6881 19.7065 24.5093C18.9852 25.0991 18.2361 26.285 19.0438 27.1108C20.9042 28.4212 22.7936 29.6999 24.682 30.9778C25.2965 31.3936 25.9109 31.8095 26.5241 32.2263C27.5634 33.0612 29.1877 32.3858 29.4162 31.0812C29.5177 30.481 29.6198 29.8809 29.7218 29.2808C30.2856 25.9641 30.8496 22.6461 31.3478 19.3186C31.4155 18.7966 31.4922 18.2747 31.5691 17.7525C31.7552 16.4869 31.9416 15.2197 31.9998 13.9473C31.8498 12.6774 30.3195 12.9567 29.468 13.2422C25.091 14.9181 20.7578 16.7181 16.4416 18.5499C15.9527 18.7678 15.4571 18.9856 14.9581 19.2048Z"
                fill="black"></path>
        </svg>
    </a>
</div>
</file>

<file path="public/domain_default/modules/categories.yaml">
required: false
locales:
  ru:
    - SAVVA Платформа
    - SAVVA Документация
    - Вопросы и ответы
  en:
    - SAVVA Talk
    - SAVVA Documentation
    - Q&A
  fr:
    - Plateforme SAVVA
    - Documentation SAVVA
    - Questions et Réponses
  ua:
    - Платформа SAVVA
    - Документація SAVVA
    - Запитання та Відповіді
</file>

<file path="public/domain_default/modules/content_lists.yaml">
market_contract: ''
list:
  main:
    title:
      ru: 'Анонсы'
      en: 'Announcements'
      ua: 'Анонси'
      fr: 'Annonces'
    on_market: true
  new:
    title:
      ru: 'Новые анонсы'
      en: 'New announces'
      ua: 'Новi анонсы'
      fr: 'new annonces'
    on_market: true
</file>

<file path="public/domain_default/modules/staker_levels.yaml">
staker_levels:
  levels:
  - min: 0
    icon:
    name: 
      - locale: en
        text: "Guest"
      - locale: ru
        text: "Гость"
      - locale: fr
        text: "Invité"
      - locale: ua
        text: "Гість"
      - locale: de
        text: "Gast"
  - min: 5000
    icon: /images/icons8-clam-50.svg
    name: 
      - locale: en
        text: "Clam"
      - locale: ru
        text: "Моллюск"
      - locale: fr
        text: "Palourde"
      - locale: ua
        text: "Молюск"
      - locale: de
        text: "Muschel"
  - min: 10000
    icon: /images/icons8-shrimp-50.svg
    name: 
      - locale: en
        text: "Shrimp"
      - locale: ru
        text: "Креветка"
      - locale: fr
        text: "Crevette"
      - locale: ua
        text: "Креветка"
      - locale: de
        text: "Garnele"
  - min: 20000
    icon: /images/icons8-seahorse-50.svg
    name: 
      - locale: en
        text: "Seahorse"
      - locale: ru
        text: "Морской конек"
      - locale: fr
        text: "Hippocampe"
      - locale: ua
        text: "Морський коник"
      - locale: de
        text: "Seepferdchen"
  - min: 50000
    icon: /images/icons8-top-view-fish-50.svg
    name: 
      - locale: en
        text: "Fish"
      - locale: ru
        text: "Рыба"
      - locale: fr
        text: "Poisson"
      - locale: ua
        text: "Риба"
      - locale: de
        text: "Fisch"
  - min: 100000
    icon: /images/icons8-dolphin-50.svg
    name: 
      - locale: en
        text: "Dolphin"
      - locale: ru
        text: "Дельфин"
      - locale: fr
        text: "Dauphin"
      - locale: ua
        text: "Дельфін"
      - locale: de
        text: "Delfin"
  - min: 200000 
    icon: /images/icons8-shark-50.svg
    name: 
      - locale: en
        text: "Shark"
      - locale: ru
        text: "Акула"
      - locale: fr
        text: "Requin"
      - locale: ua
        text: "Акула"
      - locale: de
        text: "Hai"
  - min: 500000
    icon: /images/icons8-stingray.svg
    name: 
      - locale: en
        text: "Stingray"
      - locale: ru
        text: "Скат"
      - locale: fr
        text: "Raie"
      - locale: ua
        text: "Скат"
      - locale: de
        text: "Stachelrochen"
  - min: 1000000
    icon: /images/icons8-orca-50.svg
    name: 
      - locale: en
        text: "Orca"
      - locale: ru
        text: "Косатка"
      - locale: fr
        text: "Orque"
      - locale: ua
        text: "Косатка"
      - locale: de
        text: "Orca"
  - min: 10000000
    icon: /images/icons8-whale-50.svg
    name: 
      - locale: en
        text: "Whale"
      - locale: ru
        text: "Кит"
      - locale: fr
        text: "Baleine"
      - locale: ua
        text: "Кит"
      - locale: de
        text: "Wal"
</file>

<file path="src/assets/solid.svg">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 166 155.3"><path d="M163 35S110-4 69 5l-3 1c-6 2-11 5-14 9l-2 3-15 26 26 5c11 7 25 10 38 7l46 9 18-30z" fill="#76b3e1"/><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="27.5" y1="3" x2="152" y2="63.5"><stop offset=".1" stop-color="#76b3e1"/><stop offset=".3" stop-color="#dcf2fd"/><stop offset="1" stop-color="#76b3e1"/></linearGradient><path d="M163 35S110-4 69 5l-3 1c-6 2-11 5-14 9l-2 3-15 26 26 5c11 7 25 10 38 7l46 9 18-30z" opacity=".3" fill="url(#a)"/><path d="M52 35l-4 1c-17 5-22 21-13 35 10 13 31 20 48 15l62-21S92 26 52 35z" fill="#518ac8"/><linearGradient id="b" gradientUnits="userSpaceOnUse" x1="95.8" y1="32.6" x2="74" y2="105.2"><stop offset="0" stop-color="#76b3e1"/><stop offset=".5" stop-color="#4377bb"/><stop offset="1" stop-color="#1f3b77"/></linearGradient><path d="M52 35l-4 1c-17 5-22 21-13 35 10 13 31 20 48 15l62-21S92 26 52 35z" opacity=".3" fill="url(#b)"/><linearGradient id="c" gradientUnits="userSpaceOnUse" x1="18.4" y1="64.2" x2="144.3" y2="149.8"><stop offset="0" stop-color="#315aa9"/><stop offset=".5" stop-color="#518ac8"/><stop offset="1" stop-color="#315aa9"/></linearGradient><path d="M134 80a45 45 0 00-48-15L24 85 4 120l112 19 20-36c4-7 3-15-2-23z" fill="url(#c)"/><linearGradient id="d" gradientUnits="userSpaceOnUse" x1="75.2" y1="74.5" x2="24.4" y2="260.8"><stop offset="0" stop-color="#4377bb"/><stop offset=".5" stop-color="#1a336b"/><stop offset="1" stop-color="#1a336b"/></linearGradient><path d="M114 115a45 45 0 00-48-15L4 120s53 40 94 30l3-1c17-5 23-21 13-34z" fill="url(#d)"/></svg>
</file>

<file path="src/blockchain/chainLogos.js">
// src/blockchain/chainLogos.js
export const CHAIN_LOGOS = {
  1: "/assets/chain_logos/ethereum.svg", // Ethereum Mainnet
  943: "/assets/chain_logos/puilsechain-test-v4.svg", // PulseChain Testnet
  369: "/assets/chain_logos/pulsechain.svg", // PulseChain Mainnet
  // Add more as you need
};

export function getChainLogo(chainId) {
  return CHAIN_LOGOS[chainId] || null;
}
</file>

<file path="src/blockchain/wallet.js">
// src/blockchain/wallet.js
import { createSignal } from "solid-js";

const [walletAccount, setWalletAccount] = createSignal(null);
const [walletChainId, setWalletChainId] = createSignal(null);

export function isWalletAvailable() {
  return typeof window !== "undefined" && !!window.ethereum;
}

function hexChainId(n) {
  const id = Number(n);
  if (!Number.isFinite(id)) throw new Error(`Invalid chain id: ${n}`);
  return "0x" + id.toString(16);
}

let listenersReady = false;
function setupListeners() {
  const eth = window.ethereum;
  if (!eth || listenersReady) return;
  eth.on?.("accountsChanged", (accs) => {
    setWalletAccount(accs?.[0] || null);
  });
  eth.on?.("chainChanged", (id) => {
    const n = typeof id === "string" ? parseInt(id, 16) : +id;
    setWalletChainId(Number.isFinite(n) ? n : null);
  });
  listenersReady = true;
}

export async function eagerConnect() {
  const eth = window.ethereum;
  if (!eth) return false;
  setupListeners();
  try {
    const [accounts, chainIdHex] = await Promise.all([
      eth.request({ method: "eth_accounts" }),
      eth.request({ method: "eth_chainId" }).catch(() => null),
    ]);
    if (chainIdHex) {
      const n = parseInt(chainIdHex, 16);
      setWalletChainId(Number.isFinite(n) ? n : null);
    }
    if (accounts && accounts[0]) {
      setWalletAccount(accounts[0]);
      return true;
    }
    setWalletAccount(null);
    return false;
  } catch {
    return false;
  }
}

export async function connectWallet() {
  const eth = window.ethereum;
  if (!eth) throw new Error("No Ethereum wallet found");
  setupListeners();
  const accounts = await eth.request({ method: "eth_requestAccounts" });
  const chainIdHex = await eth.request({ method: "eth_chainId" }).catch(() => null);
  if (chainIdHex) {
    const n = parseInt(chainIdHex, 16);
    setWalletChainId(Number.isFinite(n) ? n : null);
  }
  setWalletAccount(accounts?.[0] || null);
}

/**
 * Switch to a chain; if the wallet doesn't know it, try to add it.
 * meta = {
 *   chainId: number,
 *   name: string,
 *   nativeCurrency: { name, symbol, decimals },
 *   rpcUrls: string[],
 *   blockExplorers?: string[]
 * }
 */
export async function switchOrAddChain(meta) {
  const eth = window.ethereum;
  if (!eth) throw new Error("No Ethereum wallet found");
  if (!meta || !meta.chainId) throw new Error("Missing chain metadata");

  const chainIdHexVal = hexChainId(meta.chainId);
  try {
    await eth.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: chainIdHexVal }],
    });
  } catch (e) {
    // 4902 = Unrecognized chain
    const code = e?.code ?? e?.data?.originalError?.code;
    if (code === 4902) {
      await eth.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: chainIdHexVal,
            chainName: meta.name || `Chain ${meta.chainId}`,
            nativeCurrency: meta.nativeCurrency || { name: "ETH", symbol: "ETH", decimals: 18 },
            rpcUrls: meta.rpcUrls || [],
            blockExplorerUrls: meta.blockExplorers || [],
          },
        ],
      });
    } else {
      throw e;
    }
  }

  // update signal with the (new) chain id
  try {
    const cid = await eth.request({ method: "eth_chainId" });
    if (cid) {
      const n = parseInt(cid, 16);
      setWalletChainId(Number.isFinite(n) ? n : null);
    }
  } catch { /* ignore */ }
}

export { walletAccount, walletChainId };
</file>

<file path="src/components/profile/SubscriptionsTab.jsx">
// src/components/profile/SubscriptionsTab.jsx
import { createSignal, createMemo, For, Show, createEffect, on, onMount, onCleanup } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import UserCard from "../ui/UserCard.jsx";
import Spinner from "../ui/Spinner.jsx";
import TokenValue from "../ui/TokenValue.jsx";

async function fetchSponsees(params) {
  const { app, user_addr, n_weeks, offset, limit } = params;
  if (!app.wsMethod || !user_addr) return { sponsees: [], next_offset: null };
  try {
    const getSponsees = app.wsMethod("get-sponsees");
    const res = await getSponsees({
      domain: "", // Empty domain to get sponsees across all domains
      user_addr,
      n_weeks,
      limit,
      offset,
    });
    return {
      sponsees: Array.isArray(res?.sponsees) ? res.sponsees : [],
      next_offset: res?.next_offset ?? null,
    };
  } catch (e) {
    console.error("Failed to fetch sponsees:", e);
    return { sponsees: [], next_offset: null };
  }
}

export default function SubscriptionsTab(props) {
  const app = useApp();
  const { t } = app;
  const user = () => props.user;

  const [showActiveOnly, setShowActiveOnly] = createSignal(true);
  const nWeeks = createMemo(() => showActiveOnly() ? 1 : 0);
  
  const [sponsees, setSponsees] = createSignal([]);
  const [offset, setOffset] = createSignal(0);
  const [hasMore, setHasMore] = createSignal(true);
  const [loading, setLoading] = createSignal(false);

  const loadMore = async () => {
    if (loading() || !hasMore()) return;
    setLoading(true);
    
    const result = await fetchSponsees({ 
      app, 
      user_addr: user().address, 
      n_weeks: nWeeks(), 
      offset: offset(), 
      limit: 20 
    });
    
    if (result.sponsees.length > 0) {
      setSponsees(prev => [...prev, ...result.sponsees]);
    }
    
    if (result.next_offset) {
      setOffset(result.next_offset);
    } else {
      setHasMore(false);
    }

    setLoading(false);
  };
  
  createEffect(on(nWeeks, () => {
    setSponsees([]);
    setOffset(0);
    setHasMore(true);
    loadMore();
  }));
  
  onMount(() => {
    loadMore(); // Initial load
    const handleScroll = () => {
      const scrollThreshold = 300;
      const nearBottom = window.innerHeight + window.scrollY >= document.documentElement.scrollHeight - scrollThreshold;
      if (nearBottom) {
        loadMore();
      }
    };
    window.addEventListener('scroll', handleScroll, { passive: true });
    onCleanup(() => window.removeEventListener('scroll', handleScroll));
  });

  return (
    <div class="px-2">
      <div class="flex items-center justify-end mb-4">
        <label class="flex items-center gap-2 text-sm cursor-pointer">
          <input 
            type="checkbox" 
            class="rounded"
            checked={showActiveOnly()} 
            onChange={e => setShowActiveOnly(e.currentTarget.checked)} 
          />
          {t("profile.subscribers.showActiveOnly")}
        </label>
      </div>

      <div class="overflow-x-auto">
        <table class="w-full text-sm text-left">
          <thead class="text-xs text-[hsl(var(--muted-foreground))] uppercase bg-[hsl(var(--muted))]">
            <tr>
              <th scope="col" class="px-4 py-2">{t("profile.subscribers.table.user")}</th>
              <th scope="col" class="px-4 py-2">{t("profile.subscribers.table.domain")}</th>
              <th scope="col" class="px-4 py-2 text-center">{t("profile.subscribers.table.weeks")}</th>
              <th scope="col" class="px-4 py-2 text-right">{t("profile.subscribers.table.amount")}</th>
            </tr>
          </thead>
          <tbody>
            <For each={sponsees()}>
              {(sponsee) => (
                <tr class="border-b border-[hsl(var(--border))]">
                  <td class="px-4 py-2 font-medium">
                    <UserCard author={sponsee.user} />
                  </td>
                  <td class="px-4 py-2">{sponsee.domain}</td>
                  <td class="px-4 py-2 text-center">
                    {sponsee.weeks < 1 ? t("profile.subscribers.table.expired") : sponsee.weeks}
                  </td>
                  <td class="px-4 py-2 flex justify-end">
                    <TokenValue amount={sponsee.amount} format="vertical" />
                  </td>
                </tr>
              )}
            </For>
          </tbody>
        </table>
        <Show when={loading()}>
          <div class="flex justify-center p-4"><Spinner /></div>
        </Show>
        <Show when={!loading() && sponsees().length === 0}>
          <p class="text-center text-sm text-[hsl(var(--muted-foreground))] py-8">
            {t("profile.subscribers.noResults")}
          </p>
        </Show>
      </div>
    </div>
  );
}
</file>

<file path="src/components/profile/WalletTab.jsx">
// src/components/profile/WalletTab.jsx
import { useApp } from "../../context/AppContext.jsx";
import TokenValue from "../ui/TokenValue.jsx";
import { createMemo, createResource, Show } from "solid-js";
import { getSavvaContract } from "../../blockchain/contracts.js";
import { createPublicClient, http } from "viem";
import Spinner from "../ui/Spinner.jsx";
import RefreshIcon from "../ui/icons/RefreshIcon.jsx";

async function fetchWalletData({ app, user }) {
  if (!user?.address || !app.desiredChain()) return null;

  try {
    const publicClient = createPublicClient({
      chain: app.desiredChain(),
      transport: http(app.desiredChain().rpcUrls[0]),
    });

    const savvaTokenContract = await getSavvaContract(app, "SavvaToken");
    const contentFundContract = await getSavvaContract(app, "ContentFund");
    const stakingContract = await getSavvaContract(app, "Staking");

    const [
      savvaBalance,
      baseTokenBalance,
      nftEarnings,
      stakedBalance,
      stakingReward
    ] = await Promise.all([
      savvaTokenContract.read.balanceOf([user.address]),
      publicClient.getBalance({ address: user.address }),
      contentFundContract.read.claimableNftGain([user.address]),
      stakingContract.read.balanceOf([user.address]),
      stakingContract.read.claimable([user.address])
    ]);

    return { savvaBalance, baseTokenBalance, nftEarnings, stakedBalance, stakingReward };
  } catch (error) {
    console.error("Failed to fetch wallet data:", error);
    return { error };
  }
}

const WalletSection = (props) => (
  <section class="bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] rounded-lg shadow p-4 space-y-3">
    <div class="flex justify-between items-center">
        <h3 class="text-lg font-medium">{props.title}</h3>
        <Show when={props.headerAction}>
            <div>{props.headerAction}</div>
        </Show>
    </div>
    {props.children}
  </section>
);

const WalletRow = (props) => (
  <div class="py-2 border-t border-[hsl(var(--border))] first:border-t-0 first:pt-0 last:pb-0">
    <div class="flex justify-between items-start">
      <div class="pr-4">
        <h4 class="font-semibold">{props.title}</h4>
        <p class="text-xs text-[hsl(var(--muted-foreground))] mt-1">{props.description}</p>
      </div>
      <div class="flex-shrink-0">
        <TokenValue amount={props.amount || "0"} format="vertical" tokenAddress={props.tokenAddress} />
      </div>
    </div>
  </div>
);

export default function WalletTab(props) {
  const app = useApp();
  const { t } = app;
  const [walletData, { refetch }] = createResource(() => ({ app, user: props.user }), fetchWalletData);

  const desiredChain = createMemo(() => app.desiredChain());
  const baseTokenSymbol = createMemo(() => desiredChain()?.nativeCurrency?.symbol || "PLS");
  
  const RefreshButton = () => (
    <button onClick={refetch} disabled={walletData.loading} class="p-1.5 rounded-full text-[hsl(var(--muted-foreground))] hover:bg-[hsl(var(--accent))] hover:text-[hsl(var(--foreground))] disabled:opacity-50 disabled:cursor-not-allowed">
        <RefreshIcon class="w-5 h-5" />
    </button>
  );
  
  return (
    <div class="px-2 space-y-6">
      <Show when={!walletData.loading} fallback={<div class="flex justify-center p-8"><Spinner /></div>}>
        <Show when={!walletData.error} fallback={<p class="text-sm text-center text-[hsl(var(--destructive))]">{t("common.error")}: {walletData.error.message}</p>}>
            <WalletSection title={t("profile.wallet.balances.title")} headerAction={<RefreshButton />}>
                <WalletRow 
                    title={t("profile.wallet.savva.title")}
                    description={t("profile.wallet.savva.description")}
                    amount={walletData()?.savvaBalance}
                />
                <WalletRow 
                    title={baseTokenSymbol()}
                    description={t("profile.wallet.pls.description")}
                    amount={walletData()?.baseTokenBalance}
                    tokenAddress="0"
                />
            </WalletSection>
          
            <WalletSection title={t("profile.wallet.nft.title")}>
                <WalletRow 
                    title={t("profile.wallet.nftEarnings.title")}
                    description={t("profile.wallet.nftEarnings.description")}
                    amount={walletData()?.nftEarnings}
                />
            </WalletSection>

            <WalletSection title={t("profile.wallet.staking.title")}>
                <WalletRow 
                    title={t("profile.wallet.staked.title")}
                    description={t("profile.wallet.staked.description")}
                    amount={walletData()?.stakedBalance}
                />
                <WalletRow 
                    title={t("profile.wallet.reward.title")}
                    description={t("profile.wallet.reward.description")}
                    amount={walletData()?.stakingReward}
                />
            </WalletSection>
        </Show>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/settings/PinningServiceModal.jsx">
// src/components/settings/PinningServiceModal.jsx
import { createSignal, Show, createEffect, on } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

const PRESETS = {
  pinata: {
    name: "Pinata",
    apiUrl: "https://api.pinata.cloud/pinning/pinFileToIPFS",
    gatewayUrl: "https://gateway.pinata.cloud",
  },
  filebase: {
    name: "Filebase",
    apiUrl: "https://api.filebase.io/v1/ipfs/pins",
    gatewayUrl: "https://ipfs.filebase.io",
  },
  '4everland': {
    name: "4EVERLAND",
    apiUrl: "https://api.4everland.dev/pinning/pins",
    gatewayUrl: "https://4everland.io",
  },
};

export default function PinningServiceModal(props) {
  const { t } = useApp();
  const [name, setName] = createSignal("");
  const [apiUrl, setApiUrl] = createSignal("");
  const [apiKey, setApiKey] = createSignal("");
  const [gatewayUrl, setGatewayUrl] = createSignal("");
  const [preset, setPreset] = createSignal("custom");

  createEffect(on(() => props.service, (service) => {
    if (service) {
      setName(service.name || "");
      setApiUrl(service.apiUrl || "");
      setApiKey(service.apiKey || "");
      setGatewayUrl(service.gatewayUrl || "");
      setPreset("custom");
    } else {
      // Reset to default when adding a new one
      handlePresetChange("pinata");
    }
  }, { defer: true }));

  const handlePresetChange = (key) => {
    setPreset(key);
    const p = PRESETS[key];
    if (p) {
      setName(p.name);
      setApiUrl(p.apiUrl);
      setGatewayUrl(p.gatewayUrl);
      setApiKey("");
    } else {
      setName("");
      setApiUrl("");
      setGatewayUrl("");
      setApiKey("");
    }
  };

  const handleSave = () => {
    props.onSave?.({
      id: props.service?.id,
      name: name().trim(),
      apiUrl: apiUrl().trim(),
      apiKey: apiKey().trim(),
      gatewayUrl: gatewayUrl().trim(),
    });
  };

  const title = () => props.service ? t("settings.pinning.modal.editTitle") : t("settings.pinning.modal.addTitle");

  return (
    <Show when={props.isOpen}>
      <div class="fixed inset-0 z-[60] flex items-center justify-center">
        <div class="absolute inset-0 bg-black/40" onClick={props.onClose} />
        <div class="relative themed-dialog rounded-lg shadow-lg w-full max-w-lg p-4 bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))]">
          <h3 class="text-lg font-semibold mb-4">{title()}</h3>
          <div class="space-y-3">
            <select
              value={preset()}
              onChange={(e) => handlePresetChange(e.currentTarget.value)}
              class="w-full px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
            >
              <option value="custom" disabled>{t("settings.pinning.preset")}</option>
              <option value="pinata">{t("settings.pinning.preset.pinata")}</option>
              <option value="filebase">{t("settings.pinning.preset.filebase")}</option>
              <option value="4everland">{t("settings.pinning.preset.4everland")}</option>
            </select>
            <input type="text" value={name()} onInput={(e) => setName(e.currentTarget.value)} placeholder={t("settings.pinning.modal.name.placeholder")} class="w-full px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]" />
            <input type="text" value={apiUrl()} onInput={(e) => setApiUrl(e.currentTarget.value)} placeholder={t("settings.pinning.modal.apiUrl.placeholder")} class="w-full px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]" />
            <input type="password" value={apiKey()} onInput={(e) => setApiKey(e.currentTarget.value)} placeholder={t("settings.pinning.modal.apiKey.label")} class="w-full px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]" />
            <div>
              <input type="text" value={gatewayUrl()} onInput={(e) => setGatewayUrl(e.currentTarget.value)} placeholder={t("settings.pinning.modal.gatewayUrl.placeholder")} class="w-full px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]" />
              <p class="text-xs text-[hsl(var(--muted-foreground))] mt-1">{t("settings.pinning.modal.gatewayUrl.help")}</p>
            </div>
          </div>
          <div class="flex gap-2 justify-end mt-4">
            <button onClick={props.onClose} class="px-3 py-2 rounded bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))] hover:opacity-90">{t("common.cancel")}</button>
            <button onClick={handleSave} class="px-3 py-2 rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] hover:opacity-90">{t("settings.pinning.modal.save")}</button>
          </div>
        </div>
      </div>
    </Show>
  );
}
</file>

<file path="src/components/settings/PinningServicesSection.jsx">
// src/components/settings/PinningServicesSection.jsx
import { createSignal, For, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { getPinningServices, addPinningService, updatePinningService, deletePinningService, isPinningEnabled, setPinningEnabled } from "../../ipfs/pinning/storage.js";
import { testService } from "../../ipfs/pinning/manager.js";
import { pushToast } from "../../ui/toast.js";
import PinningServiceModal from "./PinningServiceModal.jsx";
import ConfirmModal from "../ui/ConfirmModal.jsx";
import Spinner from "../ui/Spinner.jsx";

const TestStepRow = (props) => {
  const { t } = useApp();
  const statusColor = () => {
    if (props.step.status === 'success') return 'text-emerald-500';
    if (props.step.status === 'error') return 'text-red-500';
    return 'text-[hsl(var(--muted-foreground))]';
  };
  const detailsText = () => {
    const { step, details } = props.step;
    if (typeof details === 'object') {
      return t(`settings.pinning.test.details.${step}_ok`, details);
    }
    return details || t(`settings.pinning.test.status.${props.step.status}`);
  };

  return (
    <div class="grid grid-cols-[2rem_1fr] items-start gap-2">
      <div class="flex justify-center pt-1">
        <Show when={props.step.status === 'pending'}><Spinner class="w-4 h-4" /></Show>
        <Show when={props.step.status === 'success'}><span class="text-emerald-500">✓</span></Show>
        <Show when={props.step.status === 'error'}><span class="text-red-500">✗</span></Show>
      </div>
      <div>
        <p class="font-semibold text-xs">{t(`settings.pinning.test.step.${props.step.step}`)}</p>
        <p class={`text-xs break-all ${statusColor()}`}>{detailsText()}</p>
      </div>
    </div>
  );
};

export default function PinningServicesSection() {
  const { t } = useApp();
  const [services, setServices] = createSignal(getPinningServices());
  const [usePinning, setUsePinning] = createSignal(isPinningEnabled());
  const [isModalOpen, setIsModalOpen] = createSignal(false);
  const [editingService, setEditingService] = createSignal(null);
  const [deletingService, setDeletingService] = createSignal(null);
  const [testingId, setTestingId] = createSignal(null);
  const [testDetails, setTestDetails] = createSignal(null);

  const refreshServices = () => setServices(getPinningServices());

  const handleTogglePinning = (e) => {
    const isEnabled = e.currentTarget.checked;
    setPinningEnabled(isEnabled);
    setUsePinning(isEnabled);
  };

  const handleAdd = () => {
    setEditingService(null);
    setIsModalOpen(true);
  };

  const handleEdit = (service) => {
    setEditingService(service);
    setIsModalOpen(true);
  };

  const handleSave = (service) => {
    if (service.id) {
      updatePinningService(service);
    } else {
      addPinningService(service);
    }
    refreshServices();
    setIsModalOpen(false);
  };

  const handleDelete = (service) => {
    deletePinningService(service.id);
    refreshServices();
  };

  const handleTest = async (service) => {
    setTestingId(service.id);
    setTestDetails({ serviceId: service.id, steps: [], error: null });

    const handleProgress = (progress) => {
      setTestDetails(prev => {
        const steps = [...prev.steps];
        const existingIndex = steps.findIndex(s => s.step === progress.step);
        if (existingIndex > -1) {
          steps[existingIndex] = progress;
        } else {
          steps.push(progress);
        }
        return { ...prev, steps };
      });
      return lastReportedStep;
    };

    try {
      await testService(service, { onProgress: handleProgress });
      pushToast({ type: "success", message: t("settings.pinning.test.success") });
    } catch (e) {
      setTestDetails(prev => ({ ...prev, error: e.message }));
      pushToast({ type: "error", message: t("settings.pinning.test.error") });
    } finally {
      setTestingId(null);
    }
  };

  return (
    <>
      <section class="bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] rounded-lg shadow p-4 space-y-3">
        <div class="flex items-center justify-between">
          <h3 class="text-lg font-medium">{t("settings.pinning.title")}</h3>
          <button onClick={handleAdd} class="px-3 py-1.5 rounded-md border border-[hsl(var(--border))] text-sm hover:bg-[hsl(var(--accent))]">{t("settings.pinning.add")}</button>
        </div>
        <p class="text-sm text-[hsl(var(--muted-foreground))]">{t("settings.pinning.description")}</p>
        
        <div class="pt-2">
          <label class="flex items-center gap-2 cursor-pointer">
            <input 
              type="checkbox"
              class="rounded"
              checked={usePinning()}
              onChange={handleTogglePinning}
            />
            <span class="text-sm font-medium">{t("settings.pinning.enable.label")}</span>
          </label>
          <p class="text-xs text-[hsl(var(--muted-foreground))] mt-1 pl-6">{t("settings.pinning.enable.help")}</p>
        </div>

        <div class="space-y-2">
          <For each={services()}>
            {(service) => (
              <div class="p-2 rounded border border-[hsl(var(--border))]">
                <div class="flex items-center justify-between">
                  <div class="font-semibold text-sm">{service.name}</div>
                  <div class="flex items-center gap-2">
                    <button onClick={() => handleTest(service)} disabled={!!testingId()} class="px-2 py-1 text-xs rounded border border-[hsl(var(--input))] hover:bg-[hsl(var(--accent))] disabled:opacity-50">
                      {testingId() === service.id ? t("settings.pinning.testing") : t("settings.pinning.test")}
                    </button>
                    <button onClick={() => handleEdit(service)} class="px-2 py-1 text-xs">{t("settings.pinning.edit")}</button>
                    <button onClick={() => setDeletingService(service)} class="px-2 py-1 text-xs text-[hsl(var(--destructive))]">{t("settings.pinning.delete")}</button>
                  </div>
                </div>
                <Show when={testDetails()?.serviceId === service.id}>
                  <div class="mt-2 pt-2 border-t border-[hsl(var(--border))] space-y-2">
                    <For each={testDetails().steps}>
                      {(step) => <TestStepRow step={step} />}
                    </For>
                    <Show when={testDetails().error}>
                      <p class="text-xs text-red-500 font-semibold">{t("settings.pinning.test.errorDetails", {details: testDetails().error})}</p>
                    </Show>
                    <button onClick={() => setTestDetails(null)} class="text-xs hover:underline">{t("settings.pinning.test.hide_details")}</button>
                  </div>
                </Show>
              </div>
            )}
          </For>
        </div>
      </section>
      
      <PinningServiceModal 
        isOpen={isModalOpen()}
        service={editingService()}
        onClose={() => setIsModalOpen(false)}
        onSave={handleSave}
      />
      
      <ConfirmModal 
        isOpen={!!deletingService()}
        onClose={() => setDeletingService(null)}
        onConfirm={() => {
          handleDelete(deletingService());
          setDeletingService(null);
        }}
        title={t("settings.pinning.confirmDelete.title")}
        message={t("settings.pinning.confirmDelete.message")}
      />
    </>
  );
}
</file>

<file path="src/components/ui/icons/RefreshIcon.jsx">
// src/components/ui/icons/RefreshIcon.jsx
export default function RefreshIcon(props) {
  return (
    <svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" fill="none" {...props}>
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
        <g id="SVGRepo_iconCarrier">
            <path fill="currentColor" fill-rule="evenodd" d="M7.997 16.99a1 1 0 10.292-1.98C5.89 14.657 4 12.508 4 9.86c0-2.294 1.416-4.21 3.358-4.914L6.367 7.25a1 1 0 101.837.79L9.92 4.053a1 1 0 00-.256-1.143l-3-2.658a1 1 0 10-1.326 1.496L6.78 3.027C3.988 3.986 2 6.702 2 9.86c0 3.603 2.581 6.624 5.997 7.13zm4.006-13.98a1 1 0 00-.292 1.98C14.11 5.343 16 7.492 16 10.14c0 2.294-1.416 4.21-3.358 4.913l.991-2.303a1 1 0 00-1.837-.79l-1.715 3.987a1 1 0 00.256 1.143l3 2.659a1 1 0 001.326-1.497l-1.443-1.279c2.792-.958 4.78-3.675 4.78-6.833 0-3.603-2.581-6.624-5.997-7.13z"></path>
        </g>
    </svg>
  );
}
</file>

<file path="src/components/ui/icons/TabIcons.jsx">
// src/components/ui/icons/TabIcons.jsx
/* src/components/ui/icons/TabIcons.jsx */
export function CrownIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-4 h-4"} aria-hidden="true" fill="none">
      <path d="M4 18h16M5 18l1-9 5 4 5-4 1 9" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
    </svg>
  );
}

export function TrendingUpIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-4 h-4"} aria-hidden="true" fill="none">
      <path d="M3 17l6-6 4 4 8-8" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M15 7h6v6" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" />
    </svg>
  );
}

export function ChatBubbleIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-4 h-4"} aria-hidden="true" fill="none">
      <path d="M5 6h14a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H8l-4 4V8a2 2 0 0 1 2-2z" stroke="currentColor" stroke-width="1.8" stroke-linejoin="round" />
      <path d="M8 11h8M8 14h5" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" />
    </svg>
  );
}

export function SparklesIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-4 h-4"} aria-hidden="true" fill="none">
      <path d="M12 4l1.7 4.2L18 10l-4.3 1.8L12 16l-1.7-4.2L6 10l4.3-1.8L12 4z" stroke="currentColor" stroke-width="1.6" stroke-linejoin="round" />
      <path d="M6 4.5l.8 1.9L9 7.2 7 8 6.2 10 5.4 8 3.5 7.2l2.1-.8L6 4.5z" stroke="currentColor" stroke-width="1.2" stroke-linejoin="round" />
    </svg>
  );
}

export function HeartIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-4 h-4"} aria-hidden="true" fill="none">
      <path d="M12 20s-7-4.3-9-8.5C1.8 8.1 3.7 6 6.2 6c1.9 0 3.4 1 4.8 2.7C12.4 7 13.9 6 15.8 6c2.5 0 4.4 2.1 3.2 5.5C19 15.7 12 20 12 20z" stroke="currentColor" stroke-width="1.8" stroke-linejoin="round" />
    </svg>
  );
}

function normalize(s) {
  return String(s || "").trim().toLowerCase();
}

/**
 * Returns a JSX icon for a known tab type (leaders, actual, comments, new, for-you).
 * Falls back to null.
 */
export function tabIconFor(type) {
  switch (normalize(type)) {
    case "leaders":   return <CrownIcon />;
    case "actual":    return <TrendingUpIcon />;
    case "comments":  return <ChatBubbleIcon />;
    case "new":       return <SparklesIcon />;
    case "for-you":   return <HeartIcon />;
    default:          return null;
  }
}
</file>

<file path="src/components/ui/BrandLogo.jsx">
// src/components/ui/BrandLogo.jsx
import { createMemo, createSignal, onMount, onCleanup, Show, createEffect } from "solid-js";
import { useApp } from "../../context/AppContext";
import { dbg } from "../../utils/debug";
import { navigate } from "../../routing/hashRouter.js";

export default function BrandLogo(props) {
  const app = useApp();
  const { t, domainAssetsConfig, assetUrl } = app;

  // Single source of truth for the domain name (falls back to i18n brand name)
  const domainTitle = createMemo(() => {
    const fromCfg = app.config?.()?.domain?.trim();
    const fallback = t("brand.name");
    return fromCfg || (fallback && !/^\[.+\]$/.test(fallback) ? fallback : "SAVVA");
  });

  // Theme + mobile detection
  const [isDark, setIsDark] = createSignal(false);
  const [isMobile, setIsMobile] = createSignal(false);
  onMount(() => {
    const el = document.documentElement;
    const updateDark = () => setIsDark(el.classList.contains("dark"));
    updateDark();
    const mo = new MutationObserver(updateDark);
    mo.observe(el, { attributes: true, attributeFilter: ["class"] });

    const mql = window.matchMedia("(max-width: 640px)");
    const onMQ = (e) => setIsMobile(!!e.matches);
    onMQ(mql);
    mql.addEventListener ? mql.addEventListener("change", onMQ) : mql.addListener(onMQ);

    onCleanup(() => {
      mo.disconnect();
      mql.removeEventListener ? mql.removeEventListener("change", onMQ) : mql.removeListener(onMQ);
    });
  });

  // logos from active domain assets config
  const logos = createMemo(() => {
    const cfg = domainAssetsConfig?.();
    const raw = cfg?.logos ?? cfg?.logo ?? null;
    if (!raw) return null;
    if (typeof raw === "string") return { default: raw };
    return {
      dark_mobile:  raw.dark_mobile  ?? raw.mobile_dark  ?? null,
      light_mobile: raw.light_mobile ?? raw.mobile_light ?? null,
      mobile:       raw.mobile       ?? null,
      dark:         raw.dark         ?? null,
      light:        raw.light        ?? null,
      default:      raw.default      ?? raw.fallback     ?? null,
    };
  });

  const relPath = createMemo(() => {
    const l = logos();
    if (!l) return "";
    const dark = isDark();
    const mobile = isMobile();
    const order = dark
      ? (mobile ? [l.dark_mobile, l.dark, l.mobile, l.default, l.light] : [l.dark, l.default, l.light, l.mobile])
      : (mobile ? [l.light_mobile, l.light, l.mobile, l.default, l.dark] : [l.light, l.default, l.dark, l.mobile]);
    return order.find(Boolean) || "";
  });

  const src = createMemo(() => (relPath() ? assetUrl(relPath()) : ""));

  // 🔎 Debug: log whenever the chosen logo src changes
  createEffect(() => {
    const s = src();
    if (!s) return;
    dbg.log("logo", "BrandLogo src picked", {
      src: s,
      relPath: relPath(),
      dark: isDark(),
      mobile: isMobile(),
      domain: app.config?.()?.domain,
      activePrefix: app.domainAssetsPrefix?.(),
      source: app.domainAssetsSource?.(),
    });
  });

  const [imgBroken, setImgBroken] = createSignal(false);
  // reset broken flag whenever src changes
  createMemo(() => { src(); setImgBroken(false); });

  const handleLogoClick = (e) => {
    e.preventDefault();
    navigate("/");
  };

  return (
    <a href="/#/" onClick={handleLogoClick} class="cursor-pointer">
      <div class="flex items-center">
        <Show when={src() && !imgBroken()} fallback={
          <span class={props.classTitle || "text-xl font-bold"}>{domainTitle()}</span>
        }>
          <img
            src={src()}
            alt={t("brand.logoAlt", { domain: domainTitle() })}
            class={props.class || "h-8 w-auto"}
            decoding="async"
            loading="eager"
            onError={() => {
              dbg.log("logo", "BrandLogo image failed to load", { src: src(), relPath: relPath() });
              setImgBroken(true);
            }}
          />
        </Show>
      </div>
    </a>
  );
}
</file>

<file path="src/components/ui/ThemeToggle.jsx">
// src/components/ui/ThemeIconToggle.jsx
import { useTheme } from "../../hooks/useTheme";
import { useApp } from "../../context/AppContext.jsx";

function SunIcon(props) {
  return (
    <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" {...props}>
      <path d="M12 4V2M12 22v-2M4.93 4.93L3.51 3.51M20.49 20.49l-1.42-1.42M4 12H2M22 12h-2M4.93 19.07L3.51 20.49M20.49 3.51l-1.42 1.42" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"/>
      <circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="1.8" fill="none"/>
    </svg>
  );
}
function MoonIcon(props) {
  return (
    <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true" {...props}>
      <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" stroke="currentColor" stroke-width="1.8" fill="none" stroke-linejoin="round"/>
    </svg>
  );
}

export default function ThemeIconToggle(props) {
  const [theme, toggleTheme] = useTheme();
  const app = useApp();

  const isDark = () => theme() === "dark";

  return (
    <div class="themed-segment" role="group" aria-label={app.t("rightPane.theme")}>
      <button
        class={`themed-pill themed-pill--icon ${!isDark() ? "is-active" : ""}`}
        aria-pressed={!isDark()}
        aria-label={app.t("ui.mode.light")}
        onClick={() => { if (isDark()) toggleTheme(); }}
        title={app.t("ui.mode.light")}
        type="button"
      >
        <SunIcon />
      </button>
      <button
        class={`themed-pill themed-pill--icon ${isDark() ? "is-active" : ""}`}
        aria-pressed={isDark()}
        aria-label={app.t("ui.mode.dark")}
        onClick={() => { if (!isDark()) toggleTheme(); }}
        title={app.t("ui.mode.dark")}
        type="button"
      >
        <MoonIcon />
      </button>
    </div>
  );
}
</file>

<file path="src/hooks/useTheme.js">
// src/hooks/useTheme.js
import { createSignal, onMount } from "solid-js";

export function useTheme() {
  const [theme, setTheme] = createSignal("light");

  onMount(() => {
    const savedTheme = localStorage.getItem("theme") || "light";
    setTheme(savedTheme);
    document.documentElement.classList.toggle("dark", savedTheme === "dark");
  });

  const toggleTheme = () => {
    const next = theme() === "dark" ? "light" : "dark";
    setTheme(next);
    document.documentElement.classList.toggle("dark", next === "dark");
    try { localStorage.setItem("theme", next); } catch {}
  };

  // Expose theme signal for external use
  useTheme.theme = theme;

  return [theme, toggleTheme];
}
</file>

<file path="src/ipfs/pinning/manager.js">
// src/ipfs/pinning/manager.js
import { fetchWithTimeout } from "../../utils/net";

function cleanUrl(url) {
  return (url || "").trim().replace(/\/+$/, "");
}

/**
 * Pins a directory of files to a single pinning service.
 */
export async function pinDirectory(serviceConfig, files, options = {}) {
  const { onProgress } = options;
  const formData = new FormData();

  for (const { file, path } of files) {
    formData.append('file', file, path);
  }

  if (serviceConfig.apiUrl.includes('pinata')) {
    const pinataMetadata = JSON.stringify({ name: `savva-post-${Date.now()}` });
    formData.append('pinataMetadata', pinataMetadata);
  }

  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('POST', serviceConfig.apiUrl, true);
    xhr.setRequestHeader('Authorization', `Bearer ${serviceConfig.apiKey}`);

    xhr.upload.onprogress = (event) => {
      if (event.lengthComputable) {
        onProgress?.(Math.round((event.loaded / event.total) * 100));
      }
    };

    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        try {
          const res = JSON.parse(xhr.responseText);
          const cid = res?.IpfsHash;
          if (!cid) throw new Error("API response did not include an IpfsHash.");
          resolve(cid);
        } catch (e) { reject(e); }
      } else {
        reject(new Error(`API responded with status ${xhr.status}: ${xhr.responseText}`));
      }
    };

    xhr.onerror = () => reject(new Error("Network error during upload."));
    xhr.ontimeout = () => reject(new Error("The upload request timed out."));
    xhr.send(formData);
  });
}

/**
 * Tests a pinning service by uploading a single file, verifying it, and reporting progress.
 */
export async function testService(serviceConfig, options = {}) {
  const { onProgress } = options;
  let lastReportedStep = null; // Hoisted to the function scope
  const report = (step, status, details = "") => {
    lastReportedStep = { step, status, details };
    onProgress?.(lastReportedStep);
  };
  
  try {
    // 1. Create a unique file object
    report('create_file', 'pending');
    const testContent = `SAVVA Pin Test @ ${new Date().toISOString()}`;
    const testFile = new File([testContent], 'savva-test.txt', { type: 'text/plain' });
    report('create_file', 'success', { bytes: testFile.size });

    // 2. Pin the file via API
    report('pinning', 'pending', serviceConfig.apiUrl);
    const formData = new FormData();
    formData.append('file', testFile);
    if (serviceConfig.apiUrl.includes('pinata')) {
      formData.append('pinataOptions', JSON.stringify({ wrapWithDirectory: false }));
    }

    const res = await fetchWithTimeout(serviceConfig.apiUrl, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${serviceConfig.apiKey}` },
      body: formData,
      timeoutMs: 20000,
    });
    if (!res.ok) {
        const errorBody = await res.text();
        throw new Error(`API responded with status ${res.status}: ${errorBody}`);
    }
    const pinResponse = await res.json();
    report('pinning', 'success', { status: res.status });

    // 3. Get the CID from the response
    report('get_cid', 'pending');
    const cid = pinResponse?.IpfsHash;
    if (!cid) throw new Error("API response did not include an IpfsHash.");
    report('get_cid', 'success', { cid });

    // 4. Verify availability on the gateway
    const gateway = cleanUrl(serviceConfig.gatewayUrl);
    const verifyUrl = `${gateway}/ipfs/${cid}`;
    report('verify', 'pending', verifyUrl);
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    const verifyRes = await fetchWithTimeout(verifyUrl, { timeoutMs: 30000 });
    if (!verifyRes.ok) throw new Error(`Gateway responded with status ${verifyRes.status}`);
    const fetchedText = await verifyRes.text();
    if (fetchedText.trim() !== testContent.trim()) {
      throw new Error("Gateway returned incorrect data.");
    }
    report('verify', 'success');
    
    return { success: true };

  } catch (e) {
    if (lastReportedStep) {
      report(lastReportedStep.step, 'error', e.message);
    }
    throw new Error(`Test failed at step '${lastReportedStep?.step || 'unknown'}': ${e.message}`);
  }
}
</file>

<file path="src/ipfs/pinning/storage.js">
// src/ipfs/pinning/storage.js
import { dbg } from "../../utils/debug";

const STORAGE_KEY = "ipfs_pinning_services";
const PINNING_ENABLED_KEY = "ipfs_pinning_enabled";

export function getPinningServices() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) {
    dbg.error("PinningStorage", "Failed to load services", e);
    return [];
  }
}

export function savePinningServices(services) {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(services));
  } catch (e) {
    dbg.error("PinningStorage", "Failed to save services", e);
  }
}

export function addPinningService(service) {
  const services = getPinningServices();
  const newService = { ...service, id: crypto.randomUUID() };
  savePinningServices([...services, newService]);
  return newService;
}

export function updatePinningService(updatedService) {
  const services = getPinningServices();
  const newServices = services.map(s => s.id === updatedService.id ? updatedService : s);
  savePinningServices(newServices);
}

export function deletePinningService(serviceId) {
  const services = getPinningServices();
  const newServices = services.filter(s => s.id !== serviceId);
  savePinningServices(newServices);
}

export function isPinningEnabled() {
  try {
    return localStorage.getItem(PINNING_ENABLED_KEY) === "1";
  } catch {
    return false;
  }
}

export function setPinningEnabled(isEnabled) {
  try {
    localStorage.setItem(PINNING_ENABLED_KEY, isEnabled ? "1" : "0");
  } catch (e) {
    dbg.error("PinningStorage", "Failed to set pinning enabled state", e);
  }
}
</file>

<file path="src/theme/DomainCssLoader.jsx">
// src/theme/DomainCssLoader.jsx
import { createEffect, onCleanup, createMemo } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import { dbg } from "../utils/debug";

const LINK_ID = "savva-domain-css";

export default function DomainCssLoader() {
  const app = useApp();

  function ensureLink() {
    let el = document.getElementById(LINK_ID);
    if (!el) {
      el = document.createElement("link");
      el.id = LINK_ID;
      el.rel = "stylesheet";
      el.media = "all";
      (document.head || document.getElementsByTagName("head")[0]).appendChild(el);
    }
    return el;
  }

  // Flip when env/domain/pack changes; used only for cache busting
  const rev = createMemo(() => {
    const cfg = app.domainAssetsConfig?.();
    const cid = cfg?.assets_cid || cfg?.cid || "";
    const env = app.assetsEnv?.() || "prod";
    const dom = (() => {
      const d = app.selectedDomain?.();
      return typeof d === "string" ? d : d?.name || "";
    })();
    return `${env}|${dom}|${cid}`;
  });

  createEffect(() => {
    const hrefBase = app.assetUrl?.("domain.css"); // <- single source of truth
    const el = ensureLink();

    if (!hrefBase) {
      el.parentNode && el.parentNode.removeChild(el);
      return;
    }

    const href = `${hrefBase}${hrefBase.includes("?") ? "&" : "?"}rev=${encodeURIComponent(rev())}`;
    if (el.getAttribute("href") === href) return;

    dbg.log("assets", "DomainCssLoader: applying domain.css", { hrefBase, href });

    const onLoad = () => dbg.log("assets", "domain.css loaded", { href });
    const onError = () => dbg.warn("assets", "domain.css failed to load", { href });

    el.addEventListener("load", onLoad, { once: true });
    el.addEventListener("error", onError, { once: true });
    el.setAttribute("href", href);
  });

  onCleanup(() => {
    const el = document.getElementById(LINK_ID);
    if (el?.parentNode) el.parentNode.removeChild(el);
  });

  return null;
}
</file>

<file path="src/theme/FaviconLoader.jsx">
// src/theme/FaviconLoader.jsx
import { createEffect, onCleanup } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import { dbg } from "../utils/debug";

const ID = {
  apple:   "savva-fav-apple",
  icon16:  "savva-fav-16",
  icon32:  "savva-fav-32",
  base:    "savva-fav-base",
  manifest:"savva-fav-manifest",
  mask:    "savva-fav-mask",
};

function ensureHeadEl(tag, id) {
  let el = document.getElementById(id);
  if (!el) {
    el = document.createElement(tag);
    el.id = id;
    el.setAttribute("data-savva", "1");
    (document.head || document.getElementsByTagName("head")[0]).appendChild(el);
  }
  return el;
}
function removeEl(id) {
  const el = document.getElementById(id);
  if (el?.parentNode) el.parentNode.removeChild(el);
}

function setOrRemoveLink(id, rel, href, attrs = {}) {
  if (!href) return removeEl(id);
  const el = ensureHeadEl("link", id);
  el.setAttribute("rel", rel);
  el.setAttribute("href", href);
  // clean attrs we may set
  ["sizes", "type", "color", "crossorigin"].forEach((a) => el.removeAttribute(a));
  Object.entries(attrs).forEach(([k, v]) => v != null && el.setAttribute(k, v));
}

function slugMetaId(name) {
  return "savva-meta-" + String(name || "").toLowerCase().replace(/[^a-z0-9_-]+/g, "-");
}
function setOrRemoveMeta(name, content) {
  const id = slugMetaId(name);
  if (!content) return removeEl(id);
  const el = ensureHeadEl("meta", id);
  el.setAttribute("name", name);
  el.setAttribute("content", content);
}

export default function FaviconLoader() {
  const app = useApp();

  createEffect(() => {
    const prefix = app.domainAssetsPrefix?.() || "";
    const cfg    = app.domainAssetsConfig?.();
    const fav    = cfg?.favicon || null;
    const revKey = `${prefix}|${cfg?.assets_cid || cfg?.cid || ""}`;

    const withRev = (relPath) => {
      if (!relPath) return "";
      const abs = app.assetUrl?.(relPath);
      if (!abs) return "";
      return `${abs}${abs.includes("?") ? "&" : "?"}rev=${encodeURIComponent(revKey)}`;
    };

    // Resolve all hrefs up front
    const hrefs = {
      apple:    fav?.["apple-touch-icon"] ? withRev(fav["apple-touch-icon"]) : "",
      icon16:   fav?.["16"] ? withRev(fav["16"]) : "",
      icon32:   fav?.["32"] ? withRev(fav["32"]) : "",
      base:     fav?.base ? withRev(fav.base) : "",
      manifest: fav?.manifest ? withRev(fav.manifest) : "",
      mask:     fav?.["mask-icon"]?.href ? withRev(fav["mask-icon"].href) : "",
    };

    dbg.log("assets", "FaviconLoader → apply", {
      prefix, revKey,
      hasFavConfig: !!fav,
      hrefs,
    });

    // Links
    setOrRemoveLink(ID.apple, "apple-touch-icon", hrefs.apple);
    setOrRemoveLink(ID.icon16, "icon", hrefs.icon16, { sizes: "16x16", type: "image/png" });
    setOrRemoveLink(ID.icon32, "icon", hrefs.icon32, { sizes: "32x32", type: "image/png" });
    setOrRemoveLink(ID.base,   "icon", hrefs.base,   { type: "image/x-icon" });
    setOrRemoveLink(ID.manifest, "manifest", hrefs.manifest);
    setOrRemoveLink(ID.mask, "mask-icon", hrefs.mask, { color: fav?.["mask-icon"]?.color || undefined });

    // Meta (generic list; we only manage our own <meta> with data-savva/id)
    const metaList = Array.isArray(fav?.meta) ? fav.meta : [];
    const keepIds = new Set();
    metaList.forEach((m) => {
      if (m && m.name && m.content != null) {
        setOrRemoveMeta(m.name, String(m.content));
        keepIds.add(slugMetaId(m.name));
      }
    });
    // Remove any previous managed meta not present anymore
    const prevManaged = Array.from(document.querySelectorAll('meta[id^="savva-meta-"][data-savva="1"]'));
    prevManaged.forEach((el) => { if (!keepIds.has(el.id)) el.parentNode?.removeChild(el); });

    // If there’s no favicon section at all, drop our managed nodes and keep index.html default
    if (!fav) {
      Object.values(ID).forEach(removeEl);
      prevManaged.forEach((el) => el.parentNode?.removeChild(el));
    }
  });

  onCleanup(() => {
    // Remove the nodes we manage (so a different shell can take over if unmounted)
    Object.values(ID).forEach(removeEl);
    const prevManaged = Array.from(document.querySelectorAll('meta[id^="savva-meta-"][data-savva="1"]'));
    prevManaged.forEach((el) => el.parentNode?.removeChild(el));
  });

  return null;
}
</file>

<file path="src/theme/GoogleAnalyticsLoader.jsx">
// src/theme/GoogleAnalyticsLoader.jsx
import { createEffect, onCleanup } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import { dbg } from "../utils/debug";

const SRC_ID  = "savva-ga-src";
const INIT_ID = "savva-ga-init";

function removeNode(id) {
  const el = document.getElementById(id);
  if (el && el.parentNode) el.parentNode.removeChild(el);
}

export default function GoogleAnalyticsLoader() {
  const app = useApp();

  createEffect(() => {
    const cfg = app.domainAssetsConfig?.(); // parsed per-domain config.yaml
    const tag = String(cfg?.GA_tag || cfg?.ga_tag || "").trim();

    const prevSrc  = document.getElementById(SRC_ID);
    const prevInit = document.getElementById(INIT_ID);

    // If tag is empty → remove our scripts (if any) and stop.
    if (!tag) {
      if (prevSrc || prevInit) {
        removeNode(SRC_ID);
        removeNode(INIT_ID);
        dbg.log("analytics", "GA disabled (no tag in config)");
      }
      return;
    }

    // If already loaded for the same tag → nothing to do.
    if (prevSrc?.getAttribute("data-ga-id") === tag && prevInit?.getAttribute("data-ga-id") === tag) {
      return;
    }

    // Replace previous GA scripts if tag changed.
    removeNode(SRC_ID);
    removeNode(INIT_ID);

    // Load gtag.js
    const s1 = document.createElement("script");
    s1.id = SRC_ID;
    s1.async = true;
    s1.src = `https://www.googletagmanager.com/gtag/js?id=${encodeURIComponent(tag)}`;
    s1.setAttribute("data-ga-id", tag);
    (document.head || document.documentElement).appendChild(s1);

    // Init + first config
    const s2 = document.createElement("script");
    s2.id = INIT_ID;
    s2.setAttribute("data-ga-id", tag);
    s2.text =
      `window.dataLayer = window.dataLayer || [];` +
      `function gtag(){dataLayer.push(arguments);} ` +
      `gtag('js', new Date()); ` +
      `gtag('config', '${tag}', { 'anonymize_ip': true });`;
    (document.head || document.documentElement).appendChild(s2);

    // Simple SPA page_view on hash route changes
    const onHash = () => {
      try {
        window.gtag && window.gtag('config', tag, { page_path: location.pathname + location.hash });
      } catch {}
    };
    window.addEventListener("hashchange", onHash);

    dbg.log("analytics", "GA enabled", { tag });

    // Clean the event handler when the effect re-runs
    onCleanup(() => {
      window.removeEventListener("hashchange", onHash);
    });
  });

  // Remove our scripts if component unmounts
  onCleanup(() => {
    removeNode(SRC_ID);
    removeNode(INIT_ID);
  });

  return null;
}
</file>

<file path="src/utils/assetLoader.js">
// src/utils/assetLoader.js
import { parse } from "yaml";
import { fetchWithTimeout } from "./net";

/**
 * Load a resource from the active domain assets (or domain_default fallback).
 * @param {object} app useApp() context
 * @param {string} relPath relative path inside the asset pack (e.g. "tabs.yaml")
 * @param {object} opts { type: "yaml"|"json"|"text", timeoutMs?: number }
 */
export async function loadAssetResource(app, relPath, opts = {}) {
  const url = app.assetUrl(relPath);
  const timeoutMs = opts.timeoutMs || 8000;
  const res = await fetchWithTimeout(url, { timeoutMs });

  if (!res.ok) {
    throw new Error(`Asset fetch failed: ${url} (${res.status})`);
  }

  const text = await res.text();

  switch (opts.type) {
    case "yaml":
      return parse(text) || null;
    case "json":
      return JSON.parse(text);
    case "text":
    default:
      return text;
  }
}
</file>

<file path="src/vite-env.d.js">
/// <reference types="vite/client" />
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local
.env

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="postcss.config.js">
// postcss.config.js
export default {
  plugins: {
    '@tailwindcss/postcss': { config: './tailwind.config.js' },
    autoprefixer: {},
  },
};
</file>

<file path="README.md">
## Usage

```bash
$ npm install # or pnpm install or yarn install
```

### Learn more on the [Solid Website](https://solidjs.com) and come chat with us on our [Discord](https://discord.com/invite/solidjs)

## Available Scripts

In the project directory, you can run:

### `npm run dev`

Runs the app in the development mode.<br>
Open [http://localhost:5173](http://localhost:5173) to view it in the browser.

### `npm run build`

Builds the app for production to the `dist` folder.<br>
It correctly bundles Solid in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br>
Your app is ready to be deployed!

## Deployment

Learn more about deploying your application with the [documentations](https://vite.dev/guide/static-deploy.html)
</file>

<file path="tailwind.config.js">
// tailwind.config.js
export default {
  darkMode: "class",
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: { extend: {} },
  plugins: [],
};
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.js"]
}
</file>

<file path="vite.config.js">
// vite.config.js
import { defineConfig } from 'vite';
import solid from 'vite-plugin-solid';

export default defineConfig({
  plugins: [solid()],
  server: {
    port: 5173,
  },
  build: {
    target: 'esnext',
  },
});
</file>

<file path="public/dev_docs/en/core-concepts/app-init.md">
# App initialization & backend connect

## What is the SAVVA backend (SAVVA node)?
A SAVVA backend is a server component that **indexes/caches data sourced from blockchain activity** and exposes fast, UI‑friendly APIs & WebSocket methods. A single backend can serve **multiple SAVVA domains**—think of a “domain” as a distinct SAVVA social network (branding, tabs, assets, defaults), all backed by one node.

## What the app needs at boot
On startup the web app needs two inputs:

1. **Backend URL** – the base URL of the SAVVA backend.
2. **Domain name** – which SAVVA domain (social network) to render by default.

Defaults come from a tiny YAML file at the web root:

### `/default_connect.yaml`
```yaml
# /default_connect.yaml
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
# optional:
# default_ipfs_link: ipfs://bafy.../something.json
````

* `backendLink` — base HTTP endpoint of the SAVVA backend (the app normalizes it).
* `domain` — initial domain to render; can be switched later in the UI.
* `gear` — enables developer gear in the UI (optional).
* `default_ipfs_link` — optional convenience default used in some flows.

> **Production note**
> In production this file is usually served by your HTTP server (e.g., Nginx) and effectively **chooses which domain** a deployed web app shows by default. One common pattern is to serve a specific file from disk:
>
> ```nginx
> # example: serve a static default_connect.yaml
> location = /default_connect.yaml {
>   default_type text/yaml;
>   alias /etc/savva/default_connect.yaml;
> }
> ```
>
> Adjust to your infra; the key is that the app can `GET /default_connect.yaml`.

---

## Boot sequence

1. **Load `/default_connect.yaml`**
   The app fetches the YAML file, validates `backendLink`, and stores `domain`. It immediately **configures endpoints** (HTTP base + WS URL) using those values. &#x20;

2. **Configure endpoints**

   * `httpBase` is a normalized version of `backendLink` (guaranteed trailing slash).
   * `ws` URL is derived from the same base, pointing to `.../ws` (protocol switched to `ws:` or `wss:`) and includes `?domain=...` in the query.
     This keeps **one source of truth** for both HTTP and WS.&#x20;

3. **Fetch `/info`**
   With endpoints set, the app calls `GET <httpBase>info` and stores the JSON. From that moment, **/info drives runtime behavior** (domains, chain, IPFS, assets).&#x20;

4. **Derive runtime state from `/info`**
   The following fields are used (see sample below):

   * **`domains`** → Available domain list. The UI prefers the explicit `domain` from the YAML/override; if it’s not present in `/info`, it still uses it.&#x20;
   * **`blockchain_id`** → Target EVM chain ID. The wallet helper can switch/add this network.&#x20;
   * **`ipfs_gateways`** → Remote IPFS gateways to try in order (unless a local IPFS override is enabled).&#x20;
   * **`assets_url`** and **`temp_assets_url`** → The **assets base** (prod vs test). The app computes the **active domain assets prefix** as
     `(<assets base> + <domain> + "/")` with a **fallback** to `/domain_default/` if the remote `config.yaml` is missing. &#x20;

5. **Load domain assets & config**
   The app tries `(<active prefix>/config.yaml)` with a short timeout; on failure it falls back to the default pack at `/domain_default/config.yaml`. The resulting parsed config (logos, tabs, locales, etc.) is stored and the UI renders accordingly.&#x20;

6. **WebSocket runtime**
   The WS client uses the computed `ws` URL from endpoints; when backend/domain changes, endpoints recalculate and the WS layer picks it up.&#x20;

---

## Sample `/info` (illustrative)

```json
{
  "domains": [
    "savva.app",
    {"name": "art.savva"},
    "dev.savva"
  ],
  "blockchain_id": 369,
  "ipfs_gateways": [
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/"
  ],
  "assets_url": "https://cdn.savva.network/assets/",
  "temp_assets_url": "https://cdn.savva.network/assets-test/"
}
```

### Field-by-field (what the app does with it)

* **domains** — list of selectable domains. The **Switch backend / domain** dialog populates from `/info`, but the configured domain still takes precedence if `/info` is behind. &#x20;
* **blockchain\_id** — numeric EVM chain ID; used to build `switch/add chain` metadata and to ensure the wallet is on the **required network**. &#x20;
* **ipfs\_gateways** — ordered list of remote gateways; combined with an optional **Local IPFS** override (when enabled in settings) to form the **active** gateway order.&#x20;
* **assets\_url / temp\_assets\_url** — the app maintains an **assets env** (`prod`/`test`) and picks the matching base. It then computes `/<base>/<domain>/` and loads `config.yaml`. If the remote pack is missing or slow, it uses the **default** `/domain_default/`.&#x20;

---

## Where this lives in the code (for quick reference)

* Boot & `/default_connect.yaml` load, then `/info`: **`src/context/AppContext.jsx`** and **`src/hooks/useConnect.js`**. &#x20;
* Endpoint source of truth (HTTP base + WS URL): **`src/net/endpoints.js`**.&#x20;
* Domain list resolution, chain ID, IPFS gateways, assets env & domain assets loading: **`src/context/AppContext.jsx`**.  &#x20;
* Switch dialog that fetches `/info` and normalizes `domains`: **`src/components/SwitchConnectDialog.jsx`**.&#x20;

---

**Next:** in the following chapter we’ll break down **domain configuration** (`config.yaml`) and how it controls logos, tabs, locales, and other per‑domain UI behaviors.
</file>

<file path="public/dev_docs/en/core-concepts/auth.md">
# Web3 Authorization Flow

The SAVVA platform uses a passwordless Web3 authentication method. Users can "log in" using any EVM-compatible wallet by simply signing a unique, server-provided message. This process verifies ownership of the address and establishes a secure session managed by a browser cookie.

## Overview of the Flow

The authorization process involves a sequence of steps orchestrated between the frontend, the user's wallet, the blockchain, and the SAVVA backend.

1.  **Prepare a Unique Message**: The frontend constructs a unique message for the user to sign. This message is composed of two parts: a dynamic value from a smart contract and a static value from the backend.
2.  **User Signs the Message**: The user is prompted by their wallet (e.g., MetaMask) to sign the prepared message.
3.  **Backend Authentication**: The frontend sends the user's address and the resulting signature to the backend's `/auth` endpoint.
4.  **Session Cookie**: If the signature is valid, the backend responds with a `Set-Cookie` header, establishing an authenticated session.
5.  **Authenticated Requests**: All subsequent API and WebSocket requests from the browser will now automatically include this cookie, identifying the user.
6.  **Fetch User Profile**: Once authenticated, the frontend makes a WebSocket call to `/get-user` to fetch the user's full profile details, such as their avatar and name.

---

## Step-by-Step Implementation

### 1. Preparing the Message to Sign

To prevent replay attacks and ensure each login request is unique, the message to be signed is constructed from two sources:

-   A dynamic **`auth_modifier`** string read from the `UserProfile` smart contract.
-   A static **`auth_text_to_sign`** string provided by the backend's `/info` endpoint.

The frontend first calls the `getString` function on the `UserProfile` contract:

```javascript
// From: src/blockchain/auth.js

// Get the UserProfile contract instance
const userProfileContract = await getSavvaContract(app, 'UserProfile');

// Prepare arguments for the contract call
const domainHex = toHexBytes32(""); // Domain is empty for the global modifier
const keyHex = toHexBytes32("auth_modifier");

// Fetch the modifier (returns a bytes32 hex string)
const modifierHex = await userProfileContract.read.getString([
  account,      // User's address
  domainHex,    // bytes32 representation of ""
  keyHex        // bytes32 representation of "auth_modifier"
]);

// Convert the hex value to a readable string
const modifierString = hexToString(modifierHex, { size: 32 });
````

It then combines this `modifierString` with the text from `/info`:

```javascript
// Get text from the already-loaded /info response
const textToSign = app.info().auth_text_to_sign;

// Combine in the required order
const messageToSign = textToSign + modifierString;
```

### 2\. Signing with the Wallet

Using `viem`, the frontend requests the user's signature for the combined message. This action opens a prompt in the user's wallet.

```javascript
// From: src/blockchain/auth.js

const walletClient = createWalletClient({
  chain: app.desiredChain(),
  transport: custom(window.ethereum)
});

const signature = await walletClient.signMessage({
  account,
  message: messageToSign,
});
```

The resulting `signature` is a long hex string (e.g., `0x...`).

### 3\. Authenticating with the Backend

The frontend then makes a `GET` request to the `/auth` endpoint, sending the user's address, domain, and the new signature as query parameters.

**Crucially**, the `fetch` request must include the **`credentials: 'include'`** option. This tells the browser to process the `Set-Cookie` header in the response, which is essential for establishing the session.

```javascript
// From: src/blockchain/auth.js

const authUrl = new URL(`${httpBase()}auth`);
authUrl.searchParams.set('user_addr', checksummedAccount);
authUrl.searchParams.set('domain', currentDomain);
authUrl.searchParams.set('signature', signature);

const authRes = await fetch(authUrl.toString(), { credentials: 'include' });
```

If successful, the backend's response will include a header similar to this:

```
Set-Cookie: auth=...; Path=/; HttpOnly; Secure; SameSite=Lax
```

### 4\. Making Authenticated API Calls

With the cookie now set in the browser, subsequent API calls (like checking for admin privileges) must also include **`credentials: 'include'`** to ensure the cookie is sent with the request.

```javascript
// From: src/blockchain/auth.js

const isAdminUrl = new URL(`${httpBase()}is-admin`);
isAdminUrl.searchParams.set('address', checksummedAccount);
isAdminUrl.searchParams.set('domain', currentDomain);

const adminRes = await fetch(isAdminUrl.toString(), { credentials: 'include' });
const isAdminData = await adminRes.json(); // e.g., {"result":"ok","admin":true}
const isAdmin = !!isAdminData?.admin;
```

### 5\. Fetching the User Profile (via WebSocket)

The browser automatically sends the auth cookie during the WebSocket connection upgrade. After a successful login, the application's `login` function makes a `wsCall` to the `get-user` method to retrieve the full user profile.

```javascript
// From: src/context/useAppAuth.js (in the login function)

const userProfile = await getWsApi().call('get-user', {
  domain: coreUserData.domain,
  user_addr: checksummedAccount,
});
```

An example response from `/get-user` might look like this:

```json
{
  "name": "alexna",
  "avatar": "QmbXwxPzs2veVYFbm7yybfK3rBMxEebuhAcWh3tuKdDTbq?filename=.png",
  "staked": 42529097734827650000000000,
  "n_followers": 9,
  "banned": false
}
```

-----

## Storing the Session

The final user object, which is a combination of the core data (`address`, `domain`, `isAdmin`) and the profile fetched from `/get-user`, is stored in the global `AppContext` and persisted to `localStorage`. This allows the session to be restored automatically when the user revisits the app.

## The Logout Process

The logout process reverses these steps:

1.  A `POST` request is sent to the `/logout` API endpoint to invalidate the server-side session and clear the cookie.
2.  The user's data is removed from the global state and `localStorage`.
3.  The WebSocket connection is forced to `reconnect`, establishing a new, unauthenticated session.

-----

## Code Reference

  - **Main orchestration**: `src/blockchain/auth.js`
  - **State management and post-login flow**: `src/context/useAppAuth.js`
</file>

<file path="public/dev_docs/en/core-concepts/config-contract.md">
# The Config Contract

The `Config` smart contract serves as the central, on-chain registry for all global system parameters in the SAVVA platform. Think of it as a decentralized key-value store that governs the behavior of all other contracts in the ecosystem.

A critical feature of the SAVVA platform is that the `Config` contract is controlled by the `Governance` contract. This means that any parameter can be changed through a community vote. Token holders can create proposals and vote to adjust fees, timelines, and other core mechanics, making the platform truly community-driven.

---

## How it Works

Parameters are stored and retrieved using `bytes32` keys. The frontend abstracts this away by providing a helper function, `getConfigParam`, which converts human-readable names (e.g., "min_staked_to_post") into the required on-chain format.

The contract has different functions for retrieving values based on their data type, primarily `getUInt` for numeric values and `getAddr` for contract addresses. The frontend automatically selects the correct function based on the parameter name.

---

## System Parameters

The following table details the global parameters currently managed by the `Config` contract.

| Name | Type | Units | Description |
| --- | --- | --- | --- |
| `authorShare` | Uint | percents * 100 | The author's share of the content fund (e.g., 100 = 1%). |
| `nftOwnerCut` | Uint | percents * 100 | The NFT owner's cut in percents * 100 (e.g., 100 = 1%). |
| `minContribution` | Uint | SAVVA | The minimum contribution to the content fund in SAVVA tokens. |
| `timeForRound` | Uint | seconds | The duration of a content fund round in seconds. |
| `winnerShare` | Uint | percents | The round prize's share of the fund in percents. |
| `minFundToShare` | Uint | SAVVA | The minimum fund amount required to share prizes, in SAVVA tokens. |
| `staking_withdraw_delay` | Uint | seconds | The staking cooldown period in seconds. |
| `contentNFT_mintPrice` | Uint | PLS | The price to mint a content NFT. |
| `pulsex_slippage` | Uint | percents | The slippage tolerance for PulseX swaps (reserve/amount min). |
| `min_staked_to_post` | Uint | SAVVA | The minimum staked SAVVA amount required to post content. |
| `sac_min_deposit` | Uint | PLS | The minimum deposit for the sacrifice phase. |
| `patron_payment_period` | Uint | seconds | The duration of a patron payment period in seconds. |
| `gov_proposal_price` | Uint | PLS | The price to create a new governance proposal. |
| `nft_auction_max_duration` | Uint | seconds | The maximum duration for an NFT auction in seconds. |
| `nft_auction_min_increment` | Uint | percents | The minimum bid increment for an NFT auction in percents. |
| `nft_auction_max_increment` | Uint | percents | The maximum bid increment for an NFT auction in percents. |
| `min_staked_for_nft_auction`| Uint | SAVVA | The minimum staked SAVVA required to create an NFT auction. |
| `authorsClubsGainReceiver` | Address | | The address that receives staking gains from Authors Clubs. |
| `min_staked_for_fundrasing` | Uint | SAVVA | The minimum staked SAVVA required to create a fundraiser. |
| `fundraising_bb_fee` | Uint | percents * 100 | The buyback fee for fundraisers in percents * 100 (e.g., 100 = 1%). |
| `contract_savvaToken` | Address | | SAVVA token contract address. |
| `contract_randomOracle` | Address | | Random oracle contract address (0 for none). |
| `contract_staking` | Address | | Staking contract address. |
| `contract_userProfile` | Address | | User Profile contract address. |
| `contract_contentNFT` | Address | | Content NFT contract address. |
| `contract_contentFund` | Address | | Content Fund contract address. |
| `contract_governance` | Address | | Governance contract address. |
| `contract_contentRegistry` | Address | | Content Registry contract address. |
| `contract_savvaFaucet` | Address | | SAVVA Faucet contract address. |
| `contract_nftMarketplace` | Address | | NFT Marketplace contract address. |
| `contract_promo` | Address | | Promo contract address. |
| `contract_buyBurn` | Address | | Buy & Burn contract address. |
| `contract_listMarket` | Address | | List Market contract address. |
| `contract_authorOfTheMonth` | Address | | Author of the Month contract address. |
| `pulsex_factory` | Address | | PulseX factory contract for Buy & Burn. |
| `pulsex_router` | Address | | PulseX router contract for Buy & Burn. |
| `WPLS` | Address | | Wrapped PLS (WPLS) contract address. |
</file>

<file path="public/dev_docs/en/core-concepts/domain.md">
# Working with domains

A **domain** is simply the name of the social network you want to render. It’s usually the site’s DNS host (e.g. `savva.app`) but it doesn’t have to be. Each domain has a **domain pack** — a folder that contains `config.yaml` plus all domain‑specific assets (logos, favicon, locales, tabs config, optional `domain.css`, etc.).

## Where does `config.yaml` live?

At runtime the app computes an **assets base URL** from `/info`:
- **Production:** `assets_url`
- **Test:** `temp_assets_url`

The active environment is a simple prod/test toggle in the app (used by admins to test changes). Given the **selected domain name**, the app builds a prefix:

```

<assetsBase>/<domain>/

```

Then the app tries to load:

```

<assetsBase>/<domain>/config.yaml

```

If that fails (missing pack, 404, etc.), the UI **falls back** to the built‑in default pack:

```

/domain\_default/config.yaml

```

> This lookup and diagnostics are centralized; you’ll see the same paths in the diagnostics UI.  
> The active `domain.css` is loaded from the same prefix and cache‑busted with a revision key, so changes apply immediately after upload.

## Why two environments (prod / test)?

The backend serves two base URLs for assets:

- **`assets_url`** → production pack for end users  
- **`temp_assets_url`** → test pack for previewing changes

An administrator (as configured in backend) can push a modified domain pack under the **test** base and verify everything (logos, tabs, GA, colors) without affecting users. When happy, they publish the same pack to **prod**.

## Domain pack layout

Everything for a domain lives under a single folder:

```

<assetsBase>/<domain>/
config.yaml          # main configuration (logos, favicon, locales, modules)
domain.css           # optional theme variables (colors, backgrounds)
i18n/*.yaml          # language dictionaries (per-locale)
images/*             # branding assets
modules/tabs.yaml    # tabs definition for the main screen
modules/*.yaml       # other module configs (optional)
html/*.html          # arbitrary HTML blocks (optional)

````

## Example `config.yaml`

Below is a trimmed example showing the typical fields the app uses:

```yaml
logo:
  light: images/logo_light.png
  dark: images/logo_dark.png
  light_mobile: images/logo_light.png
  dark_mobile: images/logo_dark.png

favicon:
  apple-touch-icon: favicon/apple-touch-icon.png
  16: favicon/favicon-16x16.png
  32: favicon/favicon-32x32.png
  manifest: favicon/site.webmanifest
  mask-icon:
    href: favicon/safari-pinned-tab.svg
    color: '#5bbad5'
  base: favicon/favicon.ico
  meta:
    - name: msapplication-TileColor
      content: '#da532c'
    - name: theme-color
      content: '#ffffff'

GA_tag: G-XXXXXXXXXX   # Google Analytics (gtag) ID

modules:
  tabs: modules/tabs.yaml
  content_lists: modules/content_lists.yaml
  staker_levels: modules/staker_levels.yaml
  categories: modules/categories.yaml

default_locale: en
locales:
  - code: en
    name: English
    title: 'SAVVA.APP - Beyond Likes Social'
    dictionary: i18n/en.yaml
  - code: ru
    name: Русский
    title: 'SAVVA.APP - За пределами лайков'
    dictionary: i18n/ru.yaml
````

### What these fields control

* **`logo`** — The app chooses the best variant automatically (dark/light + mobile/desktop) and resolves via the active domain prefix.
* **`favicon`** — All favicon links & meta tags are applied dynamically; when the config changes, the app replaces the `<link rel="icon">` set.
* **`GA_tag`** — Enables Google Analytics (gtag.js). When present, the app injects GA scripts and sends SPA `page_view` events on route changes.
* **`modules.tabs`** — Points at the YAML that defines the tabs on the main screen (see below).
* **`locales`** — Language list for the domain (code/name/title + dictionary path). The app can render localized titles/strings per domain.

## Tabs on the main screen

Tabs are configured in a standalone YAML (referenced by `modules.tabs` above). For example:

```yaml
# modules/tabs.yaml
tabs:
  - type: leaders
    title:
      en: Leaders
      ru: Лидеры
    right_panel:
      available: true
      blocks:
        - type: html
          en: /html/info_block_en.html
          ru: /html/info_block_ru.html
        - type: content_List
          list_name: main
          count: 7

  - type: new
    title:
      en: New
      ru: Новое
```

The UI picks the localized tab title, chooses an icon by `type`, and renders optional right‑panel blocks. This file lives in the **same domain folder**, so it’s versioned and previewed together with `config.yaml`.

## Theme colors via `domain.css`

If present, `domain.css` is fetched from the same domain prefix and applied at runtime. It typically defines CSS custom properties the UI uses (backgrounds, foreground, accents, borders, etc.). Switching **domain** or **environment** reloads this CSS, so admins can fine‑tune branding without rebuilding the app.

Example variables:

```css
:root {
  --gradient: linear-gradient(to top left, #000c40, #607d8b);
  --background: 243 100% 98.26%;
  --foreground: 243 10% 0.52%;
  --muted: 243 10% 91.3%;
  --muted-foreground: 243 5% 41.3%;
  --primary: 243 100% 13%;
  --primary-foreground: 243 2% 98%;
  /* ... */
}
```

## Google Analytics (GA)

Set the `GA_tag` in `config.yaml` to enable GA. The app injects the GA script and initializes `gtag(...)` automatically, and also tracks page views on hash‑route changes. Remove or clear `GA_tag` to disable analytics for the domain.

---

### Summary

* The app chooses **prod** or **test** assets base, then loads `<base>/<domain>/config.yaml` with a safe fallback to `/domain_default/config.yaml`.
* **All** domain resources (logos, locales, tabs, `domain.css`) live under the same folder for atomic updates.
* Admins can preview changes in **test** before publishing to **prod**.
* `config.yaml` controls branding (logos, favicon), localization, GA, and where to find UI modules like **tabs**.
</file>

<file path="public/dev_docs/en/core-concepts/index.md">
<!-- public/dev_docs/en/core-concepts/index.md -->
# Core Concepts

This section covers the core architecture of the SAVVA SolidJS app: how it connects to the backend, how domains and assets work, how UI is driven by per‑domain configuration, and more.

What we’ll cover:

- How the app boots and finds the correct backend & domain
- How `/info` drives runtime behavior (domains, chain ID, IPFS gateways, assets)
- How domain assets are resolved and when the default pack is used
</file>

<file path="public/dev_docs/en/core-concepts/publishing-posts.md">
# Publishing a Post

Publishing content on the SAVVA platform is a three-step process that ensures data integrity, decentralization, and on-chain verification. The flow involves preparing the post data locally, uploading the content and its descriptor to IPFS, and finally registering the post on the blockchain via a smart contract call.

The frontend editor automates this process through a wizard, but understanding the underlying steps is crucial for developers.

---

## Step 1: Prepare Post Data

Before any upload or transaction occurs, the editor organizes the post into a standardized directory structure. This structure is managed locally using the File System API.

The main components are:

* A parameters file (`params.json`) for editor-specific settings.
* A descriptor file (`info.yaml`) that defines the post's structure and metadata for IPFS.
* Markdown files for the content of each language.
* An `uploads/` directory for any associated media files (images, videos, etc.).

### Example `params.json`

This file holds settings used by the editor UI and is not published on-chain.

```json
{
  "guid": "c4a7f6b9-6e3e-4b9e-8b1e-2e4a6d7c8b9a",
  "nsfw": false,
  "fundraiser": 0,
  "publishAsNewPost": true,
  "locales": {
    "en": {
      "tags": ["decentralization", "social"],
      "categories": ["Technology"],
      "chapters": [
        { "title": "What is a Blockchain?" },
        { "title": "IPFS and Content Addressing" }
      ]
    }
  },
  "thumbnail": "uploads/thumbnail.png"
}
```

### Example `info.yaml` (The Post Descriptor)

This file is the canonical definition of the post and is uploaded to IPFS. It links all the content pieces together.

```yaml
savva_spec_version: "2.0"
data_cid: bafybeih...
gateways:
  - https://ipfs.io/
locales:
  en:
    title: "Understanding Decentralized Systems"
    text_preview: "A deep dive into the core concepts of decentralization..."
    data_path: "en/data.md"
    chapters:
      - data_path: "en/chapters/1.md"
      - data_path: "en/chapters/2.md"
```

* **data\_cid**: The IPFS CID of the directory containing all Markdown content and uploaded files.
* **locales**: Contains language-specific metadata. The title and text\_preview from the editor are stored here.
* **data\_path / chapters.data\_path**: Relative paths to the content files within the `data_cid` directory.

---

## Step 2: Upload to IPFS

The upload process happens in two distinct phases, handled by the backend's storage API.

1. **Upload Content Directory**: All content files (e.g., `en/data.md`, `en/chapters/1.md`, `uploads/thumbnail.png`) are uploaded as a single directory to IPFS. The backend returns a single IPFS CID for this directory, which becomes the `data_cid`.
2. **Upload Descriptor**: The `info.yaml` file is generated with the `data_cid` from the previous step. This YAML file is then uploaded to IPFS as a standalone file. The CID of this `info.yaml` file is the final IPFS pointer for the post.

---

## Step 3: Register on the Blockchain

The final step is to record the post on the blockchain by calling the `reg` function on the `ContentRegistry` smart contract.

The frontend executes this transaction with the following parameters:

* **domain**: The current domain name (e.g., `savva.app`).
* **author**: The user's wallet address.
* **guid**: The unique identifier from `params.json`.
* **ipfs**: The IPFS CID of the `info.yaml` descriptor file from Step 2.
* **content\_type**: A `bytes32` string, typically `post` for new content or `post-edit` for updates.

### Example Contract Call

```javascript
// From: src/components/editor/wizard_steps/StepPublish.jsx

const contract = await getSavvaContract(app, "ContentRegistry", { write: true });

const hash = await contract.write.reg([
  domain,           // "savva.app"
  user.address,     // "0x123..."
  guid,             // "c4a7f6b9-..."
  descriptorCid,    // "bafybeif..."
  toHexBytes32("post")
]);

// The UI then waits for the transaction to be confirmed
const receipt = await publicClient.waitForTransactionReceipt({ hash });
```

Once the transaction is successfully mined, the post is officially published and will appear in content feeds.
</file>

<file path="public/dev_docs/fr/core-concepts/app-init.md">
# Initialisation de l'application et connexion au backend

## Qu'est-ce que le backend SAVVA (nœud SAVVA) ?
Un backend SAVVA est un composant serveur qui **indexe/cache les données provenant de l'activité de la blockchain** et expose des API et des méthodes WebSocket rapides et conviviales pour l'interface utilisateur. Un seul backend peut servir **plusieurs domaines SAVVA**—pensez à un « domaine » comme un réseau social SAVVA distinct (branding, onglets, actifs, valeurs par défaut), tous soutenus par un seul nœud.

## Ce dont l'application a besoin au démarrage
Au démarrage, l'application web a besoin de deux entrées :

1. **URL du backend** – l'URL de base du backend SAVVA.
2. **Nom de domaine** – quel domaine SAVVA (réseau social) rendre par défaut.

Les valeurs par défaut proviennent d'un petit fichier YAML à la racine du web :

### `/default_connect.yaml`
```yaml
# /default_connect.yaml
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
# optionnel :
# default_ipfs_link: ipfs://bafy.../something.json
```

* `backendLink` — point de terminaison HTTP de base du backend SAVVA (l'application le normalise).
* `domain` — domaine initial à rendre ; peut être changé plus tard dans l'interface utilisateur.
* `gear` — active les outils de développement dans l'interface utilisateur (optionnel).
* `default_ipfs_link` — valeur par défaut optionnelle utilisée dans certains flux.

> **Remarque de production**
> En production, ce fichier est généralement servi par votre serveur HTTP (par exemple, Nginx) et choisit effectivement **quel domaine** une application web déployée affiche par défaut. Un modèle courant consiste à servir un fichier spécifique depuis le disque :
>
> ```nginx
> # exemple : servir un fichier statique default_connect.yaml
> location = /default_connect.yaml {
>   default_type text/yaml;
>   alias /etc/savva/default_connect.yaml;
> }
> ```
>
> Ajustez selon votre infrastructure ; l'essentiel est que l'application puisse `GET /default_connect.yaml`.

---

## Séquence de démarrage

1. **Charger `/default_connect.yaml`**
   L'application récupère le fichier YAML, valide `backendLink`, et stocke `domain`. Elle **configure immédiatement les points de terminaison** (base HTTP + URL WS) en utilisant ces valeurs. &#x20;

2. **Configurer les points de terminaison**

   * `httpBase` est une version normalisée de `backendLink` (garantie avec un slash final).
   * L'URL `ws` est dérivée de la même base, pointant vers `.../ws` (protocole changé en `ws:` ou `wss:`) et inclut `?domain=...` dans la requête.
     Cela maintient **une source de vérité** pour HTTP et WS.&#x20;

3. **Récupérer `/info`**
   Avec les points de terminaison définis, l'application appelle `GET <httpBase>info` et stocke le JSON. À partir de ce moment, **/info guide le comportement d'exécution** (domaines, chaîne, IPFS, actifs).&#x20;

4. **Dériver l'état d'exécution à partir de `/info`**
   Les champs suivants sont utilisés (voir l'exemple ci-dessous) :

   * **`domains`** → Liste des domaines disponibles. L'interface utilisateur préfère le `domain` explicite du YAML/surcharge ; s'il n'est pas présent dans `/info`, il l'utilise quand même.&#x20;
   * **`blockchain_id`** → ID de chaîne EVM cible. L'outil de portefeuille peut changer/ajouter ce réseau.&#x20;
   * **`ipfs_gateways`** → Passerelles IPFS distantes à essayer dans l'ordre (sauf si une surcharge IPFS locale est activée).&#x20;
   * **`assets_url`** et **`temp_assets_url`** → La **base des actifs** (prod vs test). L'application calcule le **préfixe des actifs du domaine actif** comme
     `(<base des actifs> + <domaine> + "/")` avec un **repli** sur `/domain_default/` si le `config.yaml` distant est manquant. &#x20;

5. **Charger les actifs et la configuration du domaine**
   L'application essaie `(<préfixe actif>/config.yaml)` avec un court délai d'attente ; en cas d'échec, elle revient au pack par défaut à `/domain_default/config.yaml`. La configuration analysée résultante (logos, onglets, locales, etc.) est stockée et l'interface utilisateur se rend en conséquence.&#x20;

6. **Exécution WebSocket**
   Le client WS utilise l'URL `ws` calculée à partir des points de terminaison ; lorsque le backend/le domaine changent, les points de terminaison se recalculent et la couche WS le prend en compte.&#x20;

---

## Exemple de `/info` (illustratif)

```json
{
  "domains": [
    "savva.app",
    {"name": "art.savva"},
    "dev.savva"
  ],
  "blockchain_id": 369,
  "ipfs_gateways": [
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/"
  ],
  "assets_url": "https://cdn.savva.network/assets/",
  "temp_assets_url": "https://cdn.savva.network/assets-test/"
}
```

### Champ par champ (ce que l'application en fait)

* **domains** — liste des domaines sélectionnables. La boîte de dialogue **Changer de backend / domaine** se remplit à partir de `/info`, mais le domaine configuré prend toujours la priorité si `/info` est en retard. &#x20;
* **blockchain\_id** — ID numérique de la chaîne EVM ; utilisé pour construire les métadonnées `changer/ajouter une chaîne` et pour s'assurer que le portefeuille est sur le **réseau requis**. &#x20;
* **ipfs\_gateways** — liste ordonnée de passerelles distantes ; combinée avec une éventuelle **surcharge IPFS locale** (lorsqu'elle est activée dans les paramètres) pour former l'ordre de passerelle **actif**.&#x20;
* **assets\_url / temp\_assets\_url** — l'application maintient un **environnement d'actifs** (`prod`/`test`) et choisit la base correspondante. Elle calcule ensuite `/<base>/<domaine>/` et charge `config.yaml`. Si le pack distant est manquant ou lent, elle utilise le **par défaut** `/domain_default/`.&#x20;

---

## Où cela se trouve dans le code (pour référence rapide)

* Démarrage et chargement de `/default_connect.yaml`, puis `/info` : **`src/context/AppContext.jsx`** et **`src/hooks/useConnect.js`**. &#x20;
* Source de vérité des points de terminaison (base HTTP + URL WS) : **`src/net/endpoints.js`**.&#x20;
* Résolution de la liste des domaines, ID de chaîne, passerelles IPFS, environnement d'actifs et chargement des actifs du domaine : **`src/context/AppContext.jsx`**.  &#x20;
* Boîte de dialogue de changement qui récupère `/info` et normalise `domains` : **`src/components/SwitchConnectDialog.jsx`**.&#x20;

---

**Suivant :** dans le chapitre suivant, nous allons décomposer **la configuration du domaine** (`config.yaml`) et comment elle contrôle les logos, les onglets, les locales et d'autres comportements de l'interface utilisateur par domaine.
</file>

<file path="public/dev_docs/fr/core-concepts/auth.md">
# Flux d'Autorisation Web3

La plateforme SAVVA utilise une méthode d'authentification Web3 sans mot de passe. Les utilisateurs peuvent "se connecter" en utilisant n'importe quel portefeuille compatible EVM en signant simplement un message unique fourni par le serveur. Ce processus vérifie la propriété de l'adresse et établit une session sécurisée gérée par un cookie de navigateur.

## Vue d'ensemble du Flux

Le processus d'autorisation implique une séquence d'étapes orchestrées entre le frontend, le portefeuille de l'utilisateur, la blockchain et le backend de SAVVA.

1.  **Préparer un Message Unique** : Le frontend construit un message unique que l'utilisateur doit signer. Ce message est composé de deux parties : une valeur dynamique provenant d'un contrat intelligent et une valeur statique provenant du backend.
2.  **L'utilisateur signe le Message** : L'utilisateur est invité par son portefeuille (par exemple, MetaMask) à signer le message préparé.
3.  **Authentification Backend** : Le frontend envoie l'adresse de l'utilisateur et la signature résultante à l'endpoint `/auth` du backend.
4.  **Cookie de Session** : Si la signature est valide, le backend répond avec un en-tête `Set-Cookie`, établissant une session authentifiée.
5.  **Requêtes Authentifiées** : Toutes les requêtes API et WebSocket suivantes du navigateur incluront automatiquement ce cookie, identifiant l'utilisateur.
6.  **Récupérer le Profil Utilisateur** : Une fois authentifié, le frontend effectue un appel WebSocket à `/get-user` pour récupérer les détails complets du profil de l'utilisateur, tels que son avatar et son nom.

---

## Mise en Œuvre Étape par Étape

### 1. Préparation du Message à Signer

Pour prévenir les attaques par rejeu et garantir que chaque demande de connexion soit unique, le message à signer est construit à partir de deux sources :

-   Une chaîne dynamique **`auth_modifier`** lue à partir du contrat intelligent `UserProfile`.
-   Une chaîne statique **`auth_text_to_sign`** fournie par l'endpoint `/info` du backend.

Le frontend appelle d'abord la fonction `getString` sur le contrat `UserProfile` :

```javascript
// From: src/blockchain/auth.js

// Get the UserProfile contract instance
const userProfileContract = await getSavvaContract(app, 'UserProfile');

// Prepare arguments for the contract call
const domainHex = toHexBytes32(""); // Domain is empty for the global modifier
const keyHex = toHexBytes32("auth_modifier");

// Fetch the modifier (returns a bytes32 hex string)
const modifierHex = await userProfileContract.read.getString([
  account,      // User's address
  domainHex,    // bytes32 representation of ""
  keyHex        // bytes32 representation of "auth_modifier"
]);

// Convert the hex value to a readable string
const modifierString = hexToString(modifierHex, { size: 32 });
```

Il combine ensuite ce `modifierString` avec le texte provenant de `/info` :

```javascript
// Get text from the already-loaded /info response
const textToSign = app.info().auth_text_to_sign;

// Combine in the required order
const messageToSign = textToSign + modifierString;
```

### 2\. Signature avec le Portefeuille

En utilisant `viem`, le frontend demande la signature de l'utilisateur pour le message combiné. Cette action ouvre une invite dans le portefeuille de l'utilisateur.

```javascript
// From: src/blockchain/auth.js

const walletClient = createWalletClient({
  chain: app.desiredChain(),
  transport: custom(window.ethereum)
});

const signature = await walletClient.signMessage({
  account,
  message: messageToSign,
});
```

La `signature` résultante est une longue chaîne hexadécimale (par exemple, `0x...`).

### 3\. Authentification avec le Backend

Le frontend effectue ensuite une requête `GET` à l'endpoint `/auth`, envoyant l'adresse de l'utilisateur, le domaine et la nouvelle signature en tant que paramètres de requête.

**Crucialement**, la requête `fetch` doit inclure l'option **`credentials: 'include'`**. Cela indique au navigateur de traiter l'en-tête `Set-Cookie` dans la réponse, ce qui est essentiel pour établir la session.

```javascript
// From: src/blockchain/auth.js

const authUrl = new URL(`${httpBase()}auth`);
authUrl.searchParams.set('user_addr', checksummedAccount);
authUrl.searchParams.set('domain', currentDomain);
authUrl.searchParams.set('signature', signature);

const authRes = await fetch(authUrl.toString(), { credentials: 'include' });
```

Si cela réussit, la réponse du backend inclura un en-tête similaire à celui-ci :

```
Set-Cookie: auth=...; Path=/; HttpOnly; Secure; SameSite=Lax
```

### 4\. Effectuer des Appels API Authentifiés

Avec le cookie maintenant défini dans le navigateur, les appels API suivants (comme vérifier les privilèges d'administrateur) doivent également inclure **`credentials: 'include'`** pour s'assurer que le cookie est envoyé avec la requête.

```javascript
// From: src/blockchain/auth.js

const isAdminUrl = new URL(`${httpBase()}is-admin`);
isAdminUrl.searchParams.set('address', checksummedAccount);
isAdminUrl.searchParams.set('domain', currentDomain);

const adminRes = await fetch(isAdminUrl.toString(), { credentials: 'include' });
const isAdminData = await adminRes.json(); // e.g., {"result":"ok","admin":true}
const isAdmin = !!isAdminData?.admin;
```

### 5\. Récupérer le Profil Utilisateur (via WebSocket)

Le navigateur envoie automatiquement le cookie d'authentification lors de la mise à niveau de la connexion WebSocket. Après une connexion réussie, la fonction `login` de l'application effectue un `wsCall` à la méthode `get-user` pour récupérer le profil complet de l'utilisateur.

```javascript
// From: src/context/useAppAuth.js (in the login function)

const userProfile = await getWsApi().call('get-user', {
  domain: coreUserData.domain,
  user_addr: checksummedAccount,
});
```

Un exemple de réponse de `/get-user` pourrait ressembler à ceci :

```json
{
  "name": "alexna",
  "avatar": "QmbXwxPzs2veVYFbm7yybfK3rBMxEebuhAcWh3tuKdDTbq?filename=.png",
  "staked": 42529097734827650000000000,
  "n_followers": 9,
  "banned": false
}
```

-----

## Stockage de la Session

L'objet utilisateur final, qui est une combinaison des données principales (`address`, `domain`, `isAdmin`) et du profil récupéré depuis `/get-user`, est stocké dans le `AppContext` global et persistant dans `localStorage`. Cela permet de restaurer automatiquement la session lorsque l'utilisateur revient sur l'application.

## Le Processus de Déconnexion

Le processus de déconnexion inverse ces étapes :

1.  Une requête `POST` est envoyée à l'endpoint API `/logout` pour invalider la session côté serveur et effacer le cookie.
2.  Les données de l'utilisateur sont supprimées de l'état global et de `localStorage`.
3.  La connexion WebSocket est forcée à `reconnect`, établissant une nouvelle session non authentifiée.

-----

## Référence de Code

  - **Orchestration principale** : `src/blockchain/auth.js`
  - **Gestion de l'état et flux post-connexion** : `src/context/useAppAuth.js`
</file>

<file path="public/dev_docs/fr/core-concepts/config-contract.md">
# Le Contrat de Configuration

Le contrat intelligent `Config` sert de registre central, sur la chaîne, pour tous les paramètres globaux du système sur la plateforme SAVVA. Pensez-y comme à un magasin de clés-valeurs décentralisé qui régit le comportement de tous les autres contrats de l'écosystème.

Une caractéristique essentielle de la plateforme SAVVA est que le contrat `Config` est contrôlé par le contrat `Governance`. Cela signifie que tout paramètre peut être modifié par un vote de la communauté. Les détenteurs de jetons peuvent créer des propositions et voter pour ajuster les frais, les délais et d'autres mécanismes fondamentaux, rendant la plateforme véritablement dirigée par la communauté.

---

## Comment ça fonctionne

Les paramètres sont stockés et récupérés à l'aide de clés `bytes32`. Le frontend abstrait cela en fournissant une fonction d'aide, `getConfigParam`, qui convertit les noms lisibles par l'homme (par exemple, "min_staked_to_post") dans le format requis sur la chaîne.

Le contrat a différentes fonctions pour récupérer des valeurs en fonction de leur type de données, principalement `getUInt` pour les valeurs numériques et `getAddr` pour les adresses de contrat. Le frontend sélectionne automatiquement la fonction correcte en fonction du nom du paramètre.

---

## Paramètres du Système

Le tableau suivant détaille les paramètres globaux actuellement gérés par le contrat `Config`.

| Nom | Type | Unités | Description |
| --- | --- | --- | --- |
| `authorShare` | Uint | pourcent * 100 | La part de l'auteur dans le fonds de contenu (par exemple, 100 = 1 %). |
| `nftOwnerCut` | Uint | pourcent * 100 | La part du propriétaire de l'NFT en pourcent * 100 (par exemple, 100 = 1 %). |
| `minContribution` | Uint | SAVVA | La contribution minimale au fonds de contenu en jetons SAVVA. |
| `timeForRound` | Uint | secondes | La durée d'un tour de fonds de contenu en secondes. |
| `winnerShare` | Uint | pourcent | La part du prix du tour dans le fonds en pourcent. |
| `minFundToShare` | Uint | SAVVA | Le montant minimum de fonds requis pour partager des prix, en jetons SAVVA. |
| `staking_withdraw_delay` | Uint | secondes | La période de refroidissement du staking en secondes. |
| `contentNFT_mintPrice` | Uint | PLS | Le prix pour frapper un NFT de contenu. |
| `pulsex_slippage` | Uint | pourcent | La tolérance de glissement pour les échanges PulseX (réserve/montant min). |
| `min_staked_to_post` | Uint | SAVVA | Le montant minimum de SAVVA staké requis pour publier du contenu. |
| `sac_min_deposit` | Uint | PLS | Le dépôt minimum pour la phase de sacrifice. |
| `patron_payment_period` | Uint | secondes | La durée d'une période de paiement de mécène en secondes. |
| `gov_proposal_price` | Uint | PLS | Le prix pour créer une nouvelle proposition de gouvernance. |
| `nft_auction_max_duration` | Uint | secondes | La durée maximale d'une enchère NFT en secondes. |
| `nft_auction_min_increment` | Uint | pourcent | L'augmentation minimale des enchères pour une enchère NFT en pourcent. |
| `nft_auction_max_increment` | Uint | pourcent | L'augmentation maximale des enchères pour une enchère NFT en pourcent. |
| `min_staked_for_nft_auction`| Uint | SAVVA | Le montant minimum de SAVVA staké requis pour créer une enchère NFT. |
| `authorsClubsGainReceiver` | Address | | L'adresse qui reçoit les gains de staking des Clubs d'Auteurs. |
| `min_staked_for_fundrasing` | Uint | SAVVA | Le montant minimum de SAVVA staké requis pour créer une collecte de fonds. |
| `fundraising_bb_fee` | Uint | pourcent * 100 | Les frais de rachat pour les collectes de fonds en pourcent * 100 (par exemple, 100 = 1 %). |
| `contract_savvaToken` | Address | | Adresse du contrat de jeton SAVVA. |
| `contract_randomOracle` | Address | | Adresse du contrat d'oracle aléatoire (0 pour aucun). |
| `contract_staking` | Address | | Adresse du contrat de staking. |
| `contract_userProfile` | Address | | Adresse du contrat de profil utilisateur. |
| `contract_contentNFT` | Address | | Adresse du contrat de NFT de contenu. |
| `contract_contentFund` | Address | | Adresse du contrat de fonds de contenu. |
| `contract_governance` | Address | | Adresse du contrat de gouvernance. |
| `contract_contentRegistry` | Address | | Adresse du contrat de registre de contenu. |
| `contract_savvaFaucet` | Address | | Adresse du contrat de robinet SAVVA. |
| `contract_nftMarketplace` | Address | | Adresse du contrat de marché NFT. |
| `contract_promo` | Address | | Adresse du contrat de promotion. |
| `contract_buyBurn` | Address | | Adresse du contrat d'achat et de brûlage. |
| `contract_listMarket` | Address | | Adresse du contrat de marché de liste. |
| `contract_authorOfTheMonth` | Address | | Adresse du contrat de l'Auteur du Mois. |
| `pulsex_factory` | Address | | Contrat de la fabrique PulseX pour l'achat et le brûlage. |
| `pulsex_router` | Address | | Contrat du routeur PulseX pour l'achat et le brûlage. |
| `WPLS` | Address | | Adresse du contrat Wrapped PLS (WPLS). |
</file>

<file path="public/dev_docs/fr/core-concepts/domain.md">
# Travailler avec les domaines

Un **domaine** est simplement le nom du réseau social que vous souhaitez rendre. C'est généralement l'hôte DNS du site (par exemple, `savva.app`), mais ce n'est pas obligatoire. Chaque domaine a un **pack de domaine** — un dossier qui contient `config.yaml` ainsi que tous les actifs spécifiques au domaine (logos, favicon, locales, configuration des onglets, `domain.css` optionnel, etc.).

## Où se trouve `config.yaml` ?

Au moment de l'exécution, l'application calcule une **URL de base des actifs** à partir de `/info` :
- **Production :** `assets_url`
- **Test :** `temp_assets_url`

L'environnement actif est un simple basculement prod/test dans l'application (utilisé par les administrateurs pour tester des modifications). Étant donné le **nom de domaine sélectionné**, l'application construit un préfixe :

```

<assetsBase>/<domain>/

```

Ensuite, l'application essaie de charger :

```

<assetsBase>/<domain>/config.yaml

```

Si cela échoue (pack manquant, 404, etc.), l'interface utilisateur **retourne** au pack par défaut intégré :

```

/domain\_default/config.yaml

```

> Cette recherche et ce diagnostic sont centralisés ; vous verrez les mêmes chemins dans l'interface de diagnostic.  
> Le `domain.css` actif est chargé à partir du même préfixe et est mis en cache avec une clé de révision, donc les modifications s'appliquent immédiatement après le téléchargement.

## Pourquoi deux environnements (prod / test) ?

Le backend sert deux URL de base pour les actifs :

- **`assets_url`** → pack de production pour les utilisateurs finaux  
- **`temp_assets_url`** → pack de test pour prévisualiser les modifications

Un administrateur (tel que configuré dans le backend) peut pousser un pack de domaine modifié sous la base **test** et vérifier tout (logos, onglets, GA, couleurs) sans affecter les utilisateurs. Lorsqu'il est satisfait, il publie le même pack en **prod**.

## Structure du pack de domaine

Tout pour un domaine se trouve sous un seul dossier :

```

<assetsBase>/<domain>/
config.yaml          # configuration principale (logos, favicon, locales, modules)
domain.css           # variables de thème optionnelles (couleurs, arrière-plans)
i18n/*.yaml          # dictionnaires de langue (par-locale)
images/*             # actifs de marque
modules/tabs.yaml    # définition des onglets pour l'écran principal
modules/*.yaml       # autres configurations de module (optionnelles)
html/*.html          # blocs HTML arbitraires (optionnels)

````

## Exemple de `config.yaml`

Voici un exemple abrégé montrant les champs typiques utilisés par l'application :

```yaml
logo:
  light: images/logo_light.png
  dark: images/logo_dark.png
  light_mobile: images/logo_light.png
  dark_mobile: images/logo_dark.png

favicon:
  apple-touch-icon: favicon/apple-touch-icon.png
  16: favicon/favicon-16x16.png
  32: favicon/favicon-32x32.png
  manifest: favicon/site.webmanifest
  mask-icon:
    href: favicon/safari-pinned-tab.svg
    color: '#5bbad5'
  base: favicon/favicon.ico
  meta:
    - name: msapplication-TileColor
      content: '#da532c'
    - name: theme-color
      content: '#ffffff'

GA_tag: G-XXXXXXXXXX   # ID Google Analytics (gtag)

modules:
  tabs: modules/tabs.yaml
  content_lists: modules/content_lists.yaml
  staker_levels: modules/staker_levels.yaml
  categories: modules/categories.yaml

default_locale: en
locales:
  - code: en
    name: English
    title: 'SAVVA.APP - Beyond Likes Social'
    dictionary: i18n/en.yaml
  - code: ru
    name: Русский
    title: 'SAVVA.APP - За пределами лайков'
    dictionary: i18n/ru.yaml
````

### Ce que ces champs contrôlent

* **`logo`** — L'application choisit automatiquement la meilleure variante (sombre/clair + mobile/desktop) et résout via le préfixe de domaine actif.
* **`favicon`** — Tous les liens de favicon et les balises méta sont appliqués dynamiquement ; lorsque la configuration change, l'application remplace le `<link rel="icon">` défini.
* **`GA_tag`** — Active Google Analytics (gtag.js). Lorsqu'il est présent, l'application injecte des scripts GA et envoie des événements `page_view` SPA lors des changements de route.
* **`modules.tabs`** — Pointe vers le YAML qui définit les onglets sur l'écran principal (voir ci-dessous).
* **`locales`** — Liste des langues pour le domaine (code/nom/titre + chemin du dictionnaire). L'application peut rendre des titres/chaînes localisés par domaine.

## Onglets sur l'écran principal

Les onglets sont configurés dans un YAML autonome (référencé par `modules.tabs` ci-dessus). Par exemple :

```yaml
# modules/tabs.yaml
tabs:
  - type: leaders
    title:
      en: Leaders
      ru: Лидеры
    right_panel:
      available: true
      blocks:
        - type: html
          en: /html/info_block_en.html
          ru: /html/info_block_ru.html
        - type: content_List
          list_name: main
          count: 7

  - type: new
    title:
      en: New
      ru: Новое
```

L'interface utilisateur choisit le titre d'onglet localisé, choisit une icône par `type`, et rend les blocs optionnels du panneau de droite. Ce fichier se trouve dans le **même dossier de domaine**, il est donc versionné et prévisualisé avec `config.yaml`.

## Couleurs de thème via `domain.css`

Si présent, `domain.css` est récupéré à partir du même préfixe de domaine et appliqué à l'exécution. Il définit généralement des propriétés CSS personnalisées que l'interface utilise (arrière-plans, premier plan, accents, bordures, etc.). Changer de **domaine** ou d'**environnement** recharge ce CSS, permettant aux administrateurs d'ajuster la marque sans reconstruire l'application.

Exemple de variables :

```css
:root {
  --gradient: linear-gradient(to top left, #000c40, #607d8b);
  --background: 243 100% 98.26%;
  --foreground: 243 10% 0.52%;
  --muted: 243 10% 91.3%;
  --muted-foreground: 243 5% 41.3%;
  --primary: 243 100% 13%;
  --primary-foreground: 243 2% 98%;
  /* ... */
}
```

## Google Analytics (GA)

Définissez le `GA_tag` dans `config.yaml` pour activer GA. L'application injecte le script GA et initialise `gtag(...)` automatiquement, et suit également les vues de page lors des changements de route par hachage. Supprimez ou effacez `GA_tag` pour désactiver l'analyse pour le domaine.

---

### Résumé

* L'application choisit la base d'actifs **prod** ou **test**, puis charge `<base>/<domain>/config.yaml` avec un retour sécurisé à `/domain_default/config.yaml`.
* **Tous** les ressources de domaine (logos, locales, onglets, `domain.css`) se trouvent sous le même dossier pour des mises à jour atomiques.
* Les administrateurs peuvent prévisualiser les modifications en **test** avant de publier en **prod**.
* `config.yaml` contrôle la marque (logos, favicon), la localisation, GA, et où trouver les modules d'interface utilisateur comme **tabs**.
</file>

<file path="public/dev_docs/fr/core-concepts/index.md">
<!-- public/dev_docs/fr/core-concepts/index.md -->
# Concepts de base

Cette section couvre l'architecture de base de l'application SAVVA SolidJS : comment elle se connecte au backend, comment fonctionnent les domaines et les actifs, comment l'interface utilisateur est pilotée par la configuration par domaine, et plus encore.

Ce que nous allons aborder :

- Comment l'application démarre et trouve le bon backend et domaine
- Comment `/info` influence le comportement à l'exécution (domaines, ID de chaîne, passerelles IPFS, actifs)
- Comment les actifs de domaine sont résolus et quand le pack par défaut est utilisé
</file>

<file path="public/dev_docs/fr/core-concepts/publishing-posts.md">
# Publication d'un Post

La publication de contenu sur la plateforme SAVVA est un processus en trois étapes qui garantit l'intégrité des données, la décentralisation et la vérification sur la chaîne. Le flux implique la préparation des données du post localement, le téléchargement du contenu et de son descripteur sur IPFS, et enfin l'enregistrement du post sur la blockchain via un appel de contrat intelligent.

L'éditeur frontend automatise ce processus à travers un assistant, mais comprendre les étapes sous-jacentes est crucial pour les développeurs.

---

## Étape 1 : Préparer les Données du Post

Avant qu'un téléchargement ou une transaction n'ait lieu, l'éditeur organise le post dans une structure de répertoire standardisée. Cette structure est gérée localement à l'aide de l'API File System.

Les principaux composants sont :

* Un fichier de paramètres (`params.json`) pour les paramètres spécifiques à l'éditeur.
* Un fichier de descripteur (`info.yaml`) qui définit la structure et les métadonnées du post pour IPFS.
* Des fichiers Markdown pour le contenu de chaque langue.
* Un répertoire `uploads/` pour tous les fichiers multimédias associés (images, vidéos, etc.).

### Exemple de `params.json`

Ce fichier contient les paramètres utilisés par l'interface utilisateur de l'éditeur et n'est pas publié sur la chaîne.

```json
{
  "guid": "c4a7f6b9-6e3e-4b9e-8b1e-2e4a6d7c8b9a",
  "nsfw": false,
  "fundraiser": 0,
  "publishAsNewPost": true,
  "locales": {
    "en": {
      "tags": ["décentralisation", "social"],
      "categories": ["Technologie"],
      "chapters": [
        { "title": "Qu'est-ce qu'une Blockchain ?" },
        { "title": "IPFS et l'Adressage de Contenu" }
      ]
    }
  },
  "thumbnail": "uploads/thumbnail.png"
}
```

### Exemple de `info.yaml` (Le Descripteur du Post)

Ce fichier est la définition canonique du post et est téléchargé sur IPFS. Il relie tous les éléments de contenu ensemble.

```yaml
savva_spec_version: "2.0"
data_cid: bafybeih...
gateways:
  - https://ipfs.io/
locales:
  en:
    title: "Comprendre les Systèmes Décentralisés"
    text_preview: "Une plongée approfondie dans les concepts fondamentaux de la décentralisation..."
    data_path: "en/data.md"
    chapters:
      - data_path: "en/chapters/1.md"
      - data_path: "en/chapters/2.md"
```

* **data\_cid** : Le CID IPFS du répertoire contenant tout le contenu Markdown et les fichiers téléchargés.
* **locales** : Contient des métadonnées spécifiques à la langue. Le titre et le text\_preview de l'éditeur y sont stockés.
* **data\_path / chapters.data\_path** : Chemins relatifs vers les fichiers de contenu dans le répertoire `data_cid`.

---

## Étape 2 : Télécharger sur IPFS

Le processus de téléchargement se déroule en deux phases distinctes, gérées par l'API de stockage du backend.

1. **Télécharger le Répertoire de Contenu** : Tous les fichiers de contenu (par exemple, `en/data.md`, `en/chapters/1.md`, `uploads/thumbnail.png`) sont téléchargés en tant que répertoire unique sur IPFS. Le backend renvoie un seul CID IPFS pour ce répertoire, qui devient le `data_cid`.
2. **Télécharger le Descripteur** : Le fichier `info.yaml` est généré avec le `data_cid` de l'étape précédente. Ce fichier YAML est ensuite téléchargé sur IPFS en tant que fichier autonome. Le CID de ce fichier `info.yaml` est le pointeur IPFS final pour le post.

---

## Étape 3 : Enregistrer sur la Blockchain

La dernière étape consiste à enregistrer le post sur la blockchain en appelant la fonction `reg` sur le contrat intelligent `ContentRegistry`.

Le frontend exécute cette transaction avec les paramètres suivants :

* **domain** : Le nom de domaine actuel (par exemple, `savva.app`).
* **author** : L'adresse du portefeuille de l'utilisateur.
* **guid** : L'identifiant unique du fichier `params.json`.
* **ipfs** : Le CID IPFS du fichier descripteur `info.yaml` de l'Étape 2.
* **content\_type** : Une chaîne `bytes32`, généralement `post` pour un nouveau contenu ou `post-edit` pour des mises à jour.

### Exemple d'Appel de Contrat

```javascript
// From: src/components/editor/wizard_steps/StepPublish.jsx

const contract = await getSavvaContract(app, "ContentRegistry", { write: true });

const hash = await contract.write.reg([
  domain,           // "savva.app"
  user.address,     // "0x123..."
  guid,             // "c4a7f6b9-..."
  descriptorCid,    // "bafybeif..."
  toHexBytes32("post")
]);

// L'interface utilisateur attend ensuite que la transaction soit confirmée
const receipt = await publicClient.waitForTransactionReceipt({ hash });
```

Une fois la transaction minée avec succès, le post est officiellement publié et apparaîtra dans les flux de contenu.
</file>

<file path="public/dev_docs/fr/getting-started.md">
# Prise en Main

Bienvenue dans le guide de **Prise en Main** pour la plateforme SAVVA.

Cette page vous guide à travers les étapes de base pour configurer le projet localement et commencer à contribuer.

## Prérequis

Avant de commencer, assurez-vous d'avoir les outils suivants installés :

- **Node.js** (v18 ou version ultérieure recommandée)  
- Gestionnaire de paquets **npm** ou **yarn**  
- **Git** pour cloner le dépôt  
- Un **navigateur** moderne (Chrome, Firefox, Edge) pour le développement et les tests  

## Cloner le Dépôt

Le code source est hébergé sur GitHub. Pour obtenir la dernière version :

```bash
git clone https://github.com/AlexNa-Holdings/savva-ui-solidjs
cd savva-ui-solidjs
````

## Installer les Dépendances

Dans le dossier du projet, installez toutes les dépendances requises :

```bash
npm install
# ou
yarn install
```

## Démarrer le Serveur de Développement

Lancez le serveur de développement avec rechargement à chaud :

```bash
npm run dev
# ou
yarn dev
```

L'application sera disponible à [http://localhost:5173](http://localhost:5173).

## Construire pour la Production

Pour créer une version optimisée :

```bash
npm run build
```

La sortie sera dans le dossier `dist/`.

## Étapes Suivantes

* Explorez la **Documentation Développeur** pour l'architecture et les modules.
* Essayez de changer de domaines et d'actifs dans le **Panneau de Droite**.
* Contribuez en ouvrant des problèmes ou des demandes de tirage sur GitHub.

C'est tout ! 🎉 Vous êtes prêt à commencer à travailler avec la **plateforme SAVVA**.

```html
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SAVVA · SolidJS</title>

  <!-- Précharger le thème pour éviter le flash -->
  <script>
    (function () {
      try {
        const saved = localStorage.getItem("theme");
        const systemDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const theme = saved || (systemDark ? "dark" : "light");
        document.documentElement.classList.toggle("dark", theme === "dark");
      } catch { }
    })();
  </script>

  <script>
    (function () {
      // S'il y a un chemin réel (par exemple, /settings) mais pas de hash, réécrire en forme de hash : /#/settings
      if (!location.hash && location.pathname !== "/") {
        var newHash = "#" + location.pathname + location.search + location.hash;
        history.replaceState(null, "", "/" + newHash);
      }
    })();
  </script>


  <!-- Charger l'application après que la classe de thème soit définie -->
  <script type="module" src="/src/index.jsx"></script>
</head>

<body>
  <div id="root"></div>
</body>

</html>
```
</file>

<file path="public/dev_docs/fr/index.md">
# Documentation des développeurs SAVVA

Bienvenue dans la documentation des développeurs de la **plateforme SAVVA**.


## Qu'est-ce que SAVVA ?

SAVVA est une **plateforme open-source** pour construire des réseaux sociaux de nouvelle génération.  
Contrairement aux plateformes traditionnelles, SAVVA combine **blockchain** et **IPFS** pour créer une fondation décentralisée, fiable et résistante à la censure.

- **Publications ancrées dans la blockchain**  
  Chaque contenu est enregistré sur la chaîne et signé avec la clé cryptographique de l'auteur. Cela garantit l'authenticité et permet de faire confiance au fait que la publication provient réellement de l'auteur déclaré.

- **Stockage décentralisé avec IPFS**  
  Le contenu est stocké dans le système de fichiers interplanétaire plutôt que dans la base de données d'une seule entreprise. Cela élimine les points de défaillance uniques et rend le système plus résilient.

Ensemble, la blockchain et l'IPFS forment un nouveau type de réseau social : un réseau sans contrôle centralisé, sans entreprise unique derrière lui, et sans point de pression pouvant être exploité.


## À propos de cette documentation

Ceci est une **documentation pour développeurs**, pas une aide pour les utilisateurs finaux.  
SAVVA est open source, et nous encourageons activement les développeurs à forker, étendre et adapter la base de code.  

Ici, vous trouverez :

- Les **principes fondamentaux** derrière l'architecture.  
- Comment les **interfaces et les API** sont structurées.  
- Les meilleures pratiques pour étendre et intégrer la plateforme.

Si vous êtes un développeur explorant SAVVA, c'est l'endroit où commencer. 🚀
</file>

<file path="public/dev_docs/ru/core-concepts/app-init.md">
# Инициализация приложения и подключение к бэкенду

## Что такое бэкенд SAVVA (узел SAVVA)?
Бэкенд SAVVA — это серверный компонент, который **индексирует/кэширует данные, полученные из активности блокчейна**, и предоставляет быстрые, удобные для пользователя API и методы WebSocket. Один бэкенд может обслуживать **несколько доменов SAVVA** — рассматривайте "домен" как отдельную социальную сеть SAVVA (брендинг, вкладки, активы, настройки по умолчанию), все поддерживаемые одним узлом.

## Что нужно приложению при запуске
При старте веб-приложению нужны два входных параметра:

1. **URL бэкенда** — базовый URL бэкенда SAVVA.
2. **Имя домена** — какой домен SAVVA (социальная сеть) отображать по умолчанию.

Настройки по умолчанию берутся из небольшого YAML-файла в корне веб-приложения:

### `/default_connect.yaml`
```yaml
# /default_connect.yaml
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
# опционально:
# default_ipfs_link: ipfs://bafy.../something.json
```

* `backendLink` — базовая HTTP-точка доступа бэкенда SAVVA (приложение нормализует её).
* `domain` — начальный домен для отображения; его можно изменить позже в интерфейсе.
* `gear` — включает инструменты разработчика в интерфейсе (опционально).
* `default_ipfs_link` — опциональная настройка по умолчанию, используемая в некоторых потоках.

> **Примечание для продакшена**
> В продакшене этот файл обычно обслуживается вашим HTTP-сервером (например, Nginx) и фактически **выбирает, какой домен** веб-приложение показывает по умолчанию. Один из распространенных подходов — обслуживать конкретный файл с диска:
>
> ```nginx
> # пример: обслуживать статический default_connect.yaml
> location = /default_connect.yaml {
>   default_type text/yaml;
>   alias /etc/savva/default_connect.yaml;
> }
> ```
>
> Настройте под вашу инфраструктуру; ключевым моментом является то, что приложение может `GET /default_connect.yaml`.

---

## Последовательность загрузки

1. **Загрузить `/default_connect.yaml`**
   Приложение загружает YAML-файл, проверяет `backendLink` и сохраняет `domain`. Оно немедленно **настраивает конечные точки** (базовый HTTP + URL WS), используя эти значения. &#x20;

2. **Настроить конечные точки**

   * `httpBase` — нормализованная версия `backendLink` (гарантированная завершающая косая черта).
   * URL `ws` выводится из той же базы, указывая на `.../ws` (протокол переключается на `ws:` или `wss:`) и включает `?domain=...` в запросе.
     Это сохраняет **один источник правды** как для HTTP, так и для WS.&#x20;

3. **Получить `/info`**
   С установленными конечными точками приложение вызывает `GET <httpBase>info` и сохраняет JSON. С этого момента **/info управляет поведением во время выполнения** (домены, цепочка, IPFS, активы).&#x20;

4. **Вывести состояние во время выполнения из `/info`**
   Используются следующие поля (см. пример ниже):

   * **`domains`** → Список доступных доменов. Интерфейс предпочитает явный `domain` из YAML/переопределения; если он отсутствует в `/info`, он все равно используется.&#x20;
   * **`blockchain_id`** → Целочисленный ID целевой цепи EVM. Помощник кошелька может переключать/добавлять эту сеть.&#x20;
   * **`ipfs_gateways`** → Удаленные IPFS-шлюзы, которые следует попробовать в порядке (если не включен локальный IPFS-переопределитель).&#x20;
   * **`assets_url`** и **`temp_assets_url`** → Базовые **активы** (продакшн против теста). Приложение вычисляет **префикс активов активного домена** как
     `(<assets base> + <domain> + "/")` с **резервным вариантом** на `/domain_default/`, если удаленный `config.yaml` отсутствует. &#x20;

5. **Загрузить активы домена и конфигурацию**
   Приложение пытается `(<active prefix>/config.yaml)` с коротким тайм-аутом; в случае неудачи оно переходит к пакету по умолчанию в `/domain_default/config.yaml`. Полученная разобранная конфигурация (логотипы, вкладки, локали и т. д.) сохраняется, и интерфейс отображается соответственно.&#x20;

6. **Время выполнения WebSocket**
   Клиент WS использует вычисленный `ws` URL из конечных точек; когда бэкенд/домен изменяются, конечные точки пересчитываются, и уровень WS подхватывает это.&#x20;

---

## Пример `/info` (иллюстративный)

```json
{
  "domains": [
    "savva.app",
    {"name": "art.savva"},
    "dev.savva"
  ],
  "blockchain_id": 369,
  "ipfs_gateways": [
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/"
  ],
  "assets_url": "https://cdn.savva.network/assets/",
  "temp_assets_url": "https://cdn.savva.network/assets-test/"
}
```

### Поле за полем (что приложение с ним делает)

* **domains** — список выбираемых доменов. Диалог **Переключить бэкенд / домен** заполняется из `/info`, но настроенный домен все равно имеет приоритет, если `/info` устарело. &#x20;
* **blockchain\_id** — числовой ID цепи EVM; используется для построения метаданных `switch/add chain` и для обеспечения того, чтобы кошелек находился в **требуемой сети**. &#x20;
* **ipfs\_gateways** — упорядоченный список удаленных шлюзов; комбинируется с опциональным **Локальным IPFS** переопределителем (когда включен в настройках), чтобы сформировать **активный** порядок шлюзов.&#x20;
* **assets\_url / temp\_assets\_url** — приложение поддерживает **среду активов** (`prod`/`test`) и выбирает соответствующую базу. Затем оно вычисляет `/<base>/<domain>/` и загружает `config.yaml`. Если удаленный пакет отсутствует или медленный, используется **резервный** `/domain_default/`.&#x20;

---

## Где это находится в коде (для быстрого справочника)

* Загрузка и `/default_connect.yaml`, затем `/info`: **`src/context/AppContext.jsx`** и **`src/hooks/useConnect.js`**. &#x20;
* Источник конечных точек (базовый HTTP + URL WS): **`src/net/endpoints.js`**.&#x20;
* Разрешение списка доменов, ID цепи, IPFS-шлюзы, загрузка среды активов и активов домена: **`src/context/AppContext.jsx`**.  &#x20;
* Диалог переключения, который получает `/info` и нормализует `domains`: **`src/components/SwitchConnectDialog.jsx`**.&#x20;

---

**Далее:** в следующей главе мы разберем **конфигурацию домена** (`config.yaml`) и то, как она управляет логотипами, вкладками, локалями и другими поведениями интерфейса для каждого домена.
</file>

<file path="public/dev_docs/ru/core-concepts/auth.md">
# Поток авторизации Web3

Платформа SAVVA использует метод аутентификации Web3 без пароля. Пользователи могут "войти", используя любой совместимый с EVM кошелек, просто подписав уникальное сообщение, предоставленное сервером. Этот процесс подтверждает право собственности на адрес и устанавливает безопасную сессию, управляемую куки браузера.

## Обзор потока

Процесс авторизации включает последовательность шагов, организованных между фронтендом, кошельком пользователя, блокчейном и бэкендом SAVVA.

1.  **Подготовка уникального сообщения**: Фронтенд создает уникальное сообщение для подписания пользователем. Это сообщение состоит из двух частей: динамического значения из смарт-контракта и статического значения из бэкенда.
2.  **Пользователь подписывает сообщение**: Кошелек пользователя (например, MetaMask) предлагает подписать подготовленное сообщение.
3.  **Аутентификация на бэкенде**: Фронтенд отправляет адрес пользователя и полученную подпись на конечную точку `/auth` бэкенда.
4.  **Кука сессии**: Если подпись действительна, бэкенд отвечает заголовком `Set-Cookie`, устанавливая аутентифицированную сессию.
5.  **Аутентифицированные запросы**: Все последующие API и WebSocket запросы из браузера теперь автоматически будут включать эту куку, идентифицируя пользователя.
6.  **Получение профиля пользователя**: После аутентификации фронтенд делает WebSocket вызов к `/get-user`, чтобы получить полные данные профиля пользователя, такие как его аватар и имя.

---

## Пошаговая реализация

### 1. Подготовка сообщения для подписания

Чтобы предотвратить атаки повторного воспроизведения и обеспечить уникальность каждого запроса на вход, сообщение для подписания создается из двух источников:

-   Динамическая строка **`auth_modifier`**, считываемая из смарт-контракта `UserProfile`.
-   Статическая строка **`auth_text_to_sign`**, предоставленная конечной точкой `/info` бэкенда.

Сначала фронтенд вызывает функцию `getString` на контракте `UserProfile`:

```javascript
// Из: src/blockchain/auth.js

// Получить экземпляр контракта UserProfile
const userProfileContract = await getSavvaContract(app, 'UserProfile');

// Подготовить аргументы для вызова контракта
const domainHex = toHexBytes32(""); // Домен пуст для глобального модификатора
const keyHex = toHexBytes32("auth_modifier");

// Получить модификатор (возвращает строку в формате bytes32 hex)
const modifierHex = await userProfileContract.read.getString([
  account,      // Адрес пользователя
  domainHex,    // bytes32 представление ""
  keyHex        // bytes32 представление "auth_modifier"
]);

// Преобразовать шестнадцатеричное значение в читаемую строку
const modifierString = hexToString(modifierHex, { size: 32 });
```

Затем он объединяет эту `modifierString` с текстом из `/info`:

```javascript
// Получить текст из уже загруженного ответа /info
const textToSign = app.info().auth_text_to_sign;

// Объединить в требуемом порядке
const messageToSign = textToSign + modifierString;
```

### 2\. Подписание с помощью кошелька

Используя `viem`, фронтенд запрашивает подпись пользователя для объединенного сообщения. Это действие открывает запрос в кошельке пользователя.

```javascript
// Из: src/blockchain/auth.js

const walletClient = createWalletClient({
  chain: app.desiredChain(),
  transport: custom(window.ethereum)
});

const signature = await walletClient.signMessage({
  account,
  message: messageToSign,
});
```

Полученная `signature` — это длинная шестнадцатеричная строка (например, `0x...`).

### 3\. Аутентификация на бэкенде

Затем фронтенд делает `GET` запрос к конечной точке `/auth`, отправляя адрес пользователя, домен и новую подпись в качестве параметров запроса.

**Критически важно**, чтобы запрос `fetch` включал опцию **`credentials: 'include'`**. Это говорит браузеру обработать заголовок `Set-Cookie` в ответе, что необходимо для установления сессии.

```javascript
// Из: src/blockchain/auth.js

const authUrl = new URL(`${httpBase()}auth`);
authUrl.searchParams.set('user_addr', checksummedAccount);
authUrl.searchParams.set('domain', currentDomain);
authUrl.searchParams.set('signature', signature);

const authRes = await fetch(authUrl.toString(), { credentials: 'include' });
```

Если запрос успешен, ответ бэкенда будет включать заголовок, похожий на этот:

```
Set-Cookie: auth=...; Path=/; HttpOnly; Secure; SameSite=Lax
```

### 4\. Выполнение аутентифицированных API вызовов

С установленной кукой в браузере последующие API вызовы (например, проверка прав администратора) также должны включать **`credentials: 'include'`**, чтобы гарантировать, что кука отправляется с запросом.

```javascript
// Из: src/blockchain/auth.js

const isAdminUrl = new URL(`${httpBase()}is-admin`);
isAdminUrl.searchParams.set('address', checksummedAccount);
isAdminUrl.searchParams.set('domain', currentDomain);

const adminRes = await fetch(isAdminUrl.toString(), { credentials: 'include' });
const isAdminData = await adminRes.json(); // например, {"result":"ok","admin":true}
const isAdmin = !!isAdminData?.admin;
```

### 5\. Получение профиля пользователя (через WebSocket)

Браузер автоматически отправляет куку авторизации во время обновления соединения WebSocket. После успешного входа функция `login` приложения делает `wsCall` к методу `get-user`, чтобы получить полный профиль пользователя.

```javascript
// Из: src/context/useAppAuth.js (в функции login)

const userProfile = await getWsApi().call('get-user', {
  domain: coreUserData.domain,
  user_addr: checksummedAccount,
});
```

Пример ответа от `/get-user` может выглядеть так:

```json
{
  "name": "alexna",
  "avatar": "QmbXwxPzs2veVYFbm7yybfK3rBMxEebuhAcWh3tuKdDTbq?filename=.png",
  "staked": 42529097734827650000000000,
  "n_followers": 9,
  "banned": false
}
```

-----

## Хранение сессии

Финальный объект пользователя, который является комбинацией основных данных (`address`, `domain`, `isAdmin`) и профиля, полученного из `/get-user`, хранится в глобальном `AppContext` и сохраняется в `localStorage`. Это позволяет автоматически восстанавливать сессию, когда пользователь повторно посещает приложение.

## Процесс выхода

Процесс выхода отменяет эти шаги:

1.  `POST` запрос отправляется на конечную точку API `/logout`, чтобы аннулировать серверную сессию и очистить куку.
2.  Данные пользователя удаляются из глобального состояния и `localStorage`.
3.  Соединение WebSocket принудительно `переподключается`, устанавливая новую, неаутентифицированную сессию.

-----

## Справочник по коду

  - **Основная организация**: `src/blockchain/auth.js`
  - **Управление состоянием и поток после входа**: `src/context/useAppAuth.js`
</file>

<file path="public/dev_docs/ru/core-concepts/config-contract.md">
# Контракт Конфигурации

Умный контракт `Config` служит центральным, ончейн реестром для всех глобальных параметров системы на платформе SAVVA. Рассматривайте его как децентрализованное хранилище ключ-значение, которое управляет поведением всех других контрактов в экосистеме.

Критической особенностью платформы SAVVA является то, что контракт `Config` контролируется контрактом `Governance`. Это означает, что любой параметр может быть изменен через голосование сообщества. Держатели токенов могут создавать предложения и голосовать за корректировку сборов, сроков и других основных механизмов, что делает платформу действительно управляемой сообществом.

---

## Как это работает

Параметры хранятся и извлекаются с использованием ключей `bytes32`. Фронтенд абстрагирует это, предоставляя вспомогательную функцию `getConfigParam`, которая преобразует читаемые человеком имена (например, "min_staked_to_post") в требуемый ончейн формат.

Контракт имеет разные функции для извлечения значений в зависимости от их типа данных, в основном `getUInt` для числовых значений и `getAddr` для адресов контрактов. Фронтенд автоматически выбирает правильную функцию в зависимости от имени параметра.

---

## Глобальные параметры

Следующая таблица содержит подробности о глобальных параметрах, которые в настоящее время управляются контрактом `Config`.

| Название | Тип | Единицы | Описание |
| --- | --- | --- | --- |
| `authorShare` | Uint | проценты * 100 | Доля автора в фонде контента (например, 100 = 1%). |
| `nftOwnerCut` | Uint | проценты * 100 | Доля владельца NFT в процентах * 100 (например, 100 = 1%). |
| `minContribution` | Uint | SAVVA | Минимальный взнос в фонд контента в токенах SAVVA. |
| `timeForRound` | Uint | секунды | Длительность раунда фонда контента в секундах. |
| `winnerShare` | Uint | проценты | Доля приза раунда в фонде в процентах. |
| `minFundToShare` | Uint | SAVVA | Минимальная сумма фонда, необходимая для распределения призов, в токенах SAVVA. |
| `staking_withdraw_delay` | Uint | секунды | Период охлаждения для стейкинга в секундах. |
| `contentNFT_mintPrice` | Uint | PLS | Цена на создание NFT контента. |
| `pulsex_slippage` | Uint | проценты | Допустимое проскальзывание для обменов PulseX (резерв/минимальная сумма). |
| `min_staked_to_post` | Uint | SAVVA | Минимальная сумма стейкинга SAVVA, необходимая для публикации контента. |
| `sac_min_deposit` | Uint | PLS | Минимальный депозит для фазы жертвы. |
| `patron_payment_period` | Uint | секунды | Длительность периода платежей патрона в секундах. |
| `gov_proposal_price` | Uint | PLS | Цена на создание нового предложения по управлению. |
| `nft_auction_max_duration` | Uint | секунды | Максимальная длительность аукциона NFT в секундах. |
| `nft_auction_min_increment` | Uint | проценты | Минимальное увеличение ставки для аукциона NFT в процентах. |
| `nft_auction_max_increment` | Uint | проценты | Максимальное увеличение ставки для аукциона NFT в процентах. |
| `min_staked_for_nft_auction`| Uint | SAVVA | Минимальная сумма стейкинга SAVVA, необходимая для создания аукциона NFT. |
| `authorsClubsGainReceiver` | Address | | Адрес, который получает доходы от стейкинга из Клубов авторов. |
| `min_staked_for_fundrasing` | Uint | SAVVA | Минимальная сумма стейкинга SAVVA, необходимая для создания сбора средств. |
| `fundraising_bb_fee` | Uint | проценты * 100 | Комиссия на выкуп для сборов средств в процентах * 100 (например, 100 = 1%). |
| `contract_savvaToken` | Address | | Адрес контракта токена SAVVA. |
| `contract_randomOracle` | Address | | Адрес контракта случайного оракула (0 для отсутствия). |
| `contract_staking` | Address | | Адрес контракта стейкинга. |
| `contract_userProfile` | Address | | Адрес контракта профиля пользователя. |
| `contract_contentNFT` | Address | | Адрес контракта NFT контента. |
| `contract_contentFund` | Address | | Адрес контракта фонда контента. |
| `contract_governance` | Address | | Адрес контракта управления. |
| `contract_contentRegistry` | Address | | Адрес контракта реестра контента. |
| `contract_savvaFaucet` | Address | | Адрес контракта крана SAVVA. |
| `contract_nftMarketplace` | Address | | Адрес контракта рынка NFT. |
| `contract_promo` | Address | | Адрес контракта промо. |
| `contract_buyBurn` | Address | | Адрес контракта Buy & Burn. |
| `contract_listMarket` | Address | | Адрес контракта рынка списков. |
| `contract_authorOfTheMonth` | Address | | Адрес контракта Автора месяца. |
| `pulsex_factory` | Address | | Контракт фабрики PulseX для Buy & Burn. |
| `pulsex_router` | Address | | Контракт маршрутизатора PulseX для Buy & Burn. |
| `WPLS` | Address | | Адрес контракта Wrapped PLS (WPLS). |
</file>

<file path="public/dev_docs/ru/core-concepts/domain.md">
# Работа с доменами

**Домен** — это просто название социальной сети, которую вы хотите отобразить. Обычно это DNS-хост сайта (например, `savva.app`), но это не обязательно. У каждого домена есть **пакет домена** — папка, содержащая `config.yaml` и все специфические для домена ресурсы (логотипы, фавиконы, локали, конфигурация вкладок, необязательный `domain.css` и т. д.).

## Где находится `config.yaml`?

Во время выполнения приложение вычисляет **базовый URL ресурсов** из `/info`:
- **Продакшн:** `assets_url`
- **Тест:** `temp_assets_url`

Активная среда — это простой переключатель продакшн/тест в приложении (используется администраторами для тестирования изменений). Учитывая **выбранное имя домена**, приложение строит префикс:

```

<assetsBase>/<domain>/

```

Затем приложение пытается загрузить:

```

<assetsBase>/<domain>/config.yaml

```

Если это не удается (пакет отсутствует, 404 и т. д.), интерфейс **возвращается** к встроенному пакету по умолчанию:

```

/domain\_default/config.yaml

```

> Этот поиск и диагностика централизованы; вы увидите те же пути в интерфейсе диагностики.  
> Активный `domain.css` загружается из того же префикса и кэшируется с помощью ключа ревизии, так что изменения применяются немедленно после загрузки.

## Почему две среды (продакшн / тест)?

Сервер предоставляет два базовых URL для ресурсов:

- **`assets_url`** → пакет продакшн для конечных пользователей  
- **`temp_assets_url`** → тестовый пакет для предварительного просмотра изменений

Администратор (как настроено на сервере) может загрузить измененный пакет домена под **тест** и проверить все (логотипы, вкладки, GA, цвета) без влияния на пользователей. Когда все устраивает, он публикует тот же пакет в **продакшн**.

## Структура пакета домена

Все для домена находится в одной папке:

```

<assetsBase>/<domain>/
config.yaml          # основная конфигурация (логотипы, фавиконы, локали, модули)
domain.css           # необязательные переменные темы (цвета, фоны)
i18n/*.yaml          # языковые словари (по локалям)
images/*             # ресурсы брендинга
modules/tabs.yaml    # определение вкладок для главного экрана
modules/*.yaml       # другие конфигурации модулей (необязательно)
html/*.html          # произвольные HTML-блоки (необязательно)

````

## Пример `config.yaml`

Ниже приведен сокращенный пример, показывающий типичные поля, которые использует приложение:

```yaml
logo:
  light: images/logo_light.png
  dark: images/logo_dark.png
  light_mobile: images/logo_light.png
  dark_mobile: images/logo_dark.png

favicon:
  apple-touch-icon: favicon/apple-touch-icon.png
  16: favicon/favicon-16x16.png
  32: favicon/favicon-32x32.png
  manifest: favicon/site.webmanifest
  mask-icon:
    href: favicon/safari-pinned-tab.svg
    color: '#5bbad5'
  base: favicon/favicon.ico
  meta:
    - name: msapplication-TileColor
      content: '#da532c'
    - name: theme-color
      content: '#ffffff'

GA_tag: G-XXXXXXXXXX   # ID Google Analytics (gtag)

modules:
  tabs: modules/tabs.yaml
  content_lists: modules/content_lists.yaml
  staker_levels: modules/staker_levels.yaml
  categories: modules/categories.yaml

default_locale: en
locales:
  - code: en
    name: English
    title: 'SAVVA.APP - Beyond Likes Social'
    dictionary: i18n/en.yaml
  - code: ru
    name: Русский
    title: 'SAVVA.APP - За пределами лайков'
    dictionary: i18n/ru.yaml
````

### Что контролируют эти поля

* **`logo`** — Приложение автоматически выбирает лучший вариант (темный/светлый + мобильный/десктопный) и разрешает через активный префикс домена.
* **`favicon`** — Все ссылки на фавиконы и мета-теги применяются динамически; когда конфигурация изменяется, приложение заменяет набор `<link rel="icon">`.
* **`GA_tag`** — Включает Google Analytics (gtag.js). Когда он присутствует, приложение внедряет скрипты GA и отправляет события SPA `page_view` при изменениях маршрута.
* **`modules.tabs`** — Указывает на YAML, который определяет вкладки на главном экране (см. ниже).
* **`locales`** — Список языков для домена (код/имя/название + путь к словарю). Приложение может отображать локализованные названия/строки для каждого домена.

## Вкладки на главном экране

Вкладки настраиваются в отдельном YAML (ссылаясь на `modules.tabs` выше). Например:

```yaml
# modules/tabs.yaml
tabs:
  - type: leaders
    title:
      en: Leaders
      ru: Лидеры
    right_panel:
      available: true
      blocks:
        - type: html
          en: /html/info_block_en.html
          ru: /html/info_block_ru.html
        - type: content_List
          list_name: main
          count: 7

  - type: new
    title:
      en: New
      ru: Новое
```

Интерфейс выбирает локализованное название вкладки, выбирает иконку по `type` и отображает необязательные блоки правой панели. Этот файл находится в **той же папке домена**, поэтому он версионируется и предварительно просматривается вместе с `config.yaml`.

## Цвета темы через `domain.css`

Если присутствует, `domain.css` загружается из того же префикса домена и применяется во время выполнения. Обычно он определяет пользовательские CSS-свойства, которые использует интерфейс (фоны, передний план, акценты, границы и т. д.). Переключение **домена** или **среды** перезагружает этот CSS, так что администраторы могут тонко настраивать брендинг без пересборки приложения.

Пример переменных:

```css
:root {
  --gradient: linear-gradient(to top left, #000c40, #607d8b);
  --background: 243 100% 98.26%;
  --foreground: 243 10% 0.52%;
  --muted: 243 10% 91.3%;
  --muted-foreground: 243 5% 41.3%;
  --primary: 243 100% 13%;
  --primary-foreground: 243 2% 98%;
  /* ... */
}
```

## Google Analytics (GA)

Установите `GA_tag` в `config.yaml`, чтобы включить GA. Приложение автоматически внедряет скрипт GA и инициализирует `gtag(...)`, а также отслеживает просмотры страниц при изменениях хэш-маршрутов. Удалите или очистите `GA_tag`, чтобы отключить аналитику для домена.

---

### Резюме

* Приложение выбирает **продакшн** или **тест** базу ресурсов, затем загружает `<base>/<domain>/config.yaml` с безопасным резервным копированием на `/domain_default/config.yaml`.
* **Все** ресурсы домена (логотипы, локали, вкладки, `domain.css`) находятся в одной папке для атомарных обновлений.
* Администраторы могут предварительно просматривать изменения в **тесте** перед публикацией в **продакшн**.
* `config.yaml` контролирует брендинг (логотипы, фавиконы), локализацию, GA и где найти модули интерфейса, такие как **вкладки**.
</file>

<file path="public/dev_docs/ru/core-concepts/index.md">
<!-- public/dev_docs/ru/core-concepts/index.md -->
# Основные концепции

В этом разделе рассматривается основная архитектура приложения SAVVA SolidJS: как оно подключается к бэкенду, как работают домены и активы, как пользовательский интерфейс управляется конфигурацией по доменам и многое другое.

Что мы рассмотрим:

- Как приложение запускается и находит правильный бэкенд и домен
- Как `/info` управляет поведением во время выполнения (домены, идентификатор цепочки, шлюзы IPFS, активы)
- Как разрешаются активы домена и когда используется пакет по умолчанию
</file>

<file path="public/dev_docs/ru/core-concepts/publishing-posts.md">
# Публикация поста

Публикация контента на платформе SAVVA — это трехступенчатый процесс, который обеспечивает целостность данных, децентрализацию и проверку в блокчейне. Процесс включает в себя подготовку данных поста локально, загрузку контента и его дескриптора в IPFS, а затем регистрацию поста в блокчейне через вызов смарт-контракта.

Фронтенд-редактор автоматизирует этот процесс через мастер, но понимание основных шагов имеет решающее значение для разработчиков.

---

## Шаг 1: Подготовка данных поста

Перед любой загрузкой или транзакцией редактор организует пост в стандартизированную структуру каталогов. Эта структура управляется локально с использованием API файловой системы.

Основные компоненты:

* Файл параметров (`params.json`) для настроек, специфичных для редактора.
* Файл дескриптора (`info.yaml`), который определяет структуру поста и метаданные для IPFS.
* Markdown файлы для контента на каждом языке.
* Директория `uploads/` для любых связанных медиафайлов (изображений, видео и т. д.).

### Пример `params.json`

Этот файл содержит настройки, используемые пользовательским интерфейсом редактора, и не публикуется в блокчейне.

```json
{
  "guid": "c4a7f6b9-6e3e-4b9e-8b1e-2e4a6d7c8b9a",
  "nsfw": false,
  "fundraiser": 0,
  "publishAsNewPost": true,
  "locales": {
    "en": {
      "tags": ["децентрализация", "социальные"],
      "categories": ["Технологии"],
      "chapters": [
        { "title": "Что такое блокчейн?" },
        { "title": "IPFS и адресация контента" }
      ]
    }
  },
  "thumbnail": "uploads/thumbnail.png"
}
```

### Пример `info.yaml` (Дескриптор поста)

Этот файл является каноническим определением поста и загружается в IPFS. Он связывает все части контента вместе.

```yaml
savva_spec_version: "2.0"
data_cid: bafybeih...
gateways:
  - https://ipfs.io/
locales:
  en:
    title: "Понимание децентрализованных систем"
    text_preview: "Глубокое погружение в основные концепции децентрализации..."
    data_path: "en/data.md"
    chapters:
      - data_path: "en/chapters/1.md"
      - data_path: "en/chapters/2.md"
```

* **data\_cid**: CID IPFS директории, содержащей весь Markdown контент и загруженные файлы.
* **locales**: Содержит метаданные, специфичные для языка. Заголовок и текст\_предварительный просмотр из редактора хранятся здесь.
* **data\_path / chapters.data\_path**: Относительные пути к файлам контента в директории `data_cid`.

---

## Шаг 2: Загрузка в IPFS

Процесс загрузки происходит в два отдельных этапа, которые обрабатываются API хранения на бэкенде.

1. **Загрузка директории контента**: Все файлы контента (например, `en/data.md`, `en/chapters/1.md`, `uploads/thumbnail.png`) загружаются как одна директория в IPFS. Бэкенд возвращает единственный CID IPFS для этой директории, который становится `data_cid`.
2. **Загрузка дескриптора**: Файл `info.yaml` генерируется с `data_cid` из предыдущего шага. Этот YAML файл затем загружается в IPFS как отдельный файл. CID этого файла `info.yaml` является окончательным указателем IPFS для поста.

---

## Шаг 3: Регистрация в блокчейне

Последний шаг — записать пост в блокчейн, вызвав функцию `reg` на смарт-контракте `ContentRegistry`.

Фронтенд выполняет эту транзакцию с следующими параметрами:

* **domain**: Текущее имя домена (например, `savva.app`).
* **author**: Адрес кошелька пользователя.
* **guid**: Уникальный идентификатор из `params.json`.
* **ipfs**: CID IPFS файла дескриптора `info.yaml` из Шага 2.
* **content\_type**: Строка `bytes32`, обычно `post` для нового контента или `post-edit` для обновлений.

### Пример вызова контракта

```javascript
// Из: src/components/editor/wizard_steps/StepPublish.jsx

const contract = await getSavvaContract(app, "ContentRegistry", { write: true });

const hash = await contract.write.reg([
  domain,           // "savva.app"
  user.address,     // "0x123..."
  guid,             // "c4a7f6b9-..."
  descriptorCid,    // "bafybeif..."
  toHexBytes32("post")
]);

// Интерфейс пользователя затем ждет подтверждения транзакции
const receipt = await publicClient.waitForTransactionReceipt({ hash });
```

После успешного завершения транзакции пост официально публикуется и появится в контентных лентах.
</file>

<file path="public/dev_docs/ru/getting-started.md">
# Начало работы

Добро пожаловать в руководство **Начало работы** для платформы SAVVA.

Эта страница проведет вас через основные шаги по настройке проекта локально и началу внесения вклада.

## Предварительные требования

Перед тем как начать, убедитесь, что у вас установлены следующие инструменты:

- **Node.js** (рекомендуется версия 18 или выше)  
- Пакетный менеджер **npm** или **yarn**  
- **Git** для клонирования репозитория  
- Современный **браузер** (Chrome, Firefox, Edge) для разработки и тестирования  

## Клонирование репозитория

Исходный код размещен на GitHub. Чтобы получить последнюю версию:

```bash
git clone https://github.com/AlexNa-Holdings/savva-ui-solidjs
cd savva-ui-solidjs
````

## Установка зависимостей

Внутри папки проекта установите все необходимые зависимости:

```bash
npm install
# или
yarn install
```

## Запуск сервера разработки

Запустите сервер разработки с горячей перезагрузкой:

```bash
npm run dev
# или
yarn dev
```

Приложение будет доступно по адресу [http://localhost:5173](http://localhost:5173).

## Сборка для продакшн

Чтобы создать оптимизированную сборку:

```bash
npm run build
```

Вывод будет находиться в папке `dist/`.

## Следующие шаги

* Изучите **Документацию для разработчиков** по архитектуре и модулям.
* Попробуйте переключать домены и ресурсы в **Правой панели**.
* Вносите вклад, открывая проблемы или запросы на изменение на GitHub.

Вот и все! 🎉 Вы готовы начать работу с **платформой SAVVA**.

```html
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SAVVA · SolidJS</title>

  <!-- Предварительная загрузка темы, чтобы избежать мерцания -->
  <script>
    (function () {
      try {
        const saved = localStorage.getItem("theme");
        const systemDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const theme = saved || (systemDark ? "dark" : "light");
        document.documentElement.classList.toggle("dark", theme === "dark");
      } catch { }
    })();
  </script>

  <script>
    (function () {
      // Если есть реальный путь (например, /settings), но нет хеша, перепишите в хеш-форму: /#/settings
      if (!location.hash && location.pathname !== "/") {
        var newHash = "#" + location.pathname + location.search + location.hash;
        history.replaceState(null, "", "/" + newHash);
      }
    })();
  </script>

  <!-- Загружаем приложение после установки класса темы -->
  <script type="module" src="/src/index.jsx"></script>
</head>

<body>
  <div id="root"></div>
</body>

</html>
```
</file>

<file path="public/dev_docs/ru/index.md">
# Документация для разработчиков SAVVA

Добро пожаловать в документацию для разработчиков **платформы SAVVA**.


## Что такое SAVVA?

SAVVA — это **платформа с открытым исходным кодом** для создания социальных сетей следующего поколения.  
В отличие от традиционных платформ, SAVVA сочетает в себе **блокчейн** и **IPFS**, чтобы создать децентрализованный, надежный и устойчивый к цензуре фундамент.

- **Посты, привязанные к блокчейну**  
  Каждый элемент контента регистрируется в блокчейне и подписывается криптографическим ключом автора. Это обеспечивает подлинность и позволяет доверять тому, что пост действительно исходит от заявленного автора.

- **Децентрализованное хранилище с IPFS**  
  Контент хранится в Межпланетной файловой системе, а не в базе данных одной компании. Это устраняет единые точки отказа и делает систему более устойчивой.

Вместе блокчейн и IPFS формируют новый тип социальной сети: без централизованного контроля, без одной компании за ней и без точки давления, которую можно было бы использовать.


## Об этой документации

Это **документация для разработчиков**, а не помощь для конечных пользователей.  
SAVVA является проектом с открытым исходным кодом, и мы активно поощряем разработчиков форкать, расширять и адаптировать кодовую базу.  

Здесь вы найдете:

- **Основные принципы** архитектуры.  
- Как структурированы **интерфейсы и API**.  
- Лучшие практики для расширения и интеграции платформы.

Если вы разработчик, исследующий SAVVA, это место, с которого стоит начать. 🚀
</file>

<file path="public/dev_docs/sr/core-concepts/app-init.md">
# Inicijalizacija aplikacije i povezivanje sa backend-om

## Šta je SAVVA backend (SAVVA čvor)?
SAVVA backend je serverska komponenta koja **indeksira/kešira podatke dobijene iz blockchain aktivnosti** i izlaže brze, UI-prijateljske API-je i WebSocket metode. Jedan backend može služiti **više SAVVA domena**—razmislite o "domeni" kao o posebnoj SAVVA društvenoj mreži (brendiranje, kartice, resursi, podrazumevano), sve podržano jednim čvorom.

## Šta aplikacija treba pri pokretanju
Pri pokretanju web aplikacija su potrebna dva ulaza:

1. **Backend URL** – osnovni URL SAVVA backend-a.
2. **Ime domena** – koji SAVVA domen (društvena mreža) da se prikazuje podrazumevano.

Podrazumevane vrednosti dolaze iz male YAML datoteke na web korenu:

### `/default_connect.yaml`
```yaml
# /default_connect.yaml
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
# opcionalno:
# default_ipfs_link: ipfs://bafy.../something.json
```

* `backendLink` — osnovna HTTP tačka SAVVA backend-a (aplikacija je normalizuje).
* `domain` — inicijalni domen za prikaz; može se promeniti kasnije u UI.
* `gear` — omogućava developerske alate u UI (opcionalno).
* `default_ipfs_link` — opcionalna pogodnost koja se koristi u nekim tokovima.

> **Napomena za proizvodnju**
> U proizvodnji, ova datoteka se obično služi od strane vašeg HTTP servera (npr., Nginx) i efektivno **biraju koji domen** se prikazuje podrazumevano u implementiranoj web aplikaciji. Jedan uobičajen obrazac je da se služi određena datoteka sa diska:
>
> ```nginx
> # primer: služi statičku default_connect.yaml
> location = /default_connect.yaml {
>   default_type text/yaml;
>   alias /etc/savva/default_connect.yaml;
> }
> ```
>
> Prilagodite svojoj infrastrukturi; ključ je da aplikacija može `GET /default_connect.yaml`.

---

## Sekvenca pokretanja

1. **Učitaj `/default_connect.yaml`**
   Aplikacija preuzima YAML datoteku, validira `backendLink` i čuva `domain`. Odmah **konfiguriše tačke** (HTTP osnovu + WS URL) koristeći te vrednosti. &#x20;

2. **Konfiguriši tačke**

   * `httpBase` je normalizovana verzija `backendLink` (garantovano sa završnim slash-om).
   * `ws` URL se izvodi iz iste osnove, ukazujući na `.../ws` (protokol prebačen na `ws:` ili `wss:`) i uključuje `?domain=...` u upitu.
     Ovo održava **jedan izvor istine** za HTTP i WS.&#x20;

3. **Preuzmi `/info`**
   Sa postavljenim tačkama, aplikacija poziva `GET <httpBase>info` i čuva JSON. Od tog trenutka, **/info upravlja ponašanjem u vreme izvođenja** (domeni, lanac, IPFS, resursi).&#x20;

4. **Izvedi stanje u vreme izvođenja iz `/info`**
   Sledeća polja se koriste (vidi primer ispod):

   * **`domains`** → Lista dostupnih domena. UI preferira eksplicitni `domain` iz YAML/override; ako nije prisutan u `/info`, i dalje ga koristi.&#x20;
   * **`blockchain_id`** → ID ciljnog EVM lanca. Pomoćnik za novčanik može prebaciti/dodati ovu mrežu.&#x20;
   * **`ipfs_gateways`** → Udaljeni IPFS gateway-evi koje treba probati redom (osim ako nije omogućena lokalna IPFS prepravka).&#x20;
   * **`assets_url`** i **`temp_assets_url`** → Osnovna **URL adresa resursa** (proizvod vs test). Aplikacija izračunava **aktivni prefiks resursa domena** kao
     `(<assets base> + <domain> + "/")` sa **rezervom** na `/domain_default/` ako je udaljeni `config.yaml` nedostupan. &#x20;

5. **Učitaj resurse domena i konfiguraciju**
   Aplikacija pokušava `(<active prefix>/config.yaml)` sa kratkim vremenskim ograničenjem; u slučaju neuspeha vraća se na podrazumevani paket na `/domain_default/config.yaml`. Rezultantna analizirana konfiguracija (logotipi, kartice, jezici itd.) se čuva i UI se prikazuje u skladu s tim.&#x20;

6. **WebSocket vreme izvođenja**
   WS klijent koristi izračunati `ws` URL iz tačaka; kada se backend/domen promene, tačke se ponovo izračunavaju i WS sloj to preuzima.&#x20;

---

## Primer `/info` (ilustrativno)

```json
{
  "domains": [
    "savva.app",
    {"name": "art.savva"},
    "dev.savva"
  ],
  "blockchain_id": 369,
  "ipfs_gateways": [
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/"
  ],
  "assets_url": "https://cdn.savva.network/assets/",
  "temp_assets_url": "https://cdn.savva.network/assets-test/"
}
```

### Polje po polje (šta aplikacija radi s tim)

* **domains** — lista selektabilnih domena. Dijalog **Prebaci backend / domen** se popunjava iz `/info`, ali konfigurisani domen i dalje ima prioritet ako je `/info` iza. &#x20;
* **blockchain\_id** — numerički EVM ID lanca; koristi se za izgradnju `switch/add chain` metapodataka i za osiguranje da je novčanik na **zahtevanoj mreži**. &#x20;
* **ipfs\_gateways** — uređena lista udaljenih gateway-eva; kombinovana sa opcionalnom **Lokalnom IPFS** prepravkom (kada je omogućena u podešavanjima) da formira **aktivni** redosled gateway-a.&#x20;
* **assets\_url / temp\_assets\_url** — aplikacija održava **okruženje resursa** (`prod`/`test`) i bira odgovarajući osnov. Zatim izračunava `/<base>/<domain>/` i učitava `config.yaml`. Ako udaljeni paket nedostaje ili je spor, koristi **podrazumevani** `/domain_default/`.&#x20;

---

## Gde se ovo nalazi u kodu (za brzu referencu)

* Pokretanje i učitavanje `/default_connect.yaml`, zatim `/info`: **`src/context/AppContext.jsx`** i **`src/hooks/useConnect.js`**. &#x20;
* Izvor tačke istine (HTTP osnovna + WS URL): **`src/net/endpoints.js`**.&#x20;
* Rešavanje liste domena, ID lanca, IPFS gateway-eva, okruženje resursa i učitavanje resursa domena: **`src/context/AppContext.jsx`**.  &#x20;
* Dijalog za prebacivanje koji preuzima `/info` i normalizuje `domains`: **`src/components/SwitchConnectDialog.jsx`**.&#x20;

---

**Sledeće:** u sledećem poglavlju razložićemo **konfiguraciju domena** (`config.yaml`) i kako ona kontroliše logotipe, kartice, jezike i drugo ponašanje UI po domenima.
</file>

<file path="public/dev_docs/sr/core-concepts/auth.md">
# Web3 Authorization Flow

SAVVA platform koristi metodu autentifikacije bez lozinke zasnovanu na Web3. Korisnici se mogu "prijaviti" koristeći bilo koji EVM-kompatibilni novčanik jednostavno potpisujući jedinstvenu poruku koju pruža server. Ovaj proces verifikuje vlasništvo nad adresom i uspostavlja sigurnu sesiju koju upravlja kolačić u pretraživaču.

## Pregled toka

Proces autorizacije uključuje niz koraka koji se orkestriraju između frontend-a, korisničkog novčanika, blockchain-a i SAVVA backend-a.

1.  **Priprema jedinstvene poruke**: Frontend konstruira jedinstvenu poruku koju korisnik treba da potpiše. Ova poruka se sastoji od dva dela: dinamičke vrednosti iz pametnog ugovora i statične vrednosti iz backend-a.
2.  **Korisnik potpisuje poruku**: Korisnik dobija zahtev od svog novčanika (npr. MetaMask) da potpiše pripremljenu poruku.
3.  **Backend autentifikacija**: Frontend šalje korisničku adresu i dobijeni potpis backend-u na `/auth` endpoint.
4.  **Kolačić sesije**: Ako je potpis validan, backend odgovara sa `Set-Cookie` zaglavljem, uspostavljajući autentifikovanu sesiju.
5.  **Autentifikovani zahtevi**: Svi naredni API i WebSocket zahtevi iz pretraživača će sada automatski uključivati ovaj kolačić, identifikujući korisnika.
6.  **Preuzimanje korisničkog profila**: Kada je autentifikovan, frontend pravi WebSocket poziv na `/get-user` da preuzme potpune detalje korisničkog profila, kao što su njihov avatar i ime.

---

## Implementacija korak po korak

### 1. Priprema poruke za potpisivanje

Da bi se sprečili napadi ponovnog korišćenja i osiguralo da je svaki zahtev za prijavu jedinstven, poruka koja treba da se potpiše konstruisana je iz dva izvora:

-   Dinamički **`auth_modifier`** string pročitan iz `UserProfile` pametnog ugovora.
-   Statični **`auth_text_to_sign`** string koji pruža backend na `/info` endpoint.

Frontend prvo poziva `getString` funkciju na `UserProfile` ugovoru:

```javascript
// From: src/blockchain/auth.js

// Dobijanje instance UserProfile ugovora
const userProfileContract = await getSavvaContract(app, 'UserProfile');

// Priprema argumenata za poziv ugovora
const domainHex = toHexBytes32(""); // Domen je prazan za globalni modifikator
const keyHex = toHexBytes32("auth_modifier");

// Preuzimanje modifikatora (vraća bytes32 hex string)
const modifierHex = await userProfileContract.read.getString([
  account,      // Korisnička adresa
  domainHex,    // bytes32 reprezentacija ""
  keyHex        // bytes32 reprezentacija "auth_modifier"
]);

// Konvertovanje hex vrednosti u čitljiv string
const modifierString = hexToString(modifierHex, { size: 32 });
```

Zatim kombinuje ovaj `modifierString` sa tekstom sa `/info`:

```javascript
// Dobijanje teksta iz već učitanog /info odgovora
const textToSign = app.info().auth_text_to_sign;

// Kombinovanje u potrebnom redosledu
const messageToSign = textToSign + modifierString;
```

### 2\. Potpisivanje sa novčanikom

Koristeći `viem`, frontend zahteva korisnikov potpis za kombinovanu poruku. Ova akcija otvara prozor u korisnikovom novčaniku.

```javascript
// From: src/blockchain/auth.js

const walletClient = createWalletClient({
  chain: app.desiredChain(),
  transport: custom(window.ethereum)
});

const signature = await walletClient.signMessage({
  account,
  message: messageToSign,
});
```

Rezultantni `signature` je dugačak hex string (npr. `0x...`).

### 3\. Autentifikacija sa backend-om

Frontend zatim pravi `GET` zahtev na `/auth` endpoint, šaljući korisničku adresu, domen i novi potpis kao upitne parametre.

**Ključno**, `fetch` zahtev mora uključivati **`credentials: 'include'`** opciju. Ovo govori pretraživaču da obradi `Set-Cookie` zaglavlje u odgovoru, što je od suštinskog značaja za uspostavljanje sesije.

```javascript
// From: src/blockchain/auth.js

const authUrl = new URL(`${httpBase()}auth`);
authUrl.searchParams.set('user_addr', checksummedAccount);
authUrl.searchParams.set('domain', currentDomain);
authUrl.searchParams.set('signature', signature);

const authRes = await fetch(authUrl.toString(), { credentials: 'include' });
```

Ako je uspešno, odgovor backend-a će uključivati zaglavlje slično ovome:

```
Set-Cookie: auth=...; Path=/; HttpOnly; Secure; SameSite=Lax
```

### 4\. Izvršavanje autentifikovanih API poziva

Sa kolačićem sada postavljenim u pretraživaču, naredni API pozivi (kao što je provera admin privilegija) takođe moraju uključivati **`credentials: 'include'`** kako bi se osiguralo da se kolačić šalje sa zahtevom.

```javascript
// From: src/blockchain/auth.js

const isAdminUrl = new URL(`${httpBase()}is-admin`);
isAdminUrl.searchParams.set('address', checksummedAccount);
isAdminUrl.searchParams.set('domain', currentDomain);

const adminRes = await fetch(isAdminUrl.toString(), { credentials: 'include' });
const isAdminData = await adminRes.json(); // npr., {"result":"ok","admin":true}
const isAdmin = !!isAdminData?.admin;
```

### 5\. Preuzimanje korisničkog profila (putem WebSocket-a)

Pretraživač automatski šalje auth kolačić tokom nadogradnje WebSocket veze. Nakon uspešne prijave, aplikacijska `login` funkcija pravi `wsCall` na `get-user` metodu da preuzme puni korisnički profil.

```javascript
// From: src/context/useAppAuth.js (u login funkciji)

const userProfile = await getWsApi().call('get-user', {
  domain: coreUserData.domain,
  user_addr: checksummedAccount,
});
```

Primer odgovora sa `/get-user` može izgledati ovako:

```json
{
  "name": "alexna",
  "avatar": "QmbXwxPzs2veVYFbm7yybfK3rBMxEebuhAcWh3tuKdDTbq?filename=.png",
  "staked": 42529097734827650000000000,
  "n_followers": 9,
  "banned": false
}
```

-----

## Čuvanje sesije

Konačni korisnički objekat, koji je kombinacija osnovnih podataka (`address`, `domain`, `isAdmin`) i profila preuzetog sa `/get-user`, čuva se u globalnom `AppContext` i trajno se čuva u `localStorage`. Ovo omogućava automatsko obnavljanje sesije kada se korisnik ponovo poseti aplikaciju.

## Proces odjave

Proces odjave obrće ove korake:

1.  `POST` zahtev se šalje na `/logout` API endpoint da bi se onemogućila sesija na serveru i obrisao kolačić.
2.  Korisnički podaci se uklanjaju iz globalnog stanja i `localStorage`.
3.  WebSocket veza se prisiljava da `ponovo poveže`, uspostavljajući novu, neautentifikovanu sesiju.

-----

## Referenca koda

  - **Glavna orkestracija**: `src/blockchain/auth.js`
  - **Upravljanje stanjem i post-prijava tok**: `src/context/useAppAuth.js`
</file>

<file path="public/dev_docs/sr/core-concepts/config-contract.md">
# Konfiguracioni Ugovor

`Config` pametan ugovor služi kao centralni, on-chain registar za sve globalne sistemske parametre na SAVVA platformi. Zamislite ga kao decentralizovanu skladišnu jedinicu ključeva i vrednosti koja upravlja ponašanjem svih drugih ugovora u ekosistemu.

Kritična karakteristika SAVVA platforme je da `Config` ugovor kontroliše `Governance` ugovor. To znači da se bilo koji parametar može promeniti putem glasanja zajednice. Vlasnici tokena mogu kreirati predloge i glasati za prilagođavanje taksi, vremenskih okvira i drugih osnovnih mehanizama, čineći platformu zaista vođenom od strane zajednice.

---

## Kako to funkcioniše

Parametri se čuvaju i preuzimaju koristeći `bytes32` ključeve. Frontend to apstrahuje pružanjem pomoćne funkcije, `getConfigParam`, koja konvertuje imena koja su čitljiva ljudima (npr., "min_staked_to_post") u potrebni on-chain format.

Ugovor ima različite funkcije za preuzimanje vrednosti na osnovu njihovog tipa podataka, prvenstveno `getUInt` za numeričke vrednosti i `getAddr` za adrese ugovora. Frontend automatski bira ispravnu funkciju na osnovu imena parametra.

---

## Sistemski Parametri

Sledeća tabela detaljno prikazuje globalne parametre koje trenutno upravlja `Config` ugovor.

| Ime | Tip | Jedinice | Opis |
| --- | --- | --- | --- |
| `authorShare` | Uint | procenat * 100 | Udeo autora u fondu sadržaja (npr., 100 = 1%). |
| `nftOwnerCut` | Uint | procenat * 100 | Udeo vlasnika NFT-a u procentima * 100 (npr., 100 = 1%). |
| `minContribution` | Uint | SAVVA | Minimalni doprinos fondu sadržaja u SAVVA tokenima. |
| `timeForRound` | Uint | sekunde | Trajanje runde fonda sadržaja u sekundama. |
| `winnerShare` | Uint | procenat | Udeo nagrade runde iz fonda u procentima. |
| `minFundToShare` | Uint | SAVVA | Minimalni iznos fonda potreban za deljenje nagrada, u SAVVA tokenima. |
| `staking_withdraw_delay` | Uint | sekunde | Period hlađenja za staking u sekundama. |
| `contentNFT_mintPrice` | Uint | PLS | Cena za mintovanje sadržajnog NFT-a. |
| `pulsex_slippage` | Uint | procenat | Tolerancija na klizanje za PulseX zamene (rezerva/minimalni iznos). |
| `min_staked_to_post` | Uint | SAVVA | Minimalni ulog SAVVA potreban za postavljanje sadržaja. |
| `sac_min_deposit` | Uint | PLS | Minimalni depozit za fazu žrtvovanja. |
| `patron_payment_period` | Uint | sekunde | Trajanje perioda plaćanja donatora u sekundama. |
| `gov_proposal_price` | Uint | PLS | Cena za kreiranje novog predloga za upravljanje. |
| `nft_auction_max_duration` | Uint | sekunde | Maksimalno trajanje za NFT aukciju u sekundama. |
| `nft_auction_min_increment` | Uint | procenat | Minimalno povećanje ponude za NFT aukciju u procentima. |
| `nft_auction_max_increment` | Uint | procenat | Maksimalno povećanje ponude za NFT aukciju u procentima. |
| `min_staked_for_nft_auction`| Uint | SAVVA | Minimalni ulog SAVVA potreban za kreiranje NFT aukcije. |
| `authorsClubsGainReceiver` | Adresa | | Adresa koja prima dobitke od stakinga iz Autorskih klubova. |
| `min_staked_for_fundrasing` | Uint | SAVVA | Minimalni ulog SAVVA potreban za kreiranje prikupljanja sredstava. |
| `fundraising_bb_fee` | Uint | procenat * 100 | Taksa za otkup za prikupljanje sredstava u procentima * 100 (npr., 100 = 1%). |
| `contract_savvaToken` | Adresa | | Adresa ugovora za SAVVA token. |
| `contract_randomOracle` | Adresa | | Adresa ugovora za nasumičnu orakulu (0 za nijednu). |
| `contract_staking` | Adresa | | Adresa ugovora za staking. |
| `contract_userProfile` | Adresa | | Adresa ugovora za korisnički profil. |
| `contract_contentNFT` | Adresa | | Adresa ugovora za sadržajni NFT. |
| `contract_contentFund` | Adresa | | Adresa ugovora za fond sadržaja. |
| `contract_governance` | Adresa | | Adresa ugovora za upravljanje. |
| `contract_contentRegistry` | Adresa | | Adresa ugovora za registar sadržaja. |
| `contract_savvaFaucet` | Adresa | | Adresa ugovora za SAVVA Faucet. |
| `contract_nftMarketplace` | Adresa | | Adresa ugovora za NFT tržište. |
| `contract_promo` | Adresa | | Adresa ugovora za promociju. |
| `contract_buyBurn` | Adresa | | Adresa ugovora za kupovinu i spaljivanje. |
| `contract_listMarket` | Adresa | | Adresa ugovora za tržište lista. |
| `contract_authorOfTheMonth` | Adresa | | Adresa ugovora za autora meseca. |
| `pulsex_factory` | Adresa | | PulseX fabrika ugovora za kupovinu i spaljivanje. |
| `pulsex_router` | Adresa | | PulseX ruter ugovora za kupovinu i spaljivanje. |
| `WPLS` | Adresa | | Adresa ugovora za Wrapped PLS (WPLS). |
</file>

<file path="public/dev_docs/sr/core-concepts/domain.md">
# Rad sa domenama

**Domena** je jednostavno naziv društvene mreže koju želite da prikažete. Obično je to DNS host sajta (npr. `savva.app`), ali ne mora biti. Svaka domena ima **domen paket** — folder koji sadrži `config.yaml` plus sve resurse specifične za domenu (logotipe, favicon, lokalizacije, konfiguraciju tabova, opcioni `domain.css`, itd.).

## Gde se nalazi `config.yaml`?

Tokom izvršavanja, aplikacija izračunava **osnovni URL resursa** iz `/info`:
- **Proizvodnja:** `assets_url`
- **Test:** `temp_assets_url`

Aktivno okruženje je jednostavan prekidač između produkcije i testa u aplikaciji (koji koriste administratori za testiranje promena). S obzirom na **izabrano ime domene**, aplikacija gradi prefiks:

```

<assetsBase>/<domain>/

```

Zatim aplikacija pokušava da učita:

```

<assetsBase>/<domain>/config.yaml

```

Ako to ne uspe (nedostajući paket, 404, itd.), UI **pada nazad** na ugrađeni podrazumevani paket:

```

/domain\_default/config.yaml

```

> Ova pretraga i dijagnostika su centralizovane; videćete iste putanje u dijagnostičkom UI-u.  
> Aktivni `domain.css` se učitava iz istog prefiksa i kešira se sa ključem revizije, tako da se promene primenjuju odmah nakon učitavanja.

## Zašto dva okruženja (proizvodnja / test)?

Backend pruža dva osnovna URL-a za resurse:

- **`assets_url`** → paket za proizvodnju za krajnje korisnike  
- **`temp_assets_url`** → test paket za pregled promena

Administrator (kako je podešeno u backendu) može da gurne izmenjeni domen paket pod **test** osnovu i da proveri sve (logotipe, tabove, GA, boje) bez uticaja na korisnike. Kada su zadovoljni, objavljuju isti paket u **proizvodnju**.

## Raspored domen paketa

Sve za domenu se nalazi u jednom folderu:

```

<assetsBase>/<domain>/
config.yaml          # glavna konfiguracija (logotipi, favicon, lokalizacije, moduli)
domain.css           # opcione teme varijable (boje, pozadine)
i18n/*.yaml          # jezički rečnici (po lokalizaciji)
images/*             # resursi za brendiranje
modules/tabs.yaml    # definicija tabova za glavni ekran
modules/*.yaml       # druge konfiguracije modula (opciono)
html/*.html          # proizvoljni HTML blokovi (opciono)

````

## Primer `config.yaml`

Ispod je skraćeni primer koji prikazuje tipična polja koja aplikacija koristi:

```yaml
logo:
  light: images/logo_light.png
  dark: images/logo_dark.png
  light_mobile: images/logo_light.png
  dark_mobile: images/logo_dark.png

favicon:
  apple-touch-icon: favicon/apple-touch-icon.png
  16: favicon/favicon-16x16.png
  32: favicon/favicon-32x32.png
  manifest: favicon/site.webmanifest
  mask-icon:
    href: favicon/safari-pinned-tab.svg
    color: '#5bbad5'
  base: favicon/favicon.ico
  meta:
    - name: msapplication-TileColor
      content: '#da532c'
    - name: theme-color
      content: '#ffffff'

GA_tag: G-XXXXXXXXXX   # Google Analytics (gtag) ID

modules:
  tabs: modules/tabs.yaml
  content_lists: modules/content_lists.yaml
  staker_levels: modules/staker_levels.yaml
  categories: modules/categories.yaml

default_locale: en
locales:
  - code: en
    name: English
    title: 'SAVVA.APP - Beyond Likes Social'
    dictionary: i18n/en.yaml
  - code: ru
    name: Русский
    title: 'SAVVA.APP - За пределами лайков'
    dictionary: i18n/ru.yaml
````

### Šta ova polja kontrolišu

* **`logo`** — Aplikacija automatski bira najbolju varijantu (tamnu/svetlu + mobilnu/desktop) i rešava putem aktivnog prefiksa domene.
* **`favicon`** — Sve favicon veze i meta tagovi se dinamički primenjuju; kada se konfiguracija promeni, aplikacija zamenjuje set `<link rel="icon">`.
* **`GA_tag`** — Omogućava Google Analytics (gtag.js). Kada je prisutan, aplikacija ubacuje GA skripte i šalje SPA `page_view` događaje prilikom promena rute.
* **`modules.tabs`** — Ukazuje na YAML koji definiše tabove na glavnom ekranu (vidi ispod).
* **`locales`** — Lista jezika za domenu (kod/naziv/naslov + putanja rečnika). Aplikacija može da prikaže lokalizovane naslove/stringove po domeni.

## Tabovi na glavnom ekranu

Tabovi su konfigurirani u samostalnom YAML-u (na koji se poziva `modules.tabs` iznad). Na primer:

```yaml
# modules/tabs.yaml
tabs:
  - type: leaders
    title:
      en: Leaders
      ru: Лидеры
    right_panel:
      available: true
      blocks:
        - type: html
          en: /html/info_block_en.html
          ru: /html/info_block_ru.html
        - type: content_List
          list_name: main
          count: 7

  - type: new
    title:
      en: New
      ru: Новое
```

UI bira lokalizovani naslov taba, bira ikonu prema `type`, i prikazuje opcionale blokove desnog panela. Ova datoteka se nalazi u **istom folderu domene**, tako da je verzionisana i pregledana zajedno sa `config.yaml`.

## Boje teme putem `domain.css`

Ako je prisutan, `domain.css` se preuzima iz istog prefiksa domene i primenjuje u vreme izvršavanja. Obično definiše CSS prilagođene osobine koje UI koristi (pozadine, foreground, akcenti, ivice, itd.). Promena **domene** ili **okruženja** ponovo učitava ovaj CSS, tako da administratori mogu fino podešavati brendiranje bez ponovnog izgradnje aplikacije.

Primer varijabli:

```css
:root {
  --gradient: linear-gradient(to top left, #000c40, #607d8b);
  --background: 243 100% 98.26%;
  --foreground: 243 10% 0.52%;
  --muted: 243 10% 91.3%;
  --muted-foreground: 243 5% 41.3%;
  --primary: 243 100% 13%;
  --primary-foreground: 243 2% 98%;
  /* ... */
}
```

## Google Analytics (GA)

Postavite `GA_tag` u `config.yaml` da omogućite GA. Aplikacija automatski ubacuje GA skriptu i inicijalizuje `gtag(...)`, takođe prati pregleda stranica prilikom promena hash-rute. Uklonite ili obrišite `GA_tag` da onemogućite analitiku za domenu.

---

### Sažetak

* Aplikacija bira **proizvodne** ili **test** osnovne resurse, zatim učitava `<base>/<domain>/config.yaml` sa sigurnim povratkom na `/domain_default/config.yaml`.
* **Svi** resursi domene (logotipi, lokalizacije, tabovi, `domain.css`) se nalaze u istom folderu za atomsku ažuriranja.
* Administratori mogu pregledati promene u **testu** pre objavljivanja u **proizvodnju**.
* `config.yaml` kontroliše brendiranje (logotipe, favicon), lokalizaciju, GA, i gde da pronađe UI module poput **tabova**.
</file>

<file path="public/dev_docs/sr/core-concepts/index.md">
<!-- public/dev_docs/sr/core-concepts/index.md -->
# Osnovni koncepti

Ovaj deo pokriva osnovnu arhitekturu SAVVA SolidJS aplikacije: kako se povezuje sa backend-om, kako funkcionišu domeni i resursi, kako UI zavisi od konfiguracije po domenima, i još mnogo toga.

Šta ćemo obraditi:

- Kako se aplikacija pokreće i pronalazi odgovarajući backend i domen
- Kako `/info` upravlja ponašanjem u vreme izvođenja (domeni, ID lanca, IPFS prolazi, resursi)
- Kako se rešavaju resursi domena i kada se koristi podrazumevani paket
</file>

<file path="public/dev_docs/sr/core-concepts/publishing-posts.md">
# Objavljivanje posta

Objavljivanje sadržaja na SAVVA platformi je trostepeni proces koji osigurava integritet podataka, decentralizaciju i verifikaciju na lancu. Tok procesa uključuje pripremu podataka o postu lokalno, otpremanje sadržaja i njegovog opisa na IPFS, i konačno registraciju posta na blockchainu putem poziva pametnog ugovora.

Frontend uređivač automatizuje ovaj proces kroz čarobnjaka, ali razumevanje osnovnih koraka je ključno za programere.

---

## Korak 1: Priprema podataka o postu

Pre nego što dođe do bilo kakvog otpremanja ili transakcije, uređivač organizuje post u standardizovanu strukturu direktorijuma. Ova struktura se upravlja lokalno koristeći File System API.

Glavne komponente su:

* Datoteka sa parametrima (`params.json`) za podešavanja specifična za uređivač.
* Datoteka sa opisom (`info.yaml`) koja definiše strukturu posta i metapodatke za IPFS.
* Markdown datoteke za sadržaj na svakom jeziku.
* Direktorijum `uploads/` za sve povezane medijske datoteke (slike, video zapisi itd.).

### Primer `params.json`

Ova datoteka sadrži podešavanja koja koristi UI uređivača i ne objavljuje se na lancu.

```json
{
  "guid": "c4a7f6b9-6e3e-4b9e-8b1e-2e4a6d7c8b9a",
  "nsfw": false,
  "fundraiser": 0,
  "publishAsNewPost": true,
  "locales": {
    "en": {
      "tags": ["decentralization", "social"],
      "categories": ["Technology"],
      "chapters": [
        { "title": "Šta je blockchain?" },
        { "title": "IPFS i adresiranje sadržaja" }
      ]
    }
  },
  "thumbnail": "uploads/thumbnail.png"
}
```

### Primer `info.yaml` (Opis posta)

Ova datoteka je kanonska definicija posta i otprema se na IPFS. Ona povezuje sve delove sadržaja zajedno.

```yaml
savva_spec_version: "2.0"
data_cid: bafybeih...
gateways:
  - https://ipfs.io/
locales:
  en:
    title: "Razumevanje decentralizovanih sistema"
    text_preview: "Duboko istraživanje osnovnih koncepata decentralizacije..."
    data_path: "en/data.md"
    chapters:
      - data_path: "en/chapters/1.md"
      - data_path: "en/chapters/2.md"
```

* **data\_cid**: IPFS CID direktorijuma koji sadrži sav Markdown sadržaj i otpremljene datoteke.
* **locales**: Sadrži metapodatke specifične za jezik. Naslov i tekst\_pregled iz uređivača se čuvaju ovde.
* **data\_path / chapters.data\_path**: Relativne putanje do datoteka sa sadržajem unutar `data_cid` direktorijuma.

---

## Korak 2: Otpremanje na IPFS

Proces otpremanja se odvija u dve različite faze, kojima upravlja backend-ov API za skladištenje.

1. **Otpremanje direktorijuma sa sadržajem**: Sve datoteke sa sadržajem (npr., `en/data.md`, `en/chapters/1.md`, `uploads/thumbnail.png`) se otpremaju kao jedan direktorijum na IPFS. Backend vraća jedan IPFS CID za ovaj direktorijum, koji postaje `data_cid`.
2. **Otpremanje opisa**: Datoteka `info.yaml` se generiše sa `data_cid` iz prethodnog koraka. Ova YAML datoteka se zatim otprema na IPFS kao samostalna datoteka. CID ove `info.yaml` datoteke je konačna IPFS referenca za post.

---

## Korak 3: Registracija na blockchainu

Poslednji korak je da se post zabeleži na blockchainu pozivom funkcije `reg` na pametnom ugovoru `ContentRegistry`.

Frontend izvršava ovu transakciju sa sledećim parametrima:

* **domain**: Trenutno ime domena (npr., `savva.app`).
* **author**: Adresa novčanika korisnika.
* **guid**: Jedinstveni identifikator iz `params.json`.
* **ipfs**: IPFS CID datoteke `info.yaml` iz Koraka 2.
* **content\_type**: `bytes32` string, obično `post` za novi sadržaj ili `post-edit` za ažuriranja.

### Primer poziva ugovora

```javascript
// Iz: src/components/editor/wizard_steps/StepPublish.jsx

const contract = await getSavvaContract(app, "ContentRegistry", { write: true });

const hash = await contract.write.reg([
  domain,           // "savva.app"
  user.address,     // "0x123..."
  guid,             // "c4a7f6b9-..."
  descriptorCid,    // "bafybeif..."
  toHexBytes32("post")
]);

// UI zatim čeka da transakcija bude potvrđena
const receipt = await publicClient.waitForTransactionReceipt({ hash });
```

Kada se transakcija uspešno završi, post je zvanično objavljen i pojaviće se u sadržajnim tokovima.
</file>

<file path="public/dev_docs/sr/getting-started.md">
# Uvod

Dobrodošli u **Uvod** vodič za SAVVA Platformu.

Ova stranica vas vodi kroz osnovne korake za postavljanje projekta lokalno i započinjanje doprinosa.

## Preduslovi

Pre nego što počnete, uverite se da imate instalirane sledeće alate:

- **Node.js** (preporučena verzija 18 ili novija)  
- **npm** ili **yarn** menadžer paketa  
- **Git** za kloniranje repozitorijuma  
- Moderni **pregledač** (Chrome, Firefox, Edge) za razvoj i testiranje  

## Kloniranje Repozitorijuma

Izvorni kod je hostovan na GitHub-u. Da biste dobili najnoviju verziju:

```bash
git clone https://github.com/AlexNa-Holdings/savva-ui-solidjs
cd savva-ui-solidjs
````

## Instaliranje Zavisnosti

Unutar foldera projekta, instalirajte sve potrebne zavisnosti:

```bash
npm install
# ili
yarn install
```

## Pokretanje Razvojnog Servera

Pokrenite dev server sa automatskim ponovnim učitavanjem:

```bash
npm run dev
# ili
yarn dev
```

Aplikacija će biti dostupna na [http://localhost:5173](http://localhost:5173).

## Izrada za Proizvodnju

Da biste kreirali optimizovanu verziju:

```bash
npm run build
```

Izlaz će biti u `dist/` folderu.

## Sledeći Koraci

* Istražite **Dokumentaciju za Razvijače** za arhitekturu i module.
* Pokušajte da menjate domene i resurse u **Desnom Panelu**.
* Doprinosite otvaranjem problema ili pull zahteva na GitHub-u.

To je to! 🎉 Spremni ste da počnete sa radom na **SAVVA Platformi**.

```html
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SAVVA · SolidJS</title>

  <!-- Preload theme to avoid flash -->
  <script>
    (function () {
      try {
        const saved = localStorage.getItem("theme");
        const systemDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const theme = saved || (systemDark ? "dark" : "light");
        document.documentElement.classList.toggle("dark", theme === "dark");
      } catch { }
    })();
  </script>

  <script>
    (function () {
      // If there is a real path (e.g., /settings) but no hash, rewrite to hash form: /#/settings
      if (!location.hash && location.pathname !== "/") {
        var newHash = "#" + location.pathname + location.search + location.hash;
        history.replaceState(null, "", "/" + newHash);
      }
    })();
  </script>


  <!-- Load app after theme class is set -->
  <script type="module" src="/src/index.jsx"></script>
</head>

<body>
  <div id="root"></div>
</body>

</html>
```
</file>

<file path="public/dev_docs/sr/index.md">
# SAVVA Developer Documentation

Dobrodošli u **SAVVA Platform** dokumentaciju za programere.


## Šta je SAVVA?

SAVVA je **platforma otvorenog koda** za izgradnju društvenih mreža nove generacije.  
Za razliku od tradicionalnih platformi, SAVVA kombinuje **blockchain** i **IPFS** kako bi stvorila decentralizovanu, pouzdanu i otpornu na cenzuru osnovu.

- **Objave zasnovane na blockchain-u**  
  Svaki deo sadržaja je registrovan na lancu i potpisan kriptografskim ključem autora. Ovo osigurava autentičnost i omogućava poverenje da objava zaista dolazi od navedenog autora.

- **Decentralizovano skladištenje sa IPFS**  
  Sadržaj se skladišti u InterPlanetary File System umesto u bazi podataka jedne kompanije. Ovo uklanja jedinstvene tačke kvara i čini sistem otpornijim.

Zajedno, blockchain i IPFS čine novu vrstu društvene mreže: onu bez centralizovane kontrole, bez jedne kompanije koja stoji iza nje, i bez tačke pritiska koja se može iskoristiti.


## O Ovoj Dokumentaciji

Ovo je **dokumentacija za programere**, a ne pomoć za krajnje korisnike.  
SAVVA je otvorenog koda, i aktivno podstičemo programere da fork-uju, proširuju i prilagođavaju kodnu bazu.  

Ovde ćete pronaći:

- **osnovne principe** iza arhitekture.  
- Kako su **interfejsi i API-ji** strukturirani.  
- Najbolje prakse za proširenje i integraciju platforme.

Ako ste programer koji istražuje SAVVA, ovo je mesto za početak. 🚀
</file>

<file path="public/dev_docs/ua/core-concepts/app-init.md">
# Ініціалізація додатку та підключення до бекенду

## Що таке бекенд SAVVA (вузол SAVVA)?
Бекенд SAVVA — це серверний компонент, який **індексує/кешує дані, отримані з активності блокчейну**, та надає швидкі, зручні для користувача API та методи WebSocket. Один бекенд може обслуговувати **кілька доменів SAVVA** — уявіть собі "домен" як окрему соціальну мережу SAVVA (брендинг, вкладки, активи, значення за замовчуванням), всі з яких підтримуються одним вузлом.

## Що потрібно додатку при запуску
Під час запуску веб-додатку потрібно два параметри:

1. **URL бекенду** – базовий URL бекенду SAVVA.
2. **Ім'я домену** – який домен SAVVA (соціальна мережа) відображати за замовчуванням.

Значення за замовчуванням беруться з маленького YAML файлу в корені веб-додатку:

### `/default_connect.yaml`
```yaml
# /default_connect.yaml
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
# optional:
# default_ipfs_link: ipfs://bafy.../something.json
```

* `backendLink` — базова HTTP точка доступу бекенду SAVVA (додаток нормалізує її).
* `domain` — початковий домен для відображення; його можна змінити пізніше в інтерфейсі.
* `gear` — активує інструменти розробника в інтерфейсі (необов'язково).
* `default_ipfs_link` — необов'язкове зручне значення за замовчуванням, яке використовується в деяких потоках.

> **Примітка для виробництва**
> У виробництві цей файл зазвичай обслуговується вашим HTTP сервером (наприклад, Nginx) і фактично **вибирає, який домен** веб-додаток показує за замовчуванням. Один поширений шаблон — обслуговувати конкретний файл з диска:
>
> ```nginx
> # приклад: обслуговувати статичний default_connect.yaml
> location = /default_connect.yaml {
>   default_type text/yaml;
>   alias /etc/savva/default_connect.yaml;
> }
> ```
>
> Налаштуйте відповідно до вашої інфраструктури; ключовим є те, що додаток може `GET /default_connect.yaml`.

---

## Послідовність запуску

1. **Завантажити `/default_connect.yaml`**
   Додаток отримує YAML файл, перевіряє `backendLink` і зберігає `domain`. Він негайно **конфігурує кінцеві точки** (базовий HTTP + URL WS), використовуючи ці значення. &#x20;

2. **Конфігурувати кінцеві точки**

   * `httpBase` — це нормалізована версія `backendLink` (гарантований слеш наприкінці).
   * URL `ws` отримується з тієї ж бази, вказуючи на `.../ws` (протокол змінюється на `ws:` або `wss:`) і включає `?domain=...` в запиті.
     Це забезпечує **одне джерело правди** для HTTP та WS.&#x20;

3. **Отримати `/info`**
   З установленими кінцевими точками додаток викликає `GET <httpBase>info` і зберігає JSON. З цього моменту **/info визначає поведінку під час виконання** (домени, ланцюг, IPFS, активи).&#x20;

4. **Визначити стан під час виконання з `/info`**
   Використовуються наступні поля (див. приклад нижче):

   * **`domains`** → Список доступних доменів. Інтерфейс надає перевагу явному `domain` з YAML/перезапису; якщо його немає в `/info`, він все ще використовується.&#x20;
   * **`blockchain_id`** → Цільовий ID ланцюга EVM. Допоміжна програма гаманця може перемикати/додавати цю мережу.&#x20;
   * **`ipfs_gateways`** → Віддалені IPFS шлюзи, які потрібно спробувати в порядку (якщо не увімкнено локальне переозначення IPFS).&#x20;
   * **`assets_url`** та **`temp_assets_url`** → **база активів** (продакшн проти тесту). Додаток обчислює **префікс активів активного домену** як
     `(<assets base> + <domain> + "/")` з **резервним** варіантом на `/domain_default/`, якщо віддалений `config.yaml` відсутній. &#x20;

5. **Завантажити активи домену та конфігурацію**
   Додаток намагається `(<active prefix>/config.yaml)` з коротким таймаутом; у разі невдачі він повертається до стандартного пакету за адресою `/domain_default/config.yaml`. Результуюча розібрана конфігурація (логотипи, вкладки, локалі тощо) зберігається, і інтерфейс відображається відповідно.&#x20;

6. **Час виконання WebSocket**
   Клієнт WS використовує обчислений `ws` URL з кінцевих точок; коли бекенд/домен змінюється, кінцеві точки перераховуються, і шар WS це підхоплює.&#x20;

---

## Приклад `/info` (ілюстративний)

```json
{
  "domains": [
    "savva.app",
    {"name": "art.savva"},
    "dev.savva"
  ],
  "blockchain_id": 369,
  "ipfs_gateways": [
    "https://cloudflare-ipfs.com/ipfs/",
    "https://ipfs.io/ipfs/"
  ],
  "assets_url": "https://cdn.savva.network/assets/",
  "temp_assets_url": "https://cdn.savva.network/assets-test/"
}
```

### Поле за полем (що робить з ним додаток)

* **domains** — список вибиральних доменів. Діалог **Перемикання бекенду / домену** заповнюється з `/info`, але сконфігурований домен все ще має перевагу, якщо `/info` відстає. &#x20;
* **blockchain\_id** — числовий ID ланцюга EVM; використовується для створення метаданих `перемикання/додавання ланцюга` та для забезпечення того, щоб гаманець був на **необхідній мережі**. &#x20;
* **ipfs\_gateways** — впорядкований список віддалених шлюзів; в поєднанні з необов'язковим **Локальним IPFS** переозначенням (коли увімкнено в налаштуваннях) формує **активний** порядок шлюзів.&#x20;
* **assets\_url / temp\_assets\_url** — додаток підтримує **середовище активів** (`prod`/`test`) і вибирає відповідну базу. Потім він обчислює `/<base>/<domain>/` і завантажує `config.yaml`. Якщо віддалений пакет відсутній або повільний, він використовує **за замовчуванням** `/domain_default/`.&#x20;

---

## Де це знаходиться в коді (для швидкого посилання)

* Завантаження при запуску та `/default_connect.yaml`, потім `/info`: **`src/context/AppContext.jsx`** та **`src/hooks/useConnect.js`**. &#x20;
* Джерело істини для кінцевих точок (базовий HTTP + URL WS): **`src/net/endpoints.js`**.&#x20;
* Вирішення списку доменів, ID ланцюга, шлюзів IPFS, середовище активів та завантаження активів домену: **`src/context/AppContext.jsx`**.  &#x20;
* Діалог перемикання, який отримує `/info` та нормалізує `domains`: **`src/components/SwitchConnectDialog.jsx`**.&#x20;

---

**Далі:** у наступному розділі ми розглянемо **конфігурацію домену** (`config.yaml`) і як вона контролює логотипи, вкладки, локалі та інші поведінки інтерфейсу для кожного домену.
</file>

<file path="public/dev_docs/ua/core-concepts/auth.md">
# Потік авторизації Web3

Платформа SAVVA використовує безпарольний метод аутентифікації Web3. Користувачі можуть "увійти" за допомогою будь-якого гаманця, сумісного з EVM, просто підписавши унікальне повідомлення, надане сервером. Цей процес перевіряє право власності на адресу та встановлює безпечну сесію, керовану кукі браузера.

## Огляд потоку

Процес авторизації складається з послідовності кроків, організованих між фронтендом, гаманцем користувача, блокчейном та бекендом SAVVA.

1.  **Підготовка унікального повідомлення**: Фронтенд створює унікальне повідомлення для підпису користувача. Це повідомлення складається з двох частин: динамічного значення з смарт-контракту та статичного значення з бекенду.
2.  **Користувач підписує повідомлення**: Користувач отримує запит від свого гаманця (наприклад, MetaMask) на підпис підготовленого повідомлення.
3.  **Аутентифікація на бекенді**: Фронтенд надсилає адресу користувача та отриманий підпис на кінцеву точку `/auth` бекенду.
4.  **Кукі сесії**: Якщо підпис дійсний, бекенд відповідає заголовком `Set-Cookie`, встановлюючи аутентифіковану сесію.
5.  **Аутентифіковані запити**: Усі наступні API та WebSocket запити з браузера тепер автоматично включатимуть це кукі, ідентифікуючи користувача.
6.  **Отримання профілю користувача**: Після аутентифікації фронтенд робить WebSocket виклик до `/get-user`, щоб отримати повні деталі профілю користувача, такі як його аватар та ім'я.

---

## Покрокова реалізація

### 1. Підготовка повідомлення для підпису

Щоб запобігти атакам повторного використання та забезпечити унікальність кожного запиту на вхід, повідомлення для підпису складається з двох джерел:

-   Динамічний рядок **`auth_modifier`**, прочитаний з смарт-контракту `UserProfile`.
-   Статичний рядок **`auth_text_to_sign`**, наданий кінцевою точкою `/info` бекенду.

Фронтенд спочатку викликає функцію `getString` на контракті `UserProfile`:

```javascript
// З: src/blockchain/auth.js

// Отримати екземпляр контракту UserProfile
const userProfileContract = await getSavvaContract(app, 'UserProfile');

// Підготувати аргументи для виклику контракту
const domainHex = toHexBytes32(""); // Домен порожній для глобального модифікатора
const keyHex = toHexBytes32("auth_modifier");

// Отримати модифікатор (повертає рядок hex bytes32)
const modifierHex = await userProfileContract.read.getString([
  account,      // Адреса користувача
  domainHex,    // bytes32 представлення ""
  keyHex        // bytes32 представлення "auth_modifier"
]);

// Перетворити hex значення на читабельний рядок
const modifierString = hexToString(modifierHex, { size: 32 });
```

Потім він об'єднує цей `modifierString` з текстом з `/info`:

```javascript
// Отримати текст з вже завантаженого відповіді /info
const textToSign = app.info().auth_text_to_sign;

// Об'єднати в потрібному порядку
const messageToSign = textToSign + modifierString;
```

### 2\. Підписування гаманцем

Використовуючи `viem`, фронтенд запитує підпис користувача для об'єднаного повідомлення. Ця дія відкриває запит у гаманці користувача.

```javascript
// З: src/blockchain/auth.js

const walletClient = createWalletClient({
  chain: app.desiredChain(),
  transport: custom(window.ethereum)
});

const signature = await walletClient.signMessage({
  account,
  message: messageToSign,
});
```

Отриманий `signature` є довгим hex рядком (наприклад, `0x...`).

### 3\. Аутентифікація на бекенді

Фронтенд потім робить запит `GET` до кінцевої точки `/auth`, надсилаючи адресу користувача, домен та новий підпис як параметри запиту.

**Критично**, запит `fetch` повинен включати опцію **`credentials: 'include'`**. Це говорить браузеру обробити заголовок `Set-Cookie` у відповіді, що є суттєвим для встановлення сесії.

```javascript
// З: src/blockchain/auth.js

const authUrl = new URL(`${httpBase()}auth`);
authUrl.searchParams.set('user_addr', checksummedAccount);
authUrl.searchParams.set('domain', currentDomain);
authUrl.searchParams.set('signature', signature);

const authRes = await fetch(authUrl.toString(), { credentials: 'include' });
```

Якщо успішно, відповідь бекенду міститиме заголовок, подібний до цього:

```
Set-Cookie: auth=...; Path=/; HttpOnly; Secure; SameSite=Lax
```

### 4\. Виконання аутентифікованих API викликів

З кукі, тепер встановленим у браузері, наступні API виклики (наприклад, перевірка адміністративних привілеїв) також повинні включати **`credentials: 'include'`**, щоб забезпечити надсилання кукі з запитом.

```javascript
// З: src/blockchain/auth.js

const isAdminUrl = new URL(`${httpBase()}is-admin`);
isAdminUrl.searchParams.set('address', checksummedAccount);
isAdminUrl.searchParams.set('domain', currentDomain);

const adminRes = await fetch(isAdminUrl.toString(), { credentials: 'include' });
const isAdminData = await adminRes.json(); // наприклад, {"result":"ok","admin":true}
const isAdmin = !!isAdminData?.admin;
```

### 5\. Отримання профілю користувача (через WebSocket)

Браузер автоматично надсилає кукі авторизації під час оновлення з'єднання WebSocket. Після успішного входу функція `login` програми виконує `wsCall` до методу `get-user`, щоб отримати повний профіль користувача.

```javascript
// З: src/context/useAppAuth.js (в функції входу)

const userProfile = await getWsApi().call('get-user', {
  domain: coreUserData.domain,
  user_addr: checksummedAccount,
});
```

Приклад відповіді з `/get-user` може виглядати так:

```json
{
  "name": "alexna",
  "avatar": "QmbXwxPzs2veVYFbm7yybfK3rBMxEebuhAcWh3tuKdDTbq?filename=.png",
  "staked": 42529097734827650000000000,
  "n_followers": 9,
  "banned": false
}
```

-----

## Зберігання сесії

Останній об'єкт користувача, який є комбінацією основних даних (`address`, `domain`, `isAdmin`) та профілю, отриманого з `/get-user`, зберігається в глобальному `AppContext` та зберігається в `localStorage`. Це дозволяє автоматично відновити сесію, коли користувач знову відвідує додаток.

## Процес виходу

Процес виходу скасовує ці кроки:

1.  Запит `POST` надсилається до API кінцевої точки `/logout`, щоб анулювати сесію на сервері та очистити кукі.
2.  Дані користувача видаляються з глобального стану та `localStorage`.
3.  З'єднання WebSocket примусово "перепідключається", встановлюючи нову, неаутентифіковану сесію.

-----

## Кодова довідка

  - **Основна організація**: `src/blockchain/auth.js`
  - **Управління станом та потік після входу**: `src/context/useAppAuth.js`
</file>

<file path="public/dev_docs/ua/core-concepts/config-contract.md">
# Контракт конфігурації

Смарт-контракт `Config` слугує центральним, ончейн реєстром для всіх глобальних параметрів системи на платформі SAVVA. Уявіть його як децентралізоване сховище ключ-значення, яке регулює поведінку всіх інших контрактів в екосистемі.

Критично важливою особливістю платформи SAVVA є те, що контракт `Config` контролюється контрактом `Governance`. Це означає, що будь-який параметр може бути змінений через голосування громади. Тримачі токенів можуть створювати пропозиції та голосувати за коригування зборів, термінів та інших основних механік, що робить платформу справді керованою громадою.

---

## Як це працює

Параметри зберігаються та отримуються за допомогою ключів `bytes32`. Фронтенд абстрагує це, надаючи допоміжну функцію `getConfigParam`, яка перетворює зрозумілі для людини назви (наприклад, "min_staked_to_post") у необхідний ончейн формат.

Контракт має різні функції для отримання значень залежно від їх типу даних, переважно `getUInt` для числових значень та `getAddr` для адрес контрактів. Фронтенд автоматично вибирає правильну функцію на основі назви параметра.

---

## Глобальні параметри

Наступна таблиця містить деталі глобальних параметрів, які наразі керуються контрактом `Config`.

| Назва | Тип | Одиниці | Опис |
| --- | --- | --- | --- |
| `authorShare` | Uint | відсотки * 100 | Частка автора фонду контенту (наприклад, 100 = 1%). |
| `nftOwnerCut` | Uint | відсотки * 100 | Частка власника NFT у відсотках * 100 (наприклад, 100 = 1%). |
| `minContribution` | Uint | SAVVA | Мінімальний внесок у фонд контенту в токенах SAVVA. |
| `timeForRound` | Uint | секунди | Тривалість раунду фонду контенту в секундах. |
| `winnerShare` | Uint | відсотки | Частка призу раунду фонду в відсотках. |
| `minFundToShare` | Uint | SAVVA | Мінімальна сума фонду, необхідна для розподілу призів, в токенах SAVVA. |
| `staking_withdraw_delay` | Uint | секунди | Період охолодження стейкінгу в секундах. |
| `contentNFT_mintPrice` | Uint | PLS | Ціна на карбування NFT контенту. |
| `pulsex_slippage` | Uint | відсотки | Допустиме відхилення для обміну PulseX (резерв/мінімальна сума). |
| `min_staked_to_post` | Uint | SAVVA | Мінімальна сума стейкованих SAVVA, необхідна для публікації контенту. |
| `sac_min_deposit` | Uint | PLS | Мінімальний депозит для фази жертви. |
| `patron_payment_period` | Uint | секунди | Тривалість періоду виплат патронів в секундах. |
| `gov_proposal_price` | Uint | PLS | Ціна на створення нової пропозиції з управління. |
| `nft_auction_max_duration` | Uint | секунди | Максимальна тривалість аукціону NFT в секундах. |
| `nft_auction_min_increment` | Uint | відсотки | Мінімальне збільшення ставки для аукціону NFT в відсотках. |
| `nft_auction_max_increment` | Uint | відсотки | Максимальне збільшення ставки для аукціону NFT в відсотках. |
| `min_staked_for_nft_auction`| Uint | SAVVA | Мінімальна сума стейкованих SAVVA, необхідна для створення аукціону NFT. |
| `authorsClubsGainReceiver` | Address | | Адреса, яка отримує прибутки від стейкінгу з Authors Clubs. |
| `min_staked_for_fundrasing` | Uint | SAVVA | Мінімальна сума стейкованих SAVVA, необхідна для створення збору коштів. |
| `fundraising_bb_fee` | Uint | відсотки * 100 | Комісія за викуп для зборів коштів у відсотках * 100 (наприклад, 100 = 1%). |
| `contract_savvaToken` | Address | | Адреса контракту токена SAVVA. |
| `contract_randomOracle` | Address | | Адреса контракту випадкового оракула (0 для відсутності). |
| `contract_staking` | Address | | Адреса контракту стейкінгу. |
| `contract_userProfile` | Address | | Адреса контракту профілю користувача. |
| `contract_contentNFT` | Address | | Адреса контракту NFT контенту. |
| `contract_contentFund` | Address | | Адреса контракту фонду контенту. |
| `contract_governance` | Address | | Адреса контракту управління. |
| `contract_contentRegistry` | Address | | Адреса контракту реєстру контенту. |
| `contract_savvaFaucet` | Address | | Адреса контракту SAVVA Faucet. |
| `contract_nftMarketplace` | Address | | Адреса контракту NFT Marketplace. |
| `contract_promo` | Address | | Адреса контракту промо. |
| `contract_buyBurn` | Address | | Адреса контракту Buy & Burn. |
| `contract_listMarket` | Address | | Адреса контракту List Market. |
| `contract_authorOfTheMonth` | Address | | Адреса контракту Автор місяця. |
| `pulsex_factory` | Address | | Контракт фабрики PulseX для Buy & Burn. |
| `pulsex_router` | Address | | Контракт маршрутизатора PulseX для Buy & Burn. |
| `WPLS` | Address | | Адреса контракту Wrapped PLS (WPLS). |
</file>

<file path="public/dev_docs/ua/core-concepts/domain.md">
# Робота з доменами

**Домен** — це просто назва соціальної мережі, яку ви хочете відобразити. Зазвичай це DNS-хост сайту (наприклад, `savva.app`), але це не обов'язково. Кожен домен має **пакет домену** — папку, що містить `config.yaml` та всі специфічні для домену ресурси (логотипи, фавікон, локалі, конфігурацію вкладок, необов'язковий `domain.css` тощо).

## Де знаходиться `config.yaml`?

Під час виконання програма обчислює **базовий URL ресурсів** з `/info`:
- **Продакшн:** `assets_url`
- **Тест:** `temp_assets_url`

Активне середовище — це простий перемикач прод/тест у програмі (використовується адміністраторами для тестування змін). Виходячи з **обраної назви домену**, програма створює префікс:

```

<assetsBase>/<domain>/

```

Потім програма намагається завантажити:

```

<assetsBase>/<domain>/config.yaml

```

Якщо це не вдається (відсутній пакет, 404 тощо), інтерфейс **повертається** до вбудованого пакету за замовчуванням:

```

/domain\_default/config.yaml

```

> Цей пошук та діагностика централізовані; ви побачите ті ж самі шляхи в діагностичному інтерфейсі.  
> Активний `domain.css` завантажується з того ж префікса і кешується з ключем версії, тому зміни застосовуються негайно після завантаження.

## Чому два середовища (прод / тест)?

Сервер надає два базових URL для ресурсів:

- **`assets_url`** → продакшн пакет для кінцевих користувачів  
- **`temp_assets_url`** → тестовий пакет для попереднього перегляду змін

Адміністратор (як налаштовано на сервері) може завантажити модифікований пакет домену під **тестовий** базовий URL і перевірити все (логотипи, вкладки, GA, кольори) без впливу на користувачів. Коли все буде задовольняти, він публікує той же пакет у **прод**.

## Структура пакету домену

Все для домену знаходиться в одній папці:

```

<assetsBase>/<domain>/
config.yaml          # основна конфігурація (логотипи, фавікон, локалі, модулі)
domain.css           # необов'язкові змінні теми (кольори, фони)
i18n/*.yaml          # мовні словники (по локалях)
images/*             # брендові ресурси
modules/tabs.yaml    # визначення вкладок для головного екрану
modules/*.yaml       # інші конфігурації модулів (необов'язкові)
html/*.html          # довільні HTML блоки (необов'язкові)

````

## Приклад `config.yaml`

Нижче наведено скорочений приклад, що показує типові поля, які використовує програма:

```yaml
logo:
  light: images/logo_light.png
  dark: images/logo_dark.png
  light_mobile: images/logo_light.png
  dark_mobile: images/logo_dark.png

favicon:
  apple-touch-icon: favicon/apple-touch-icon.png
  16: favicon/favicon-16x16.png
  32: favicon/favicon-32x32.png
  manifest: favicon/site.webmanifest
  mask-icon:
    href: favicon/safari-pinned-tab.svg
    color: '#5bbad5'
  base: favicon/favicon.ico
  meta:
    - name: msapplication-TileColor
      content: '#da532c'
    - name: theme-color
      content: '#ffffff'

GA_tag: G-XXXXXXXXXX   # ID Google Analytics (gtag)

modules:
  tabs: modules/tabs.yaml
  content_lists: modules/content_lists.yaml
  staker_levels: modules/staker_levels.yaml
  categories: modules/categories.yaml

default_locale: en
locales:
  - code: en
    name: English
    title: 'SAVVA.APP - Beyond Likes Social'
    dictionary: i18n/en.yaml
  - code: ru
    name: Русский
    title: 'SAVVA.APP - За межами лайків'
    dictionary: i18n/ru.yaml
````

### Що контролюють ці поля

* **`logo`** — Програма автоматично вибирає найкращий варіант (темний/світлий + мобільний/десктопний) і вирішує через активний префікс домену.
* **`favicon`** — Усі посилання на фавікон та мета-теги застосовуються динамічно; коли конфігурація змінюється, програма замінює набір `<link rel="icon">`.
* **`GA_tag`** — Дозволяє Google Analytics (gtag.js). Коли присутній, програма вставляє скрипти GA та надсилає події SPA `page_view` при зміні маршруту.
* **`modules.tabs`** — Вказує на YAML, який визначає вкладки на головному екрані (див. нижче).
* **`locales`** — Список мов для домену (код/ім'я/назва + шлях до словника). Програма може відображати локалізовані назви/рядки для кожного домену.

## Вкладки на головному екрані

Вкладки налаштовуються в окремому YAML (на який посилається `modules.tabs` вище). Наприклад:

```yaml
# modules/tabs.yaml
tabs:
  - type: leaders
    title:
      en: Leaders
      ru: Лідери
    right_panel:
      available: true
      blocks:
        - type: html
          en: /html/info_block_en.html
          ru: /html/info_block_ru.html
        - type: content_List
          list_name: main
          count: 7

  - type: new
    title:
      en: New
      ru: Нове
```

Інтерфейс вибирає локалізовану назву вкладки, вибирає іконку за `type` та відображає необов'язкові блоки правої панелі. Цей файл знаходиться в **тій же папці домену**, тому він версійований і попередньо переглядається разом з `config.yaml`.

## Кольори теми через `domain.css`

Якщо присутній, `domain.css` завантажується з того ж префікса домену та застосовується під час виконання. Він зазвичай визначає CSS змінні, які використовує інтерфейс (фони, передній план, акценти, межі тощо). Зміна **домену** або **середовища** перезавантажує цей CSS, тому адміністратори можуть точно налаштувати брендинг без повторної збірки програми.

Приклад змінних:

```css
:root {
  --gradient: linear-gradient(to top left, #000c40, #607d8b);
  --background: 243 100% 98.26%;
  --foreground: 243 10% 0.52%;
  --muted: 243 10% 91.3%;
  --muted-foreground: 243 5% 41.3%;
  --primary: 243 100% 13%;
  --primary-foreground: 243 2% 98%;
  /* ... */
}
```

## Google Analytics (GA)

Встановіть `GA_tag` у `config.yaml`, щоб увімкнути GA. Програма автоматично вставляє скрипт GA та ініціалізує `gtag(...)`, а також відстежує перегляди сторінок при змінах хеш-маршруту. Видаліть або очистіть `GA_tag`, щоб вимкнути аналітику для домену.

---

### Резюме

* Програма вибирає **прод** або **тест** базу ресурсів, а потім завантажує `<base>/<domain>/config.yaml` з безпечним запасним варіантом на `/domain_default/config.yaml`.
* **Всі** ресурси домену (логотипи, локалі, вкладки, `domain.css`) знаходяться в одній папці для атомарних оновлень.
* Адміністратори можуть попередньо переглядати зміни в **тесті** перед публікацією в **прод**.
* `config.yaml` контролює брендинг (логотипи, фавікон), локалізацію, GA та де знайти модулі інтерфейсу, такі як **вкладки**.
</file>

<file path="public/dev_docs/ua/core-concepts/index.md">
<!-- public/dev_docs/ua/core-concepts/index.md -->
# Основні концепції

Цей розділ охоплює основну архітектуру програми SAVVA SolidJS: як вона підключається до бекенду, як працюють домени та активи, як інтерфейс користувача керується конфігурацією за доменами та інше.

Що ми розглянемо:

- Як програма завантажується та знаходить правильний бекенд і домен
- Як `/info` визначає поведінку під час виконання (домени, ID ланцюга, шлюзи IPFS, активи)
- Як вирішуються активи домену та коли використовується стандартний пакет
</file>

<file path="public/dev_docs/ua/core-concepts/publishing-posts.md">
# Публікація Посту

Публікація контенту на платформі SAVVA є трьохетапним процесом, який забезпечує цілісність даних, децентралізацію та перевірку в ланцюгу. Процес включає підготовку даних посту локально, завантаження контенту та його опису до IPFS, а також реєстрацію посту в блокчейні через виклик смарт-контракту.

Фронтенд-редактор автоматизує цей процес через майстра, але розуміння основних етапів є важливим для розробників.

---

## Крок 1: Підготовка Даних Посту

Перед будь-яким завантаженням або транзакцією редактор організовує пост у стандартизовану структуру директорій. Цю структуру керують локально, використовуючи API файлової системи.

Основні компоненти:

* Файл параметрів (`params.json`) для налаштувань, специфічних для редактора.
* Файл опису (`info.yaml`), який визначає структуру посту та метадані для IPFS.
* Markdown файли для контенту кожної мови.
* Директорія `uploads/` для будь-яких супутніх медіафайлів (зображення, відео тощо).

### Приклад `params.json`

Цей файл містить налаштування, які використовуються інтерфейсом редактора, і не публікується в ланцюзі.

```json
{
  "guid": "c4a7f6b9-6e3e-4b9e-8b1e-2e4a6d7c8b9a",
  "nsfw": false,
  "fundraiser": 0,
  "publishAsNewPost": true,
  "locales": {
    "en": {
      "tags": ["децентралізація", "соціальні"],
      "categories": ["Технології"],
      "chapters": [
        { "title": "Що таке блокчейн?" },
        { "title": "IPFS та адресація контенту" }
      ]
    }
  },
  "thumbnail": "uploads/thumbnail.png"
}
```

### Приклад `info.yaml` (Опис Посту)

Цей файл є канонічним визначенням посту і завантажується до IPFS. Він зв'язує всі частини контенту разом.

```yaml
savva_spec_version: "2.0"
data_cid: bafybeih...
gateways:
  - https://ipfs.io/
locales:
  en:
    title: "Розуміння децентралізованих систем"
    text_preview: "Глибоке занурення в основні концепції децентралізації..."
    data_path: "en/data.md"
    chapters:
      - data_path: "en/chapters/1.md"
      - data_path: "en/chapters/2.md"
```

* **data\_cid**: CID IPFS директорії, що містить весь Markdown контент та завантажені файли.
* **locales**: Містить метадані, специфічні для мови. Заголовок та текст\_прев'ю з редактора зберігаються тут.
* **data\_path / chapters.data\_path**: Відносні шляхи до файлів контенту в директорії `data_cid`.

---

## Крок 2: Завантаження до IPFS

Процес завантаження відбувається в два окремі етапи, які обробляються API зберігання бекенду.

1. **Завантаження Директорії Контенту**: Усі файли контенту (наприклад, `en/data.md`, `en/chapters/1.md`, `uploads/thumbnail.png`) завантажуються як одна директорія до IPFS. Бекенд повертає єдиний CID IPFS для цієї директорії, який стає `data_cid`.
2. **Завантаження Опису**: Файл `info.yaml` генерується з `data_cid` з попереднього етапу. Цей YAML файл потім завантажується до IPFS як окремий файл. CID цього файлу `info.yaml` є фінальним вказівником IPFS для посту.

---

## Крок 3: Реєстрація в Блокчейні

Останній крок - зафіксувати пост у блокчейні, викликавши функцію `reg` на смарт-контракті `ContentRegistry`.

Фронтенд виконує цю транзакцію з наступними параметрами:

* **domain**: Поточна назва домену (наприклад, `savva.app`).
* **author**: Адреса гаманця користувача.
* **guid**: Унікальний ідентифікатор з `params.json`.
* **ipfs**: CID IPFS файлу опису `info.yaml` з Кроку 2.
* **content\_type**: Рядок `bytes32`, зазвичай `post` для нового контенту або `post-edit` для оновлень.

### Приклад Виклику Контракту

```javascript
// З: src/components/editor/wizard_steps/StepPublish.jsx

const contract = await getSavvaContract(app, "ContentRegistry", { write: true });

const hash = await contract.write.reg([
  domain,           // "savva.app"
  user.address,     // "0x123..."
  guid,             // "c4a7f6b9-..."
  descriptorCid,    // "bafybeif..."
  toHexBytes32("post")
]);

// Інтерфейс користувача потім чекає на підтвердження транзакції
const receipt = await publicClient.waitForTransactionReceipt({ hash });
```

Якщо транзакцію успішно оброблено, пост офіційно публікується і з'явиться в контентних стрічках.
</file>

<file path="public/dev_docs/ua/getting-started.md">
# Початок роботи

Ласкаво просимо до посібника **Початок роботи** для платформи SAVVA.

Ця сторінка проведе вас через основні кроки для налаштування проекту локально та початку внесення внесків.

## Попередні вимоги

Перед початком переконайтеся, що у вас встановлені наступні інструменти:

- **Node.js** (рекомендується версія 18 або новіша)  
- Пакетний менеджер **npm** або **yarn**  
- **Git** для клонування репозиторію  
- Сучасний **браузер** (Chrome, Firefox, Edge) для розробки та тестування  

## Клонування репозиторію

Вихідний код розміщено на GitHub. Щоб отримати останню версію:

```bash
git clone https://github.com/AlexNa-Holdings/savva-ui-solidjs
cd savva-ui-solidjs
````

## Встановлення залежностей

У папці проекту встановіть усі необхідні залежності:

```bash
npm install
# або
yarn install
```

## Запуск сервера розробки

Запустіть сервер розробки з гарячим перезавантаженням:

```bash
npm run dev
# або
yarn dev
```

Додаток буде доступний за адресою [http://localhost:5173](http://localhost:5173).

## Створення версії для продакшну

Щоб створити оптимізовану версію:

```bash
npm run build
```

Вихідні файли будуть у папці `dist/`.

## Наступні кроки

* Ознайомтеся з **Документацією для розробників** щодо архітектури та модулів.
* Спробуйте змінити домени та активи у **Правій панелі**.
* Внесіть свій внесок, відкриваючи проблеми або запити на злиття на GitHub.

Ось і все! 🎉 Ви готові почати працювати з **платформою SAVVA**.

```html
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SAVVA · SolidJS</title>

  <!-- Preload theme to avoid flash -->
  <script>
    (function () {
      try {
        const saved = localStorage.getItem("theme");
        const systemDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const theme = saved || (systemDark ? "dark" : "light");
        document.documentElement.classList.toggle("dark", theme === "dark");
      } catch { }
    })();
  </script>

  <script>
    (function () {
      // If there is a real path (e.g., /settings) but no hash, rewrite to hash form: /#/settings
      if (!location.hash && location.pathname !== "/") {
        var newHash = "#" + location.pathname + location.search + location.hash;
        history.replaceState(null, "", "/" + newHash);
      }
    })();
  </script>


  <!-- Load app after theme class is set -->
  <script type="module" src="/src/index.jsx"></script>
</head>

<body>
  <div id="root"></div>
</body>

</html>
```
</file>

<file path="public/dev_docs/ua/index.md">
# Документація для розробників SAVVA

Ласкаво просимо до документації для розробників **платформи SAVVA**.


## Що таке SAVVA?

SAVVA — це **платформа з відкритим кодом** для створення соціальних мереж наступного покоління.  
На відміну від традиційних платформ, SAVVA поєднує **блокчейн** та **IPFS**, щоб створити децентралізований, надійний та стійкий до цензури фундамент.

- **Пости, закріплені в блокчейні**  
  Кожен елемент контенту реєструється в блокчейні та підписується криптографічним ключем автора. Це забезпечує автентичність і дозволяє довіряти, що пост дійсно походить від зазначеного автора.

- **Децентралізоване зберігання з IPFS**  
  Контент зберігається в міжпланетній файловій системі, а не в базі даних однієї компанії. Це усуває єдині точки відмови та робить систему більш стійкою.

Разом блокчейн і IPFS формують новий тип соціальної мережі: без централізованого контролю, без єдиної компанії за нею та без точки тиску, яку можна експлуатувати.


## Про цю документацію

Це **документація для розробників**, а не допомога для кінцевих користувачів.  
SAVVA є проектом з відкритим кодом, і ми активно заохочуємо розробників форкати, розширювати та адаптувати кодову базу.  

Тут ви знайдете:

- **основні принципи** архітектури.  
- Як структуровані **інтерфейси та API**.  
- Найкращі практики для розширення та інтеграції платформи.

Якщо ви розробник, який досліджує SAVVA, це місце, з якого варто почати. 🚀
</file>

<file path="public/domain_default/config.yaml">
logo:
  light: images/logo_light.png
  dark: images/logo_dark.png
  light_mobile: images/logo_light.png
  dark_mobile: images/logo_dark.png
favicon:
  apple-touch-icon: favicon/apple-touch-icon.png
  16: favicon/favicon-16x16.png
  32: favicon/favicon-32x32.png
  manifest: favicon/site.webmanifest
  mask-icon:
    href: favicon/safari-pinned-tab.svg
    color: '#5bbad5'
  base: favicon/favicon.ico
  meta:
    - name: msapplication-TileColor
      content: '#da532c'
    - name: theme-color
      content: '#ffffff'
GA_tag: G-XDSTY1ND4P
modules:
  content_lists: modules/content_lists.yaml
  categories: modules/categories.yaml
  tabs: modules/tabs.yaml
default_locale: en
locales:
  - code: en
    name: English
    title: 'SAVVA.APP - Beyond Likes Social'
    dictionary: i18n/en.yaml
  - code: ru
    name: Русский
    title: 'SAVVA.APP - За пределами лайков'
    dictionary: i18n/ru.yaml
  - code: fr
    name: Français
    title: 'SAVVA.APP - Au-delà des likes'
    dictionary: i18n/fr.yaml
  - code: ua
    name: Українська
    title: 'SAVVA.APP - Поза межами вподобань'
    dictionary: i18n/ua.yaml
</file>

<file path="public/domain_default/domain.css">
:root {
  --gradient: linear-gradient(to top left, #000c40, #607d8b);
  --background: 243 100% 98.26%;
  --foreground: 243 10% 0.52%;

  --muted: 243 10% 91.3%;
  --muted-foreground: 243 5% 41.3%;

  --popover: 243 10% 91.3%;
  --popover-foreground: 243 10% 0.65%;

  --card: 243 10% 91.3%;
  --card-foreground: 243 10% 0.65%;

  --border: 243 15% 89.52%;
  --input: 243 15% 89.52%;

  --primary: 243 100% 13%;
  --primary-foreground: 243 2% 91.3%;

  --secondary: 243 5% 81.73%;
  --secondary-foreground: 243 7% 11.3%;

  --accent: 243 5% 95.65%;
  --accent-foreground: 243 7% 11.3%;

  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 0 0% 98%;

  --ring: 243 100% 13%;

  --radius: 0.5rem;

  --tabs-justify: center;
}

.dark {
  /* CSS: .bg-gradient { background: var(--gradient) } */
  --gradient: linear-gradient(to top left, #acb6e5, #86fde8);

  --background: 244 33.800000000000004% 6.32%;
  --foreground: 244 5.2% 98.95%;

  --muted: 244 26% 23.700000000000003%;
  --muted-foreground: 244 5.2% 57.9%;

  --popover: 244 54.6% 10.27%;
  --popover-foreground: 244 5.2% 98.95%;

  --card: 244 54.6% 10.27%;
  --card-foreground: 244 5.2% 98.95%;

  --border: 244 26% 23.700000000000003%;
  --input: 244 26% 23.700000000000003%;

  --primary: 244 52% 79%;
  --primary-foreground: 244 5.2% 7.9%;

  --secondary: 244 26% 23.700000000000003%;
  --secondary-foreground: 244 5.2% 98.95%;

  --accent: 244 26% 23.700000000000003%;
  --accent-foreground: 244 5.2% 98.95%;

  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 244 5.2% 98.95%;

  --ring: 244 52% 79%;
}
</file>

<file path="scripts/i18n-docs.mjs">
// scripts/i18n-docs.mjs
//
// Localize developer documentation from English to the other locales.
//
// Behavior:
//  - English (source of truth): public/dev_docs/en
//  - Locales are discovered from src/i18n/*.js (excluding useI18n.js, just like scripts/i18n.mjs)
//  - For each non-EN locale:
//      * Ensure public/dev_docs/<lang> exists
//      * Delete files not present in EN
//      * Re-translate ONLY files whose EN source changed (tracked via per-locale .i18n-docs-state.json SHA256 map)
//      * Markdown translated with code/HTML preserved
//      * sidebar.yaml translated only for label/title fields
//
// Usage:
//   node scripts/i18n-docs.mjs
//
// Env:
//   OPENAI_API_KEY  (required)
//   OPENAI_MODEL    (optional, default: gpt-4o-mini)
//   DRY_RUN=1       (optional)

import fs from "node:fs";
import path from "node:path";
import crypto from "node:crypto";
import dotenv from "dotenv";
import yaml from "js-yaml";
import OpenAI from "openai";

dotenv.config();

const ROOT = process.cwd();

// --- match scripts/i18n.mjs constants exactly ---
const SRC_DIR = path.join(ROOT, "src");
const I18N_DIR = path.join(SRC_DIR, "i18n"); // ← same as i18n.mjs 
function isLangFile(name) {
  // same filter as i18n.mjs
  return name.endsWith(".js") && !/useI18n\.js$/i.test(name); // 
}

const DEV_DOCS_DIR = path.join(ROOT, "public", "dev_docs");
const EN_DIR = path.join(DEV_DOCS_DIR, "en");
const STATE_FILE = ".i18n-docs-state.json";
const DRY_RUN = process.env.DRY_RUN === "1";

const OPENAI_KEY = process.env.OPENAI_API_KEY || "";
const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";

if (!OPENAI_KEY) {
  console.error("[i18n-docs] Missing OPENAI_API_KEY");
  process.exit(1);
}

const openai = new OpenAI({ apiKey: OPENAI_KEY });

function sha256(buf) { return crypto.createHash("sha256").update(buf).digest("hex"); }

function walkFiles(dir) {
  const out = [];
  (function walk(d) {
    for (const ent of fs.readdirSync(d, { withFileTypes: true })) {
      if (ent.name === STATE_FILE) continue;
      const p = path.join(d, ent.name);
      if (ent.isDirectory()) walk(p);
      else out.push(p);
    }
  })(dir);
  return out;
}
function ensureDir(p) { fs.mkdirSync(p, { recursive: true }); }
function readFileSafe(p) { try { return fs.readFileSync(p); } catch { return null; } }
function writeFileSafe(p, content) {
  if (DRY_RUN) { console.log(`[DRY] write ${p}`); return; }
  ensureDir(path.dirname(p)); fs.writeFileSync(p, content);
}
function removeFileSafe(p) { if (DRY_RUN) console.log(`[DRY] remove ${p}`); else try { fs.unlinkSync(p); } catch {} }
function loadJson(p) { try { return JSON.parse(fs.readFileSync(p, "utf8")); } catch { return {}; } }
function saveJson(p, obj) { if (DRY_RUN) console.log(`[DRY] state -> ${p}`); else { ensureDir(path.dirname(p)); fs.writeFileSync(p, JSON.stringify(obj, null, 2) + "\n", "utf8"); } }

function englishMap() {
  const files = walkFiles(EN_DIR);
  const m = new Map();
  for (const abs of files) m.set(path.relative(EN_DIR, abs), abs);
  return m;
}

function listLocaleFiles(localeDir) {
  if (!fs.existsSync(localeDir)) return [];
  return walkFiles(localeDir).map(p => path.relative(localeDir, p));
}

function isMarkdown(rel) { return /\.md$/i.test(rel); }
function isYaml(rel) { return /\.ya?ml$/i.test(rel); }
function isSidebarYaml(rel) {
  return /(^|[\\/])sidebar\.ya?ml$/i.test(rel);
}

// --- DISCOVER LOCALES (exact approach as scripts/i18n.mjs) ---
function discoverLocalesFromI18n() {
  if (!fs.existsSync(I18N_DIR)) {
    console.error(`[i18n-docs] Not found: ${path.relative(ROOT, I18N_DIR)}`); // mirrors i18n.mjs sanity
    process.exit(1);
  }
  const langFiles = fs.readdirSync(I18N_DIR).filter(isLangFile); // same filter
  if (langFiles.length === 0) {
    console.error("[i18n-docs] No language files found in src/i18n");
    process.exit(1);
  }
  // Derive codes from filenames (e.g., "ru.js" -> "ru"), skip en.js
  const codes = langFiles
    .map(f => path.basename(f, ".js"))
    .filter(code => code !== "en");
  // Ensure doc folders exist
  for (const code of codes) {
    const dir = path.join(DEV_DOCS_DIR, code);
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
  }
  return codes;
}

// scripts/i18n-docs.mjs — helpers to unwrap accidental code fences
function unwrapCodeFence(text) {
  if (!text) return text;
  const s = String(text).trim();

  // ```[lang]\n...content...\n```
  const fenceRe = /^```[a-z0-9_-]*\s*\n([\s\S]*?)\n```$/i;
  const m = s.match(fenceRe);
  if (m) return m[1].trim();

  // ```...``` (single-line fallback)
  const fenceSingle = /^```([\s\S]*?)```$/;
  const m2 = s.match(fenceSingle);
  if (m2) return m2[1].trim();

  return s;
}

// scripts/i18n-docs.mjs — replace translateMarkdownTo with this version
async function translateMarkdownTo(langCode, markdown) {
  const sys =
    "You are a professional technical translator. Translate user-visible prose while preserving Markdown structure, " +
    "code fences, inline code, raw HTML, YAML frontmatter, and URLs. Do NOT translate code. " +
    "Do NOT wrap the output in triple backticks or any code fences.";
  const user =
    `Target language: ${langCode}\n` +
    "Return ONLY the translated Markdown text (no surrounding code fences).\n\n" +
    // important: we no longer wrap the input inside ```...```
    "Input Markdown follows below:\n\n" +
    markdown;

  const res = await openai.chat.completions.create({
    model: OPENAI_MODEL,
    temperature: 0.2,
    messages: [
      { role: "system", content: sys },
      { role: "user", content: user },
    ],
  });

  const raw = (res.choices?.[0]?.message?.content || "").trim();
  return unwrapCodeFence(raw);
}


async function translateSidebarYamlTo(langCode, text) {
  let doc; try { doc = yaml.load(text) ?? {}; } catch { return text; }
  const strings = [];
  (function collect(o) {
    if (Array.isArray(o)) o.forEach(collect);
    else if (o && typeof o === "object") {
      for (const [k, v] of Object.entries(o)) {
        if ((k === "title" || k === "label") && typeof v === "string") strings.push(v);
        else collect(v);
      }
    }
  })(doc);
  if (!strings.length) return text;

  const res = await openai.chat.completions.create({
    model: OPENAI_MODEL, temperature: 0.2, response_format: { type: "json_object" },
    messages: [
      { role: "system", content: "Translate UI strings. Return JSON { list: [...] } in the same order." },
      { role: "user", content: JSON.stringify({ target_language: langCode, list: strings }) },
    ],
  });
  let translated = [];
  try { translated = JSON.parse(res.choices?.[0]?.message?.content || "{}").list || []; } catch {}
  if (translated.length !== strings.length) return text;

  let idx = 0;
  (function inject(o) {
    if (Array.isArray(o)) o.forEach(inject);
    else if (o && typeof o === "object") {
      for (const k of Object.keys(o)) {
        const v = o[k];
        if ((k === "title" || k === "label") && typeof v === "string") o[k] = translated[idx++];
        else inject(v);
      }
    }
  })(doc);

  // scripts/i18n-docs.mjs — at the end of translateSidebarYamlTo
const outYaml = yaml.dump(doc, { lineWidth: 1000, quotingType: '"' });
// guard: never fenced
return unwrapCodeFence(outYaml);
}

// --- MAIN ---
async function main() {
  const locales = discoverLocalesFromI18n();
  console.log(`[i18n-docs] Locales: ${locales.join(", ") || "(none)"}`);

  const enFiles = englishMap(); // Map<rel, abs>

  for (const lang of locales) {
    const targetDir = path.join(DEV_DOCS_DIR, lang);
    const statePath = path.join(targetDir, STATE_FILE);
    const state = loadJson(statePath); // { "<rel>": "<sha256(en)>" }

    // 1) Remove stray files
    for (const rel of listLocaleFiles(targetDir)) {
      if (!enFiles.has(rel)) {
        console.log(`[i18n-docs] ${lang} remove stray: ${rel}`);
        removeFileSafe(path.join(targetDir, rel));
        delete state[rel];
      }
    }

    // 2) Translate changed/missing
    let updated = 0;
    for (const [rel, enAbs] of enFiles.entries()) {
      const enBuf = readFileSafe(enAbs); if (!enBuf) continue;
      const enHash = sha256(enBuf);
      const outAbs = path.join(targetDir, rel);
      const prevHash = state[rel] || "";

      const needTranslate = (() => {
        if (!fs.existsSync(outAbs)) return true;
        if (prevHash && prevHash === enHash) return false; // unchanged since last time
        try {
          const enStat = fs.statSync(enAbs);
          const tStat = fs.statSync(outAbs);
          return enStat.mtimeMs > tStat.mtimeMs; // EN newer than target
        } catch { return true; }
      })();
      if (!needTranslate) continue;

      let outText;
      if (isMarkdown(rel)) {
        console.log(`[i18n-docs] ${lang} ← ${rel} (md)`);
        outText = await translateMarkdownTo(lang, enBuf.toString("utf8"));
      } else if (isYaml(rel) && isSidebarYaml(rel)) {
        console.log(`[i18n-docs] ${lang} ← ${rel} (sidebar.yaml)`);
        outText = await translateSidebarYamlTo(lang, enBuf.toString("utf8"));
      } else {
        console.log(`[i18n-docs] ${lang} copy (verbatim): ${rel}`);
        outText = enBuf.toString("utf8");
      }

      writeFileSafe(outAbs, outText);
      state[rel] = enHash;
      updated++;
    }

    saveJson(statePath, state);
    console.log(`[i18n-docs] ${lang} done: ${updated} updated`);
  }

  console.log("[i18n-docs] All locales complete.");
}

main().catch((err) => { console.error(err); process.exit(1); });
</file>

<file path="src/alerts/AlertManager.jsx">
// src/alerts/AlertManager.jsx
import { onMount } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import { alertRegistry } from "./registry.js";
import { dbg } from "../utils/debug.js";

export default function AlertManager() {
  const app = useApp();

  onMount(() => {
    // Subscribe to all events from the WebSocket bus.
    const unsubscribe = app.alertBus.on("*", ({ type, payload }) => {
      const handler = alertRegistry[type];
      if (handler) {
        try {
          handler(app, payload);
        } catch (error) {
          dbg.error("AlertManager", `Error in handler for '${type}':`, error);
        }
      } else {
        // Optional: Log unhandled events for development purposes.
        dbg.log("AlertManager", `No handler for alert type: '${type}'`);
      }
    });

    // The component doesn't unmount in this app, but this is good practice.
    return () => unsubscribe();
  });

  return null; // This component does not render anything.
}
</file>

<file path="src/blockchain/abi/AuthorOfTheMonth.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_initialOwner",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "Award",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "Sacrifice",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "awardAll",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "domainList",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "_domain",
        "type": "string"
      }
    ],
    "name": "get3Leaders",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "_domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "_nominant",
        "type": "address"
      }
    ],
    "name": "getNominantInfo",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "_domain",
        "type": "string"
      }
    ],
    "name": "getTotalSacrificed",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "_domain",
        "type": "string"
      }
    ],
    "name": "getWinner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "lastAwardTime",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "nextAwardTime",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "period",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "_domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "_author",
        "type": "address"
      }
    ],
    "name": "sacrifice",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_nextAwardTime",
        "type": "uint256"
      }
    ],
    "name": "setNextAwardTime",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_period",
        "type": "uint256"
      }
    ],
    "name": "setPeriod",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/AuthorsClubs.json">
[
  {
    "inputs": [
      {
        "internalType": "contract IConfig",
        "name": "_config",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "test",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "SafeERC20FailedOperation",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountPerWeek",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "n_weeks",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "totalAmount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "currentFrame",
        "type": "uint256"
      }
    ],
    "name": "Buy",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "currentFrame",
        "type": "uint256"
      }
    ],
    "name": "Claim",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "ClaimedStakingGain",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "refunded",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "currentFrame",
        "type": "uint256"
      }
    ],
    "name": "Stopped",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amountPerWeek",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "n_weeks",
        "type": "uint256"
      }
    ],
    "name": "buy",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amountPerWeek",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "n_weeks",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "_v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "_r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "_s",
        "type": "bytes32"
      }
    ],
    "name": "buyWithPermit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "content_type",
        "type": "bytes32"
      }
    ],
    "name": "claim",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimStakingGain",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      }
    ],
    "name": "claimableGain",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "clubs",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "lastClaimedWeek",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "currentFrame",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      }
    ],
    "name": "getClub",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256[52]",
        "name": "",
        "type": "uint256[52]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "frame",
        "type": "uint256"
      }
    ],
    "name": "getFrame",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      }
    ],
    "name": "getSub",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      }
    ],
    "name": "stop",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "subs",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountPerWeek",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "til_frame",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/BuyBurn.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_initialOwner",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "swapped",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "Bought",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "Burned",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "burn",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "buy",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "buyAndBurn",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getBalance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getSavvaBalance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalBurned",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "withdraw",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "stateMutability": "payable",
    "type": "receive"
  }
]
</file>

<file path="src/blockchain/abi/Config.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_initialOwner",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "value",
        "type": "address"
      }
    ],
    "name": "ConfigAddressSet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "value",
        "type": "string"
      }
    ],
    "name": "ConfigSet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "ConfigUintSet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "config",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "configAddress",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "configUint",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      }
    ],
    "name": "get",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      }
    ],
    "name": "getAddr",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      }
    ],
    "name": "getUInt",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "string",
        "name": "value",
        "type": "string"
      }
    ],
    "name": "set",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "value",
        "type": "address"
      }
    ],
    "name": "setAddr",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "setUInt",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/ContentFund.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "nft_owner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "ClaimedNFTGain",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "savva_cid",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "contributor",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "contributed",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "author_share",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "nft_share",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "nft_owner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "round_time",
        "type": "uint256"
      }
    ],
    "name": "ContributeEvent",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "savva_cid",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "winner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "prize",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "round_time",
        "type": "uint256"
      }
    ],
    "name": "PrizeEvent",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "SLRoot",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimNFTGain",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "claimableNftGain",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "guid",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "contribute",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "guid",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "contributeWithPermit",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "funds",
    "outputs": [
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "guid",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "total_contributed",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "round_time",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "SLLeft",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "SLRight",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "savva_cid",
        "type": "uint256"
      }
    ],
    "name": "getFund",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "author",
            "type": "address"
          },
          {
            "internalType": "string",
            "name": "domain",
            "type": "string"
          },
          {
            "internalType": "string",
            "name": "guid",
            "type": "string"
          },
          {
            "components": [
              {
                "internalType": "address",
                "name": "contributor",
                "type": "address"
              },
              {
                "internalType": "uint256",
                "name": "contributed_before",
                "type": "uint256"
              }
            ],
            "internalType": "struct ContentFund.Contribution[]",
            "name": "contributions",
            "type": "tuple[]"
          },
          {
            "internalType": "uint256",
            "name": "total_contributed",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "round_time",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "SLLeft",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "SLRight",
            "type": "uint256"
          }
        ],
        "internalType": "struct ContentFund.Fund",
        "name": "",
        "type": "tuple"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "getNftOwner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "savva_cid",
        "type": "uint256"
      }
    ],
    "name": "getNumberOfContributions",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "savva_cid",
        "type": "uint256"
      }
    ],
    "name": "getTotalContributed",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "isTimeToProcess",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "nftOwnerGain",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "max_rounds",
        "type": "uint256"
      }
    ],
    "name": "processRounds",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/ContentNFT.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "ERC721EnumerableForbiddenBatchMint",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "ERC721IncorrectOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "operator",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "ERC721InsufficientApproval",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "approver",
        "type": "address"
      }
    ],
    "name": "ERC721InvalidApprover",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "operator",
        "type": "address"
      }
    ],
    "name": "ERC721InvalidOperator",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "ERC721InvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "receiver",
        "type": "address"
      }
    ],
    "name": "ERC721InvalidReceiver",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "ERC721InvalidSender",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "ERC721NonexistentToken",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "index",
        "type": "uint256"
      }
    ],
    "name": "ERC721OutOfBoundsIndex",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "approved",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "operator",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bool",
        "name": "approved",
        "type": "bool"
      }
    ],
    "name": "ApprovalForAll",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "_fromTokenId",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "_toTokenId",
        "type": "uint256"
      }
    ],
    "name": "BatchMetadataUpdate",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "_tokenId",
        "type": "uint256"
      }
    ],
    "name": "MetadataUpdate",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "token_id",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "guid",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "uri",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "Mint",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "burn",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "getApproved",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "operator",
        "type": "address"
      }
    ],
    "name": "isApprovedForAll",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "guid",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "uri",
        "type": "string"
      }
    ],
    "name": "mint",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "ownerOf",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "safeTransferFrom",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "safeTransferFrom",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "operator",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "approved",
        "type": "bool"
      }
    ],
    "name": "setApprovalForAll",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes4",
        "name": "interfaceId",
        "type": "bytes4"
      }
    ],
    "name": "supportsInterface",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "index",
        "type": "uint256"
      }
    ],
    "name": "tokenByIndex",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "index",
        "type": "uint256"
      }
    ],
    "name": "tokenOfOwnerByIndex",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "tokenURI",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/ContentRegistry.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "admin",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "command",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "p1",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "p2",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "p3",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "p4",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "Command",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "poster",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "guid",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "ipfs",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "content_type",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "savva_cid",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "RegEvent",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "allowed_address",
        "type": "address"
      }
    ],
    "name": "allow",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "allowed",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "cmd",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "p1",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "p2",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "p3",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "p4",
        "type": "string"
      }
    ],
    "name": "command",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "allowed_address",
        "type": "address"
      }
    ],
    "name": "disallow",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "string",
        "name": "guid",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "ipfs",
        "type": "string"
      },
      {
        "internalType": "bytes32",
        "name": "content_type",
        "type": "bytes32"
      }
    ],
    "name": "reg",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string[]",
        "name": "domains",
        "type": "string[]"
      },
      {
        "internalType": "string[]",
        "name": "guids",
        "type": "string[]"
      },
      {
        "internalType": "string[]",
        "name": "ipfss",
        "type": "string[]"
      },
      {
        "internalType": "bytes32[]",
        "name": "content_types",
        "type": "bytes32[]"
      }
    ],
    "name": "regArray",
    "outputs": [
      {
        "internalType": "uint256[]",
        "name": "",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/Fundraiser.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_initialOwner",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "SafeERC20FailedOperation",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "id",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "creator",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "totalCollected",
        "type": "uint256"
      }
    ],
    "name": "CampaignClosed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "id",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "title",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "targetAmount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "creator",
        "type": "address"
      }
    ],
    "name": "CampaignCreated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "id",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "contributor",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "creator",
        "type": "address"
      }
    ],
    "name": "ContributionReceived",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bool",
        "name": "status",
        "type": "bool"
      }
    ],
    "name": "TokenAccepted",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "acceptedTokens",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "campaignCounter",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "campaigns",
    "outputs": [
      {
        "internalType": "string",
        "name": "title",
        "type": "string"
      },
      {
        "internalType": "address",
        "name": "creator",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "targetAmount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "totalContributed",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "campaignId",
        "type": "uint256"
      }
    ],
    "name": "closeCampaign",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "campaignId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "fromToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      }
    ],
    "name": "contribute",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "campaignId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "fromToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "_v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "_r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "_s",
        "type": "bytes32"
      }
    ],
    "name": "contributeWithPermit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "title",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "targetAmount",
        "type": "uint256"
      }
    ],
    "name": "createCampaign",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getAcceptedTokens",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "status",
        "type": "bool"
      }
    ],
    "name": "setAcceptedToken",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/Governance.json">
[
  {
    "inputs": [
      {
        "internalType": "contract IVotes",
        "name": "_token",
        "type": "address"
      },
      {
        "internalType": "contract IConfig",
        "name": "_config",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "CheckpointUnorderedInsertion",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "FailedCall",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "voter",
        "type": "address"
      }
    ],
    "name": "GovernorAlreadyCastVote",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "GovernorAlreadyQueuedProposal",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "GovernorDisabledDeposit",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "proposer",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "votes",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "threshold",
        "type": "uint256"
      }
    ],
    "name": "GovernorInsufficientProposerVotes",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "targets",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "calldatas",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "values",
        "type": "uint256"
      }
    ],
    "name": "GovernorInvalidProposalLength",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "quorumNumerator",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "quorumDenominator",
        "type": "uint256"
      }
    ],
    "name": "GovernorInvalidQuorumFraction",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "voter",
        "type": "address"
      }
    ],
    "name": "GovernorInvalidSignature",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "GovernorInvalidVoteParams",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "GovernorInvalidVoteType",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "votingPeriod",
        "type": "uint256"
      }
    ],
    "name": "GovernorInvalidVotingPeriod",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "GovernorNonexistentProposal",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "GovernorNotQueuedProposal",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "GovernorOnlyExecutor",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "GovernorQueueNotImplemented",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "proposer",
        "type": "address"
      }
    ],
    "name": "GovernorRestrictedProposer",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "GovernorUnableToCancel",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "internalType": "enum IGovernor.ProposalState",
        "name": "current",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "expectedStates",
        "type": "bytes32"
      }
    ],
    "name": "GovernorUnexpectedProposalState",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "currentNonce",
        "type": "uint256"
      }
    ],
    "name": "InvalidAccountNonce",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidShortString",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint8",
        "name": "bits",
        "type": "uint8"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "SafeCastOverflowedUintDowncast",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "str",
        "type": "string"
      }
    ],
    "name": "StringTooLong",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [],
    "name": "EIP712DomainChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "ProposalCanceled",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "proposer",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address[]",
        "name": "targets",
        "type": "address[]"
      },
      {
        "indexed": false,
        "internalType": "uint256[]",
        "name": "values",
        "type": "uint256[]"
      },
      {
        "indexed": false,
        "internalType": "string[]",
        "name": "signatures",
        "type": "string[]"
      },
      {
        "indexed": false,
        "internalType": "bytes[]",
        "name": "calldatas",
        "type": "bytes[]"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "voteStart",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "voteEnd",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "description",
        "type": "string"
      }
    ],
    "name": "ProposalCreated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "ProposalExecuted",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "etaSeconds",
        "type": "uint256"
      }
    ],
    "name": "ProposalQueued",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "oldProposalThreshold",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "newProposalThreshold",
        "type": "uint256"
      }
    ],
    "name": "ProposalThresholdSet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "oldQuorumNumerator",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "newQuorumNumerator",
        "type": "uint256"
      }
    ],
    "name": "QuorumNumeratorUpdated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "voter",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "support",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "weight",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "reason",
        "type": "string"
      }
    ],
    "name": "VoteCast",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "voter",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint8",
        "name": "support",
        "type": "uint8"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "weight",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "reason",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "bytes",
        "name": "params",
        "type": "bytes"
      }
    ],
    "name": "VoteCastWithParams",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "oldVotingDelay",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "newVotingDelay",
        "type": "uint256"
      }
    ],
    "name": "VotingDelaySet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "oldVotingPeriod",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "newVotingPeriod",
        "type": "uint256"
      }
    ],
    "name": "VotingPeriodSet",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "BALLOT_TYPEHASH",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "CLOCK_MODE",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "COUNTING_MODE",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "EXTENDED_BALLOT_TYPEHASH",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "balances",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "targets",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "values",
        "type": "uint256[]"
      },
      {
        "internalType": "bytes[]",
        "name": "calldatas",
        "type": "bytes[]"
      },
      {
        "internalType": "bytes32",
        "name": "descriptionHash",
        "type": "bytes32"
      }
    ],
    "name": "cancel",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "support",
        "type": "uint8"
      }
    ],
    "name": "castVote",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "support",
        "type": "uint8"
      },
      {
        "internalType": "address",
        "name": "voter",
        "type": "address"
      },
      {
        "internalType": "bytes",
        "name": "signature",
        "type": "bytes"
      }
    ],
    "name": "castVoteBySig",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "support",
        "type": "uint8"
      },
      {
        "internalType": "string",
        "name": "reason",
        "type": "string"
      }
    ],
    "name": "castVoteWithReason",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "support",
        "type": "uint8"
      },
      {
        "internalType": "string",
        "name": "reason",
        "type": "string"
      },
      {
        "internalType": "bytes",
        "name": "params",
        "type": "bytes"
      }
    ],
    "name": "castVoteWithReasonAndParams",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "support",
        "type": "uint8"
      },
      {
        "internalType": "address",
        "name": "voter",
        "type": "address"
      },
      {
        "internalType": "string",
        "name": "reason",
        "type": "string"
      },
      {
        "internalType": "bytes",
        "name": "params",
        "type": "bytes"
      },
      {
        "internalType": "bytes",
        "name": "signature",
        "type": "bytes"
      }
    ],
    "name": "castVoteWithReasonAndParamsBySig",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "clock",
    "outputs": [
      {
        "internalType": "uint48",
        "name": "",
        "type": "uint48"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "deposit",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "eip712Domain",
    "outputs": [
      {
        "internalType": "bytes1",
        "name": "fields",
        "type": "bytes1"
      },
      {
        "internalType": "string",
        "name": "name",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "version",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "chainId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "verifyingContract",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "salt",
        "type": "bytes32"
      },
      {
        "internalType": "uint256[]",
        "name": "extensions",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "targets",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "values",
        "type": "uint256[]"
      },
      {
        "internalType": "bytes[]",
        "name": "calldatas",
        "type": "bytes[]"
      },
      {
        "internalType": "bytes32",
        "name": "descriptionHash",
        "type": "bytes32"
      }
    ],
    "name": "execute",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "targets",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "values",
        "type": "uint256[]"
      },
      {
        "internalType": "bytes[]",
        "name": "calldatas",
        "type": "bytes[]"
      },
      {
        "internalType": "bytes32",
        "name": "descriptionHash",
        "type": "bytes32"
      }
    ],
    "name": "getProposalId",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "timepoint",
        "type": "uint256"
      }
    ],
    "name": "getVotes",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "timepoint",
        "type": "uint256"
      },
      {
        "internalType": "bytes",
        "name": "params",
        "type": "bytes"
      }
    ],
    "name": "getVotesWithParams",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "hasVoted",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "targets",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "values",
        "type": "uint256[]"
      },
      {
        "internalType": "bytes[]",
        "name": "calldatas",
        "type": "bytes[]"
      },
      {
        "internalType": "bytes32",
        "name": "descriptionHash",
        "type": "bytes32"
      }
    ],
    "name": "hashProposal",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "nonces",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256[]",
        "name": "",
        "type": "uint256[]"
      },
      {
        "internalType": "uint256[]",
        "name": "",
        "type": "uint256[]"
      },
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "name": "onERC1155BatchReceived",
    "outputs": [
      {
        "internalType": "bytes4",
        "name": "",
        "type": "bytes4"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "name": "onERC1155Received",
    "outputs": [
      {
        "internalType": "bytes4",
        "name": "",
        "type": "bytes4"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "name": "onERC721Received",
    "outputs": [
      {
        "internalType": "bytes4",
        "name": "",
        "type": "bytes4"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "proposalDeadline",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "proposalEta",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "proposalNeedsQueuing",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "proposalProposer",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "proposalSnapshot",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "proposalThreshold",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "proposalVotes",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "againstVotes",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "forVotes",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "abstainVotes",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "targets",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "values",
        "type": "uint256[]"
      },
      {
        "internalType": "bytes[]",
        "name": "calldatas",
        "type": "bytes[]"
      },
      {
        "internalType": "string",
        "name": "description",
        "type": "string"
      }
    ],
    "name": "propose",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address[]",
        "name": "targets",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "values",
        "type": "uint256[]"
      },
      {
        "internalType": "bytes[]",
        "name": "calldatas",
        "type": "bytes[]"
      },
      {
        "internalType": "bytes32",
        "name": "descriptionHash",
        "type": "bytes32"
      }
    ],
    "name": "queue",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "blockNumber",
        "type": "uint256"
      }
    ],
    "name": "quorum",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "quorumDenominator",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "timepoint",
        "type": "uint256"
      }
    ],
    "name": "quorumNumerator",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "quorumNumerator",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "target",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      },
      {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }
    ],
    "name": "relay",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "newProposalThreshold",
        "type": "uint256"
      }
    ],
    "name": "setProposalThreshold",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint48",
        "name": "newVotingDelay",
        "type": "uint48"
      }
    ],
    "name": "setVotingDelay",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint32",
        "name": "newVotingPeriod",
        "type": "uint32"
      }
    ],
    "name": "setVotingPeriod",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "proposalId",
        "type": "uint256"
      }
    ],
    "name": "state",
    "outputs": [
      {
        "internalType": "enum IGovernor.ProposalState",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes4",
        "name": "interfaceId",
        "type": "bytes4"
      }
    ],
    "name": "supportsInterface",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "token",
    "outputs": [
      {
        "internalType": "contract IERC5805",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "newQuorumNumerator",
        "type": "uint256"
      }
    ],
    "name": "updateQuorumNumerator",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "version",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "votingDelay",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "votingPeriod",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "withdraw",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "stateMutability": "payable",
    "type": "receive"
  }
]
</file>

<file path="src/blockchain/abi/IContentFund.json">
[
  {
    "inputs": [],
    "name": "claimNFTGain",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "nftOwnerGain",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/IPulseXFactory.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "tokenA",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "tokenB",
        "type": "address"
      }
    ],
    "name": "getPair",
    "outputs": [
      {
        "internalType": "address",
        "name": "pair",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/IPulseXRouter.json">
[
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amountOutMin",
        "type": "uint256"
      },
      {
        "internalType": "address[]",
        "name": "path",
        "type": "address[]"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "swapExactTokensForTokens",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amountOutMin",
        "type": "uint256"
      },
      {
        "internalType": "address[]",
        "name": "path",
        "type": "address[]"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "swapExactTokensForTokensV1",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amountOutMin",
        "type": "uint256"
      },
      {
        "internalType": "address[]",
        "name": "path",
        "type": "address[]"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "swapExactTokensForTokensV2",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amountOutMin",
        "type": "uint256"
      },
      {
        "internalType": "address[]",
        "name": "path",
        "type": "address[]"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "swapExactTokensForTokensV3",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "payable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/IStaking.json">
[
  {
    "inputs": [],
    "name": "claimGain",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "claimable",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/IWPLS.json">
[
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "deposit",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "withdraw",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/ListMarket.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_collector",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_initialOwner",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "string",
        "name": "list_name",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "buyer",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "Bought",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "string",
        "name": "list_name",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "PriceSet",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "list_name",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "savva_cid",
        "type": "string"
      }
    ],
    "name": "buy",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "collector",
    "outputs": [
      {
        "internalType": "address payable",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "list_name",
        "type": "string"
      }
    ],
    "name": "getPrice",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "name": "prices",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address payable",
        "name": "_collector",
        "type": "address"
      }
    ],
    "name": "setCollector",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "list_name",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "name": "setPrice",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/NFTAuction.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "SafeERC20FailedOperation",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "AuctionCancelled",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "seller",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "startingPrice",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "endTime",
        "type": "uint256"
      }
    ],
    "name": "AuctionCreated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "seller",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "winner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "winningBid",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "bidToken",
        "type": "address"
      }
    ],
    "name": "AuctionFinalized",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "seller",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "bidder",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "bidAmount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "bidToken",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "refundAddress",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "refundAmount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "refundToken",
        "type": "address"
      }
    ],
    "name": "BidPlaced",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "ClaimedNftGain",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "ClaimedStakingGain",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "RefundWithdrawn",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "auctions",
    "outputs": [
      {
        "internalType": "address",
        "name": "seller",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "startingPrice",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "highestBid",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "highestBidder",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "endTime",
        "type": "uint256"
      },
      {
        "internalType": "bool",
        "name": "active",
        "type": "bool"
      },
      {
        "internalType": "address",
        "name": "bidToken",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "cancelAuction",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimNftGain",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimStakingGain",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "startingPrice",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "duration",
        "type": "uint256"
      }
    ],
    "name": "createAuction",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "finalizeAuction",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "name": "onERC721Received",
    "outputs": [
      {
        "internalType": "bytes4",
        "name": "",
        "type": "bytes4"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "bidAmount",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "tokenAddress",
        "type": "address"
      }
    ],
    "name": "placeBid",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "bidAmount",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "tokenAddress",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "placeBidWithPermit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "refunds",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "tokenAddress",
        "type": "address"
      }
    ],
    "name": "withdrawRefund",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/NFTMarketplace.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "token_id",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "name": "NFTAddedToMarket",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "token_id",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "old_owner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "new_owner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "name": "NFTBought",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "token_id",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "old_owner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "new_owner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "new_price",
        "type": "uint256"
      }
    ],
    "name": "NFTOwnerChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "token_id",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "name": "NFTPriceChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "token_id",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "NFTRemovedFromMarket",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "name": "addToMarket",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "buy",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "new_price",
        "type": "uint256"
      }
    ],
    "name": "buyAndLeaveOnMarket",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "buyWithPermit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "name": "changePrice",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "getNFTOwner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "getPrice",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "nfts",
    "outputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "nftsByOwner",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "name": "onERC721Received",
    "outputs": [
      {
        "internalType": "bytes4",
        "name": "",
        "type": "bytes4"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "tokenId",
        "type": "uint256"
      }
    ],
    "name": "removeFromMarket",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/Promo.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_initialOwner",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "donator",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "savva_amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "hash",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "pls_amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "valid_till",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "PromoCodeCreated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "donator",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "savva_amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "hash",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "secret",
        "type": "string"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "pls_amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "valid_till",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "PromoCodeRedeemed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "donator",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "savva_amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "hash",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "pls_amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "valid_till",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "PromoCodeReturned",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_savva_amount",
        "type": "uint256"
      },
      {
        "internalType": "bytes32",
        "name": "_hash",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "_valid_till",
        "type": "uint256"
      }
    ],
    "name": "createPromoCode",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_savva_amount",
        "type": "uint256"
      },
      {
        "internalType": "bytes32",
        "name": "_hash",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "_valid_till",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "_v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "_r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "_s",
        "type": "bytes32"
      }
    ],
    "name": "createPromoCodeWithPermit",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "_hash",
        "type": "bytes32"
      }
    ],
    "name": "getPromoCode",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "donator",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "savva_amount",
            "type": "uint256"
          },
          {
            "internalType": "bytes32",
            "name": "hash",
            "type": "bytes32"
          },
          {
            "internalType": "uint256",
            "name": "pls_amount",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "valid_till",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "index",
            "type": "uint256"
          }
        ],
        "internalType": "struct Promo.PromoCode",
        "name": "",
        "type": "tuple"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getPromoCodesCount",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "hasExpiredPromoCodes",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "_hash",
        "type": "bytes32"
      }
    ],
    "name": "isHashValid",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "processor_fee",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "promoCodes",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "promoCodesMap",
    "outputs": [
      {
        "internalType": "address",
        "name": "donator",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "savva_amount",
        "type": "uint256"
      },
      {
        "internalType": "bytes32",
        "name": "hash",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "pls_amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "valid_till",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "index",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "_hash",
        "type": "bytes32"
      },
      {
        "internalType": "string",
        "name": "_secret",
        "type": "string"
      },
      {
        "internalType": "address payable",
        "name": "_user",
        "type": "address"
      }
    ],
    "name": "redeemPromoCode",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "maxDeletes",
        "type": "uint256"
      }
    ],
    "name": "returnAllExpired",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "_hash",
        "type": "bytes32"
      }
    ],
    "name": "returnExpired",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address payable",
        "name": "_processor",
        "type": "address"
      }
    ],
    "name": "setProcessor",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_fee",
        "type": "uint256"
      }
    ],
    "name": "setProcessorFee",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/RandomOracle.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_initialOwner",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "random",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "db_index",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "RandomUpdated",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "db_index",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getLastUpdateTime",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getRandom",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "lastUpdateTime",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "random",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_updaterAccount",
        "type": "address"
      }
    ],
    "name": "setUpdaterAccount",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_random",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_db_index",
        "type": "uint256"
      }
    ],
    "name": "update",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "updaterAccount",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/SafeERC20.json">
[]
</file>

<file path="src/blockchain/abi/SavvaFaucet.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "_round_seconds",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "Deposit",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "round",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "tokensToShare",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "RoundFinished",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "TokensSent",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "timestamp",
        "type": "uint256"
      }
    ],
    "name": "claimed",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address payable",
        "name": "newOrigin",
        "type": "address"
      }
    ],
    "name": "ChangeOrigin",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "IsRoundFinished",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "NumberOfDepositors",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "ORIGIN_ADDRESS",
    "outputs": [
      {
        "internalType": "address payable",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "TokensToShare",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claim",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "claimable",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "deposit",
    "outputs": [],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "deposited",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "finishRound",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "name": "finishedRounds",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "total",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "perShare",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getRoundLength",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "get_deposited",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "lastRoundPayWeek",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "pay_week",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "roundPayWeek",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "roundTokensToShare",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "roundTotalDepositors",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "roundTotalDeposits",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "stateMutability": "payable",
    "type": "receive"
  }
]
</file>

<file path="src/blockchain/abi/SavvaNPO.json">
[
  {
    "inputs": [],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "addAdmin",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "bytes32[]",
        "name": "roleNames_",
        "type": "bytes32[]"
      }
    ],
    "name": "addMember",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "addSupportedToken",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "bytes32[]",
        "name": "newRoles",
        "type": "bytes32[]"
      }
    ],
    "name": "changeMemberRoles",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "confirmMembership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getAdmins",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getMemberList",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "getMemberRoles",
    "outputs": [
      {
        "internalType": "bytes32[]",
        "name": "",
        "type": "bytes32[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "getMemberWeeklyLimit",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getRoleList",
    "outputs": [
      {
        "internalType": "bytes32[]",
        "name": "",
        "type": "bytes32[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      }
    ],
    "name": "getRolePermissions",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "targetContract",
            "type": "address"
          },
          {
            "internalType": "bytes4[]",
            "name": "allowedFunctions",
            "type": "bytes4[]"
          }
        ],
        "internalType": "struct SavvaNPO.Permission[]",
        "name": "",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "getSpentByTokenAndWeek",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "getSupportedTokens",
    "outputs": [
      {
        "internalType": "address[]",
        "name": "",
        "type": "address[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "addr",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      }
    ],
    "name": "hasRole",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_conf",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "first_admin",
        "type": "address"
      }
    ],
    "name": "initialize",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "isAdmin",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "isConfirmed",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "addr",
        "type": "address"
      }
    ],
    "name": "isMember",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "isMemberConfirmed",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "members",
    "outputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "bool",
        "name": "confirmed",
        "type": "bool"
      },
      {
        "internalType": "uint256",
        "name": "lastWeekChecked",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "target",
            "type": "address"
          },
          {
            "internalType": "bytes",
            "name": "data",
            "type": "bytes"
          },
          {
            "internalType": "uint256",
            "name": "value",
            "type": "uint256"
          }
        ],
        "internalType": "struct SavvaNPO.Call[]",
        "name": "calls",
        "type": "tuple[]"
      }
    ],
    "name": "multicall",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      },
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "name": "onERC721Received",
    "outputs": [
      {
        "internalType": "bytes4",
        "name": "",
        "type": "bytes4"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "removeAdmin",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "removeMember",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      }
    ],
    "name": "removeRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "removeSupportedToken",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      },
      {
        "components": [
          {
            "internalType": "address",
            "name": "targetContract",
            "type": "address"
          },
          {
            "internalType": "bytes4[]",
            "name": "allowedFunctions",
            "type": "bytes4[]"
          }
        ],
        "internalType": "struct SavvaNPO.Permission[]",
        "name": "perms",
        "type": "tuple[]"
      }
    ],
    "name": "setRole",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "unconfirmMembership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "newLimit",
        "type": "uint256"
      }
    ],
    "name": "updateWeeklyLimit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "withdrawERC20",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "withdrawNative",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "stateMutability": "payable",
    "type": "receive"
  }
]
</file>

<file path="src/blockchain/abi/SavvaNPOEvents.json">
[
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "AdminAdded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "AdminRemoved",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "target",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes4",
        "name": "selector",
        "type": "bytes4"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "FunctionCalled",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "MemberAdded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "MemberConfirmed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "MemberRemoved",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes32[]",
        "name": "newRoles",
        "type": "bytes32[]"
      }
    ],
    "name": "MemberRolesChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "MemberUnconfirmed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "firstAdmin",
        "type": "address"
      }
    ],
    "name": "NPOCreated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      }
    ],
    "name": "RoleCreated",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      }
    ],
    "name": "RoleModified",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      }
    ],
    "name": "RoleRemoved",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "SupportedTokenAdded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "SupportedTokenRemoved",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "TokenSpent",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "TokenWithdrawn",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "newLimit",
        "type": "uint256"
      }
    ],
    "name": "WeeklyLimitUpdated",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "emitAdminAdded",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "emitAdminRemoved",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "target",
        "type": "address"
      },
      {
        "internalType": "bytes4",
        "name": "selector",
        "type": "bytes4"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "emitFunctionCalled",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "emitMemberAdded",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "emitMemberConfirmed",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "emitMemberRemoved",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "bytes32[]",
        "name": "newRoles",
        "type": "bytes32[]"
      }
    ],
    "name": "emitMemberRolesChanged",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      }
    ],
    "name": "emitMemberUnconfirmed",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "firstAdmin",
        "type": "address"
      }
    ],
    "name": "emitNPOCreated",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      }
    ],
    "name": "emitRoleCreated",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      }
    ],
    "name": "emitRoleModified",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "roleName",
        "type": "bytes32"
      }
    ],
    "name": "emitRoleRemoved",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "emitSupportedTokenAdded",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "emitSupportedTokenRemoved",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "emitTokenSpent",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "emitTokenWithdrawn",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "npo",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "member",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "newLimit",
        "type": "uint256"
      }
    ],
    "name": "emitWeeklyLimitUpdated",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/SavvaNPOFactory.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_conf",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "FailedDeployment",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "balance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "InsufficientBalance",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "clone",
        "type": "address"
      }
    ],
    "name": "SavvaNPOCloned",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "first_admin",
        "type": "address"
      }
    ],
    "name": "cloneSavvaNPO",
    "outputs": [
      {
        "internalType": "address",
        "name": "clone",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "salt",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "first_admin",
        "type": "address"
      }
    ],
    "name": "cloneSavvaNPODeterministic",
    "outputs": [
      {
        "internalType": "address",
        "name": "clone",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "conf",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "savvaNPOImplementation",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/SavvaSwap.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "ReentrancyGuardReentrantCall",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "token",
        "type": "address"
      }
    ],
    "name": "SafeERC20FailedOperation",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "caller",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "fromToken",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "toToken",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "name": "Swapped",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "last_amount_out",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "last_error",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "last_error_reason",
    "outputs": [
      {
        "internalType": "bytes",
        "name": "",
        "type": "bytes"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "fromToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "toToken",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "swapExact",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "toToken",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "swapExactNative",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "amountOut",
        "type": "uint256"
      }
    ],
    "stateMutability": "payable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "fromToken",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amountIn",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "toToken",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "swapExactTest",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "stateMutability": "payable",
    "type": "receive"
  }
]
</file>

<file path="src/blockchain/abi/SavvaToken.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_config",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "_initialOwner",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "ECDSAInvalidSignature",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "length",
        "type": "uint256"
      }
    ],
    "name": "ECDSAInvalidSignatureLength",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "ECDSAInvalidSignatureS",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allowance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "ERC20InsufficientAllowance",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "balance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "ERC20InsufficientBalance",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "approver",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidApprover",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "receiver",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidReceiver",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidSender",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidSpender",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      }
    ],
    "name": "ERC2612ExpiredSignature",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "signer",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "ERC2612InvalidSigner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "currentNonce",
        "type": "uint256"
      }
    ],
    "name": "InvalidAccountNonce",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidShortString",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "OwnableInvalidOwner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "OwnableUnauthorizedAccount",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "str",
        "type": "string"
      }
    ],
    "name": "StringTooLong",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [],
    "name": "EIP712DomainChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "OwnershipTransferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "burn",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "burnFrom",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "eip712Domain",
    "outputs": [
      {
        "internalType": "bytes1",
        "name": "fields",
        "type": "bytes1"
      },
      {
        "internalType": "string",
        "name": "name",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "version",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "chainId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "verifyingContract",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "salt",
        "type": "bytes32"
      },
      {
        "internalType": "uint256[]",
        "name": "extensions",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "mint",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "nonces",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "owner",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "permit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "renounceOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }
    ],
    "name": "transferOwnership",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/Staking.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_conf",
        "type": "address"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "inputs": [],
    "name": "CheckpointUnorderedInsertion",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ECDSAInvalidSignature",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "length",
        "type": "uint256"
      }
    ],
    "name": "ECDSAInvalidSignatureLength",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "ECDSAInvalidSignatureS",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "increasedSupply",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "cap",
        "type": "uint256"
      }
    ],
    "name": "ERC20ExceededSafeSupply",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "allowance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "ERC20InsufficientAllowance",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "balance",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "needed",
        "type": "uint256"
      }
    ],
    "name": "ERC20InsufficientBalance",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "approver",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidApprover",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "receiver",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidReceiver",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "sender",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidSender",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "ERC20InvalidSpender",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      }
    ],
    "name": "ERC2612ExpiredSignature",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "signer",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "ERC2612InvalidSigner",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "timepoint",
        "type": "uint256"
      },
      {
        "internalType": "uint48",
        "name": "clock",
        "type": "uint48"
      }
    ],
    "name": "ERC5805FutureLookup",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "ERC6372InconsistentClock",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "currentNonce",
        "type": "uint256"
      }
    ],
    "name": "InvalidAccountNonce",
    "type": "error"
  },
  {
    "inputs": [],
    "name": "InvalidShortString",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint8",
        "name": "bits",
        "type": "uint8"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "SafeCastOverflowedUintDowncast",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "str",
        "type": "string"
      }
    ],
    "name": "StringTooLong",
    "type": "error"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "expiry",
        "type": "uint256"
      }
    ],
    "name": "VotesExpiredSignature",
    "type": "error"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "staked",
        "type": "uint256"
      }
    ],
    "name": "ClaimUnstaked",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "staked",
        "type": "uint256"
      }
    ],
    "name": "Compounded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "delegator",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "fromDelegate",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "toDelegate",
        "type": "address"
      }
    ],
    "name": "DelegateChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "delegate",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "previousVotes",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "newVotes",
        "type": "uint256"
      }
    ],
    "name": "DelegateVotesChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [],
    "name": "EIP712DomainChanged",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "staked",
        "type": "uint256"
      }
    ],
    "name": "GainClaimed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "event_contract",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "event_id",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "staked",
        "type": "uint256"
      }
    ],
    "name": "PatronPaid",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "event_contract",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "event_id",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "staked",
        "type": "uint256"
      }
    ],
    "name": "PatronPaymentClaimed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "event_contract",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "event_id",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "author",
        "type": "address"
      }
    ],
    "name": "PayRecordDeleted",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "event_contract",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "event_id",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "user_staked",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "author_staked",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "paid",
        "type": "uint256"
      }
    ],
    "name": "PayRecordSet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "RewardDistribution",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "staked",
        "type": "uint256"
      }
    ],
    "name": "Staked",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "staked_from",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "staked_to",
        "type": "uint256"
      }
    ],
    "name": "Transferred",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "staked",
        "type": "uint256"
      }
    ],
    "name": "Unstaked",
    "type": "event"
  },
  {
    "inputs": [],
    "name": "CLOCK_MODE",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "DOMAIN_SEPARATOR",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      }
    ],
    "name": "allowance",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "approve",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "balanceOf",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint32",
        "name": "pos",
        "type": "uint32"
      }
    ],
    "name": "checkpoints",
    "outputs": [
      {
        "components": [
          {
            "internalType": "uint48",
            "name": "_key",
            "type": "uint48"
          },
          {
            "internalType": "uint208",
            "name": "_value",
            "type": "uint208"
          }
        ],
        "internalType": "struct Checkpoints.Checkpoint208",
        "name": "",
        "type": "tuple"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimGain",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "event_id",
        "type": "bytes32"
      }
    ],
    "name": "claimPayment",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "claimUnstaked",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "claimable",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "clock",
    "outputs": [
      {
        "internalType": "uint48",
        "name": "",
        "type": "uint48"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "compoundGain",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "config",
    "outputs": [
      {
        "internalType": "contract IConfig",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "decimals",
    "outputs": [
      {
        "internalType": "uint8",
        "name": "",
        "type": "uint8"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "delegatee",
        "type": "address"
      }
    ],
    "name": "delegate",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "delegatee",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "nonce",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "expiry",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "delegateBySig",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "delegates",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "event_contract",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "event_id",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      }
    ],
    "name": "deletePayRecord",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "distribute",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "eip712Domain",
    "outputs": [
      {
        "internalType": "bytes1",
        "name": "fields",
        "type": "bytes1"
      },
      {
        "internalType": "string",
        "name": "name",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "version",
        "type": "string"
      },
      {
        "internalType": "uint256",
        "name": "chainId",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "verifyingContract",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "salt",
        "type": "bytes32"
      },
      {
        "internalType": "uint256[]",
        "name": "extensions",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_user",
        "type": "address"
      }
    ],
    "name": "getAvailableUnstaked",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "contract_address",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "event_id",
        "type": "bytes32"
      }
    ],
    "name": "getExpectedPatronPayment",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "timepoint",
        "type": "uint256"
      }
    ],
    "name": "getPastTotalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "timepoint",
        "type": "uint256"
      }
    ],
    "name": "getPastVotes",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_user",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      }
    ],
    "name": "getPayRecord",
    "outputs": [
      {
        "components": [
          {
            "internalType": "address",
            "name": "author",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "event_contract",
            "type": "address"
          },
          {
            "internalType": "bytes32",
            "name": "event_id",
            "type": "bytes32"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "index",
            "type": "uint256"
          }
        ],
        "internalType": "struct Staking.PayRecord",
        "name": "",
        "type": "tuple"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_user",
        "type": "address"
      }
    ],
    "name": "getPayRecordsKeys",
    "outputs": [
      {
        "internalType": "bytes32[]",
        "name": "",
        "type": "bytes32[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "_user",
        "type": "address"
      }
    ],
    "name": "getUnstakeRequests",
    "outputs": [
      {
        "components": [
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "timestamp",
            "type": "uint256"
          }
        ],
        "internalType": "struct Staking.UnstakeRequest[]",
        "name": "",
        "type": "tuple[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "getVotes",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "name",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      }
    ],
    "name": "nonces",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "account",
        "type": "address"
      }
    ],
    "name": "numCheckpoints",
    "outputs": [
      {
        "internalType": "uint32",
        "name": "",
        "type": "uint32"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "owner",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "spender",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "s",
        "type": "bytes32"
      }
    ],
    "name": "permit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "event_contract",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "event_id",
        "type": "bytes32"
      },
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "setPayRecord",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "stake",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "_amount",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "_deadline",
        "type": "uint256"
      },
      {
        "internalType": "uint8",
        "name": "_v",
        "type": "uint8"
      },
      {
        "internalType": "bytes32",
        "name": "_r",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "_s",
        "type": "bytes32"
      }
    ],
    "name": "stakeWithPermit",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "stakers",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "accruedGain",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "tokensPerShareFrom",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "nextUnstakeRequestId",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "stake_frame",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "event_contract",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "last_paid_by_patrons",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "symbol",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "tokensPerShare",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalAccruedGain",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalDistributed",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalSupply",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "totalUnstaking",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "from",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transferFrom",
    "outputs": [
      {
        "internalType": "bool",
        "name": "",
        "type": "bool"
      }
    ],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "transferStake",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "uint256",
        "name": "amount",
        "type": "uint256"
      }
    ],
    "name": "unstake",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/UserProfile.json">
[
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "avatar",
        "type": "string"
      }
    ],
    "name": "AvatarSet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "name",
        "type": "string"
      }
    ],
    "name": "NameSet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "domain",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "string",
        "name": "value",
        "type": "string"
      }
    ],
    "name": "StringSet",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": false,
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "domain",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "UIntSet",
    "type": "event"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "avatars",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "domain",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      }
    ],
    "name": "getString",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "domain",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      }
    ],
    "name": "getUInt",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "name": "names",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "name": "owners",
    "outputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "profileString",
    "outputs": [
      {
        "internalType": "string",
        "name": "",
        "type": "string"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "",
        "type": "address"
      },
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "name": "profileUInt",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "name": "removeName",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "name",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "avatar",
        "type": "string"
      },
      {
        "internalType": "bytes32",
        "name": "domain",
        "type": "bytes32"
      },
      {
        "internalType": "string",
        "name": "profile",
        "type": "string"
      }
    ],
    "name": "setAll",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "avatar",
        "type": "string"
      }
    ],
    "name": "setAvatar",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "name",
        "type": "string"
      }
    ],
    "name": "setName",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "_modifier",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "_pub_key",
        "type": "string"
      }
    ],
    "name": "setPubKey",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "domain",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "string",
        "name": "value",
        "type": "string"
      }
    ],
    "name": "setString",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "domain",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "key",
        "type": "bytes32"
      },
      {
        "internalType": "uint256",
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "setUInt",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "to",
        "type": "address"
      }
    ],
    "name": "transferName",
    "outputs": [],
    "stateMutability": "nonpayable",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/abi/utils.json">
[
  {
    "inputs": [
      {
        "internalType": "address",
        "name": "author",
        "type": "address"
      },
      {
        "internalType": "string",
        "name": "domain",
        "type": "string"
      },
      {
        "internalType": "string",
        "name": "guid",
        "type": "string"
      }
    ],
    "name": "SavvaID",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "bytes32",
        "name": "a",
        "type": "bytes32"
      },
      {
        "internalType": "bytes32",
        "name": "b",
        "type": "bytes32"
      }
    ],
    "name": "concat",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "",
        "type": "bytes32"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  },
  {
    "inputs": [
      {
        "internalType": "string",
        "name": "source",
        "type": "string"
      }
    ],
    "name": "str2bytes32",
    "outputs": [
      {
        "internalType": "bytes32",
        "name": "result",
        "type": "bytes32"
      }
    ],
    "stateMutability": "pure",
    "type": "function"
  }
]
</file>

<file path="src/blockchain/chains.js">
// src/blockchain/chains.js
export const CHAINS = {
  943: {
    id: 943,
    chainId: 943, // required by wallet.js
    name: "PulseChain Testnet v4",
    rpcUrls: ["https://rpc.v4.testnet.pulsechain.com"],
    nativeCurrency: { name: "Test Pulse", symbol: "tPLS", decimals: 18 },
    blockExplorers: ["https://scan.v4.testnet.pulsechain.com"],
  },
  369: {
    id: 369,
    chainId: 369, // required by wallet.js
    name: "PulseChain",
    rpcUrls: ["https://rpc.pulsechain.com"],
    nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
    blockExplorers: ["https://scan.pulsechain.com"],
  },
};

export function getChainMeta(chainId) {
  const raw = CHAINS[chainId];
  if (!raw) return null;

  const chainIdNum = raw.chainId ?? raw.id ?? Number(chainId);
  const rpcUrls = Array.isArray(raw.rpcUrls)
    ? raw.rpcUrls
    : raw.rpcUrls ? [raw.rpcUrls] : [];

  let explorers = [];
  if (Array.isArray(raw.blockExplorers)) {
    explorers = raw.blockExplorers
      .map((x) => (typeof x === "string" ? x : x?.url))
      .filter(Boolean);
  } else if (Array.isArray(raw.blockExplorerUrls)) {
    explorers = raw.blockExplorerUrls.filter(Boolean);
  }

  return {
    id: chainIdNum, // This is the required property for viem
    chainId: chainIdNum,
    name: raw.name,
    nativeCurrency: raw.nativeCurrency,
    rpcUrls,
    blockExplorers: explorers,
  };
}
</file>

<file path="src/blockchain/config.js">
// src/blockchain/config.js
import { getSavvaContract } from "./contracts.js";
import { toHexBytes32 } from "./utils.js";
import { dbg } from "../utils/debug.js";

// A cache to store config values once they are fetched.
const paramCache = new Map();

// A simple way to determine the type of a parameter based on its name.
function getParamType(name) {
  if (name.startsWith("contract_") || name.endsWith("Address") || name === 'pulsex_factory' || name === 'pulsex_router' || name === 'WPLS') {
    return 'address';
  }
  return 'uint';
}

/**
 * Fetches a configuration parameter from the Config smart contract.
 * Results are cached to avoid repeated blockchain calls.
 *
 * @param {object} app - The global application context from useApp().
 * @param {string} name - The human-readable name of the parameter (e.g., "min_staked_to_post").
 * @returns {Promise<string|number|bigint|null>} The value of the parameter.
 */
export async function getConfigParam(app, name) {
  if (paramCache.has(name)) {
    return paramCache.get(name);
  }

  try {
    const configContract = await getSavvaContract(app, 'Config');
    const keyHex = toHexBytes32(name);
    const paramType = getParamType(name);

    let value;
    if (paramType === 'address') {
      value = await configContract.read.getAddr([keyHex]);
    } else {
      value = await configContract.read.getUInt([keyHex]);
    }

    paramCache.set(name, value);
    return value;
  } catch (error) {
    dbg.error("ConfigHelper", `Failed to fetch config parameter '${name}'`, error);
    return null;
  }
}

/**
 * Clears the configuration parameter cache.
 * This should be called when the network or backend changes.
 */
export function clearConfigCache() {
    paramCache.clear();
    dbg.log("ConfigHelper", "Configuration cache cleared.");
}
</file>

<file path="src/components/auth/SwitchAccountModal.jsx">
// src/components/auth/SwitchAccountModal.jsx
import { Show, createEffect } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { walletAccount } from "../../blockchain/wallet.js";

function shortAddr(addr) {
  if (!addr) return "";
  return addr.slice(0, 6) + "…" + addr.slice(-4);
}

export default function SwitchAccountModal(props) {
  const { t } = useApp();
  const requiredAddress = () => props.requiredAddress?.toLowerCase();

  createEffect(() => {
    // Automatically close and resolve when the user switches to the correct account.
    if (props.isOpen && walletAccount()?.toLowerCase() === requiredAddress()) {
      props.onSuccess?.();
    }
  });

  return (
    <Show when={props.isOpen}>
      <div class="fixed inset-0 z-[60] flex items-center justify-center">
        <div class="absolute inset-0 bg-black/40" />
        <div class="relative themed-dialog rounded-lg shadow-lg w-full max-w-md p-4 bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))]">
          <h3 class="text-lg font-semibold mb-2">Wrong Account Selected</h3>
          <p class="text-sm text-[hsl(var(--muted-foreground))] mb-4">
            To continue, please open your wallet and switch to the following account:
            <br />
            <strong class="font-mono text-[hsl(var(--foreground))]">{shortAddr(props.requiredAddress)}</strong>
          </p>
          <div class="flex gap-2 justify-end">
            <button
              class="px-3 py-2 rounded bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))] hover:opacity-90"
              onClick={props.onCancel}
            >
              {t("common.cancel")}
            </button>
          </div>
        </div>
      </div>
    </Show>
  );
}
</file>

<file path="src/components/comments/CommentThread.jsx">
// src/components/comments/CommentThread.jsx
import { Show, createMemo } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { navigate } from "../../routing/hashRouter.js";
import CommentCard from "../post/CommentCard.jsx";

// Helper to get the best-matching title from a post's locales object
function getLocalizedTitle(locales, lang) {
  if (!locales) return "";
  const l = locales[lang] || locales.en || locales[Object.keys(locales)[0]];
  return l?.title || "";
}

export default function CommentThread(props) {
  const app = useApp();
  const { t, lang } = app;

  const thread = () => props.thread?._raw;
  const parentPost = () => thread()?.savva_content?.parent_post;

  const parentTitle = createMemo(() => getLocalizedTitle(parentPost()?.locales, lang()));
  const parentAuthorName = createMemo(() => parentPost()?.author?.name || "anonymous");
  const parentPostUrl = createMemo(() => `/post/${parentPost()?.savva_cid}`);

  const handleNav = (e) => {
    e.preventDefault();
    e.stopPropagation();
    navigate(parentPostUrl());
  };

  return (
    <div class="space-y-2 p-3 rounded-lg border border-[hsl(var(--border))] bg-opacity-50">
      <Show when={parentPost()}>
        <div class="text-xs text-[hsl(var(--muted-foreground))] px-3">
          <span>{t("commentsTab.replyTo")} </span>
          <a href={parentPostUrl()} onClick={handleNav} class="font-semibold text-[hsl(var(--foreground))] hover:underline">
            "{parentTitle()}"
          </a>
        </div>
      </Show>
      <CommentCard comment={thread()} />
    </div>
  );
}
</file>

<file path="src/components/docs/DocsIndex.jsx">
// src/components/docs/DocsIndex.jsx
import { createMemo, createResource, For, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

async function fetchSidebar(lang) {
  // Expected: public/dev_docs/<lang>/sidebar.yaml
  const res = await fetch(`/dev_docs/${lang}/sidebar.yaml`, { cache: "no-store" });
  if (!res.ok) return { sections: [] };
  const text = await res.text();
  // very small YAML reader to avoid extra deps:
  // supports:
  // sections:
  //   - title: ...
  //     items: [{label,file}, ...]
  try {
    const y = (await import("js-yaml")).default.load(text) || {};
    if (Array.isArray(y.sections)) return { sections: y.sections };
    if (Array.isArray(y.items)) return { sections: [{ title: "Docs", items: y.items }] };
    if (Array.isArray(y)) return { sections: [{ title: "Docs", items: y }] };
  } catch {}
  return { sections: [] };
}

export default function DocsIndex(props) {
  const app = useApp();
  const lang = createMemo(() => (app.lang?.() || "en").toLowerCase());
  const [data] = createResource(lang, fetchSidebar);

  const item = (it) => {
    const label = it.label || it.title || it.file || "";
    const file  = it.file || it.path  || "";
    const active = () => props.active === file;
    return (
      <button
        class={`w-full text-left px-3 py-2 text-sm rounded ${
          active() ? "bg-[hsl(var(--accent))]" : "hover:bg-[hsl(var(--accent))]"
        }`}
        onClick={() => props.onPick?.(file)}
        title={label}
        type="button"
      >
        {label}
      </button>
    );
  };

  return (
    <div class="py-2">
      <Show when={!data.loading} fallback={
        <div class="px-3 py-2 text-sm text-[hsl(var(--muted-foreground))]">{app.t("common.loading")}</div>
      }>
        <For each={data()?.sections || []}>
          {(sec) => (
            <div class="mb-2">
              <div class="px-3 pb-1 pt-2 text-xs uppercase tracking-wide text-[hsl(var(--muted-foreground))]">
                {sec.title || app.t("docs.section")}
              </div>
              <For each={sec.items || []}>{item}</For>
            </div>
          )}
        </For>
        <Show when={!data() || (data()?.sections || []).length === 0}>
          <div class="px-3 py-2 text-sm text-[hsl(var(--muted-foreground))]">
            {app.t("docs.sidebar.empty")}
          </div>
        </Show>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/wizard_steps/StepCheckRights.jsx">
// src/components/editor/wizard_steps/StepCheckRights.jsx
import { createSignal, onMount, Show } from "solid-js";
import { useApp } from "../../../context/AppContext.jsx";
import Spinner from "../../ui/Spinner.jsx";
import { getConfigParam } from "../../../blockchain/config.js";
import { getSavvaContract } from "../../../blockchain/contracts.js";
import { formatUnits } from "viem";

export default function StepCheckRights(props) {
  const app = useApp();
  const { t } = app;
  const [error, setError] = createSignal(null);
  const [isChecking, setIsChecking] = createSignal(true);

  const checkRights = async () => {
    const user = app.authorizedUser();
    if (!user?.address) {
      throw new Error(t("editor.publish.rights.errorNoAuth"));
    }

    const minStakeWei = await getConfigParam(app, "min_staked_to_post");
    if (minStakeWei === null) {
      throw new Error(t("editor.publish.rights.errorConfig"));
    }

    const stakingContract = await getSavvaContract(app, "Staking");
    const userStakeWei = await stakingContract.read.balanceOf([user.address]);

    if (userStakeWei < minStakeWei) {
      const required = parseFloat(formatUnits(minStakeWei, 18)).toLocaleString();
      const actual = parseFloat(formatUnits(userStakeWei, 18)).toLocaleString();
      throw new Error(t("editor.publish.rights.errorInsufficientStake", { required, actual }));
    }
  };

  onMount(() => {
    setTimeout(async () => {
      try {
        await checkRights();
        props.onComplete?.();
      } catch (e) {
        setError(e.message);
      } finally {
        setIsChecking(false);
      }
    }, 500);
  });

  return (
    <div class="flex flex-col items-center justify-center h-full">
      <Show when={isChecking()}>
        <Spinner />
        <p class="mt-2 text-sm">{t("common.checking")}...</p>
      </Show>
      <Show when={error()}>
        <div class="text-center p-4">
          <h4 class="font-bold text-red-600">{t("editor.publish.rights.errorTitle")}</h4>
          <p class="mt-2 text-sm">{error()}</p>
          <button onClick={props.onCancel} class="mt-4 px-4 py-2 rounded border border-[hsl(var(--input))] hover:bg-[hsl(var(--accent))]">
            {t("editor.publish.validation.backToEditor")}
          </button>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/ChapterManager.jsx">
// src/components/editor/ChapterManager.jsx
import { For, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

function PlusIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-5 h-5"} fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="12" y1="5" x2="12" y2="19"></line>
      <line x1="5" y1="12" x2="19" y2="12"></line>
    </svg>
  );
}

export default function ChapterManager(props) {
  const { t } = useApp();

  const handleAddChapter = () => {
    const newChapter = { title: t("editor.chapters.newChapterTitle"), body: "" };
    props.onUpdate([...(props.chapters || []), newChapter]);
  };

  const handleRemoveChapter = (index) => {
    const updatedChapters = (props.chapters || []).filter((_, i) => i !== index);
    props.onUpdate(updatedChapters);
    // If the active chapter was deleted, switch to prologue
    if (props.activeIndex === index) {
      props.onSelectIndex(-1);
    }
  };

  const handleTitleChange = (index, newTitle) => {
    const updatedChapters = (props.chapters || []).map((chapter, i) => 
      i === index ? { ...chapter, title: newTitle } : chapter
    );
    props.onUpdate(updatedChapters);
  };

  const activeClass = (index) => props.activeIndex === index ? "bg-[hsl(var(--accent))]" : "hover:bg-[hsl(var(--accent))]";

  return (
    <div class="p-4 rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] space-y-3">
      <h3 class="text-lg font-semibold">{t("editor.chapters.title")}</h3>
      <div class="space-y-2">
        {/* Prologue Item */}
        <div class={`flex items-center gap-2 p-1 rounded ${activeClass(-1)}`}>
          <button class="flex-1 text-left text-sm font-semibold" onClick={() => props.onSelectIndex(-1)}>
            {t("post.chapters.prologue")}
          </button>
        </div>

        {/* Chapter Items */}
        <For each={props.chapters}>
          {(chapter, index) => (
            <div class={`flex items-center gap-2 p-1 rounded ${activeClass(index())}`}>
              <button class="text-left text-sm font-semibold" onClick={() => props.onSelectIndex(index())}>
                {index() + 1}.
              </button>
              <input
                type="text"
                value={chapter.title}
                onInput={(e) => handleTitleChange(index(), e.currentTarget.value)}
                class="flex-1 px-2 py-1 text-sm rounded border bg-[hsl(var(--background))] border-[hsl(var(--input))]"
              />
              <button
                onClick={() => handleRemoveChapter(index())}
                class="p-1 text-xs text-[hsl(var(--destructive))]"
              >
                {t("common.remove")}
              </button>
            </div>
          )}
        </For>
      </div>
      <button
        onClick={handleAddChapter}
        class="text-sm px-3 py-1 rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] flex items-center gap-1"
      >
        <PlusIcon class="w-4 h-4" />
        {t("editor.chapters.add")}
      </button>
    </div>
  );
}
</file>

<file path="src/components/editor/EditorChapterSelector.jsx">
// src/components/editor/EditorChapterSelector.jsx
import { createSignal, onMount, onCleanup, Show, For, createMemo } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

function ChevronDownIcon(props) {
  return (
    <svg viewBox="0 0 16 16" class={props.class || "w-4 h-4"} aria-hidden="true" fill="currentColor">
      <path d="M8 11.25a.75.75 0 01-.53-.22l-4-4a.75.75 0 111.06-1.06L8 9.94l3.47-3.47a.75.75 0 111.06 1.06l-4 4a.75.75 0 01-.53.22z"></path>
    </svg>
  );
}

function PlusIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-5 h-5"} fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="12" y1="5" x2="12" y2="19"></line>
      <line x1="5" y1="12" x2="19" y2="12"></line>
    </svg>
  );
}

function MinusIcon(props) {
    return (
      <svg viewBox="0 0 24 24" class={props.class || "w-5 h-5"} fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <line x1="5" y1="12" x2="19" y2="12"></line>
      </svg>
    );
}

export default function EditorChapterSelector(props) {
  const { t } = useApp();
  const [isOpen, setIsOpen] = createSignal(false);
  let containerRef;

  const chapters = () => props.chapters || [];
  const activeIndex = () => props.activeIndex;

  const activeItem = createMemo(() => {
    const index = activeIndex();
    if (index === -1) return { title: t("post.chapters.prologue") };
    return chapters()[index] || null;
  });

  const displayedTitle = createMemo(() => {
    const item = activeItem();
    if (!item) return "";
    const index = activeIndex();
    return index > -1 ? `${index + 1}. ${item.title}` : item.title;
  });

  const handleClickOutside = (event) => {
    if (containerRef && !containerRef.contains(event.target)) {
      setIsOpen(false);
    }
  };

  onMount(() => document.addEventListener("mousedown", handleClickOutside));
  onCleanup(() => document.removeEventListener("mousedown", handleClickOutside));

  return (
    <div class="space-y-2">
        <div class="flex items-center gap-2">
            <div class="relative w-full" ref={containerRef}>
                <button
                    class="w-full flex items-center justify-between px-3 py-2 text-sm rounded-md border border-[hsl(var(--input))] bg-[hsl(var(--background))] hover:bg-[hsl(var(--accent))]"
                    onClick={() => setIsOpen(!isOpen())}
                    aria-haspopup="true"
                    aria-expanded={isOpen()}
                >
                    <span class="font-semibold truncate">{displayedTitle()}</span>
                    <ChevronDownIcon />
                </button>

                <Show when={isOpen()}>
                    <div class="absolute top-full left-0 mt-1 w-full max-h-60 overflow-y-auto rounded-md shadow-lg bg-[hsl(var(--popover))] text-[hsl(var(--popover-foreground))] ring-1 ring-black ring-opacity-5 z-20">
                    <ul class="py-1" role="menu">
                        <li>
                            <a href="#" class="block w-full text-left px-4 py-2 text-sm hover:bg-[hsl(var(--accent))]" onClick={(e) => { e.preventDefault(); props.onSelectIndex(-1); setIsOpen(false); }}>
                                {t("post.chapters.prologue")}
                            </a>
                        </li>
                        <For each={chapters()}>
                        {(chapter, i) => (
                            <li>
                                <a href="#" class="block w-full text-left px-4 py-2 text-sm hover:bg-[hsl(var(--accent))]" onClick={(e) => { e.preventDefault(); props.onSelectIndex(i()); setIsOpen(false); }}>
                                    {i() + 1}. {chapter.title}
                                </a>
                            </li>
                        )}
                        </For>
                    </ul>
                    </div>
                </Show>
            </div>
            <button onClick={props.onAdd} title={t("editor.chapters.add")} class="p-2 rounded-md bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))]">
                <PlusIcon />
            </button>
            <button onClick={props.onRemove} title={t("editor.chapters.remove")} disabled={activeIndex() === -1} class="p-2 rounded-md bg-[hsl(var(--destructive))] text-[hsl(var(--destructive-foreground))] disabled:opacity-50">
                <MinusIcon />
            </button>
        </div>
        <Show when={activeIndex() > -1}>
            <input
                type="text"
                value={activeItem()?.title || ""}
                onInput={(e) => props.onTitleChange(e.currentTarget.value)}
                placeholder={t("editor.chapters.titlePlaceholder")}
                class="w-full text-sm px-2 py-1 bg-transparent border-b border-[hsl(var(--border))] focus:outline-none focus:border-[hsl(var(--primary))]"
            />
        </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/EditorSidebar.jsx">
// src/components/editor/EditorSidebar.jsx
import { useApp } from "../../context/AppContext.jsx";
import LangSelector from "../ui/LangSelector.jsx";

export default function EditorSidebar(props) {
  const { t, domainAssetsConfig } = useApp();

  const domainLangCodes = () => {
    const fromDomain = (domainAssetsConfig?.()?.locales || []).map((l) => l.code).filter(Boolean);
    return fromDomain.length > 0 ? fromDomain : ["en"];
  };

  return (
    <aside class="sticky top-16 space-y-4">
      <div class="rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] p-4">
        <h3 class="text-sm font-semibold mb-2">{t("editor.sidebar.thumbnail")}</h3>
        <div class="aspect-video rounded bg-[hsl(var(--muted))] flex items-center justify-center">
          <span class="text-xs text-[hsl(var(--muted-foreground))]">{t("editor.sidebar.thumbnailPlaceholder")}</span>
        </div>
      </div>

      <div class="rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] p-4">
        <h3 class="text-sm font-semibold mb-2">{t("editor.sidebar.language")}</h3>
        <LangSelector
          codes={domainLangCodes()}
          value={props.lang}
          onChange={props.onLangChange}
          variant="stretch"
        />
      </div>

      <div class="rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] p-4">
        <h3 class="text-sm font-semibold mb-2">{t("editor.sidebar.files")}</h3>
        <div class="h-48 rounded bg-[hsl(var(--muted))] flex items-center justify-center">
          <span class="text-xs text-[hsl(var(--muted-foreground))]">{t("editor.sidebar.filesPlaceholder")}</span>
        </div>
      </div>
    </aside>
  );
}
</file>

<file path="src/components/editor/EditorTocButton.jsx">
// src/components/editor/EditorTocButton.jsx
import { useApp } from "../../context/AppContext.jsx";

function TocIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-5 h-5"} fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 6h16M4 12h16M4 18h16" />
    </svg>
  );
}

export default function EditorTocButton(props) {
  const { t } = useApp();
  return (
    <button
      onClick={props.onClick}
      class="p-1.5 rounded-full text-[hsl(var(--muted-foreground))] hover:bg-[hsl(var(--accent))] hover:text-[hsl(var(--foreground))]"
      title={t("editor.chapters.add")}
    >
      <TocIcon class="w-5 h-5" />
    </button>
  );
}
</file>

<file path="src/components/editor/FileContextMenu.jsx">
// src/components/editor/FileContextMenu.jsx
import { onMount, onCleanup, For } from "solid-js";

export default function FileContextMenu(props) {
  let menuRef;

  const handleClickOutside = (event) => {
    if (menuRef && !menuRef.contains(event.target)) {
      props.onClose?.();
    }
  };

  onMount(() => {
    setTimeout(() => document.addEventListener("mousedown", handleClickOutside), 0);
  });

  onCleanup(() => {
    document.removeEventListener("mousedown", handleClickOutside);
  });

  const handleItemClick = (e, item) => {
    e.preventDefault();
    e.stopPropagation();
    item.onClick?.();
    props.onClose?.();
  };

  return (
    <div
      ref={menuRef}
      class="absolute w-48 rounded-md shadow-lg bg-[hsl(var(--popover))] text-[hsl(var(--popover-foreground))] ring-1 ring-black ring-opacity-5 z-30"
      // This style attribute applies the dynamic position
      style={{ top: `${props.y}px`, left: `${props.x}px` }}
    >
      <ul class="py-1" role="menu">
        <For each={props.items}>
          {(item) => (
            <li>
              <a
                href="#"
                class="block w-full text-left px-4 py-2 text-sm hover:bg-[hsl(var(--accent))]"
                onClick={(e) => handleItemClick(e, item)}
              >
                {item.label}
              </a>
            </li>
          )}
        </For>
      </ul>
    </div>
  );
}
</file>

<file path="src/components/editor/PostComments.jsx">
// src/components/post/PostComments.jsx
import { createResource, For, Show, createSignal, createEffect } from "solid-js";
import { useApp } from "../../context/AppContext";
import { toChecksumAddress } from "../../blockchain/utils";
import Spinner from "../ui/Spinner";
import CommentCard from "./CommentCard";
import { navigate } from "../../routing/hashRouter.js";

async function fetchComments(params) {
  const { app, postId, offset = 0 } = params;
  if (!app.wsMethod || !postId) return { list: [], nextOffset: null };

  const getChildren = app.wsMethod("content-children");
  const requestParams = {
    domain: app.selectedDomainName(),
    savva_cid: postId,
    max_deep: 4,
    limit: 20,
    offset,
  };

  const user = app.authorizedUser();
  if (user?.address) {
    requestParams.my_addr = toChecksumAddress(user.address);
  }

  try {
    const res = await getChildren(requestParams);
    const list = Array.isArray(res?.list) ? res.list : [];
    const nextOffset = res?.next_offset > 0 ? res.next_offset : null;
    return { list, nextOffset };
  } catch (err) {
    console.error(`Failed to fetch comments for post '${postId}':`, err);
    return { list: [], nextOffset: null, error: err.message };
  }
}

export default function PostComments(props) {
  const app = useApp();
  const { t } = app;
  const postId = () => props.post?.savva_cid;

  const [comments, setComments] = createSignal([]);
  const [nextOffset, setNextOffset] = createSignal(0);
  const [isLoadingMore, setIsLoadingMore] = createSignal(false);

  const [initialData] = createResource(() => ({ app, postId: postId() }), fetchComments);

  createEffect(() => {
    const data = initialData();
    if (data && !initialData.loading) {
      setComments(data.list || []);
      setNextOffset(data.nextOffset);
    }
  });

  const loadMore = async () => {
    if (isLoadingMore() || nextOffset() === null) return;
    setIsLoadingMore(true);
    const data = await fetchComments({ app, postId: postId(), offset: nextOffset() });
    if (data.list) {
      setComments((prev) => [...prev, ...data.list]);
      setNextOffset(data.nextOffset);
    }
    setIsLoadingMore(false);
  };

  const handleAddComment = () => {
    navigate(`/editor/comment/${postId()}`);
  };

  return (
    <div class="mt-8 pt-6 border-t border-[hsl(var(--border))]">
      {/* Header with link only, no counter */}
      <div class="mb-4 flex items-center justify-between">
        <h3 class="text-xl font-semibold">{t("post.comments")}</h3>
        <button
          onClick={handleAddComment}
          class="text-sm underline text-[hsl(var(--foreground))] hover:opacity-80"
        >
          {t("post.addComment")}
        </button>
      </div>

      <Show when={initialData.loading}>
        <div class="flex justify-center p-8"><Spinner /></div>
      </Show>

      <Show when={initialData.error}>
        <p class="text-sm text-[hsl(var(--destructive))]">
          {t("common.error")}: {initialData.error}
        </p>
      </Show>

      <Show when={!initialData.loading && !initialData.error && comments().length > 0}>
        <div class="space-y-4">
          <For each={comments()}>
            {(comment) => <CommentCard comment={comment} />}
          </For>
        </div>
      </Show>

      <Show when={!initialData.loading && !initialData.error && comments().length === 0}>
        <p class="text-sm text-[hsl(var(--muted-foreground))]">{t("post.noComments")}</p>
      </Show>

      <Show when={nextOffset() !== null && !initialData.loading}>
        <div class="mt-6 text-center">
          <button
            onClick={loadMore}
            disabled={isLoadingMore()}
            class="px-4 py-2 rounded-md border border-[hsl(var(--border))] text-sm hover:bg-[hsl(var(--accent))] disabled:opacity-50"
          >
            {isLoadingMore() ? t("common.loading") : t("post.loadMoreComments")}
          </button>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/UploadFromUrlModal.jsx">
// src/components/editor/UploadFromUrlModal.jsx
import { createSignal, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

export default function UploadFromUrlModal(props) {
  const { t } = useApp();
  const [url, setUrl] = createSignal("");
  const [isLoading, setIsLoading] = createSignal(false);

  const handleUpload = async () => {
    if (!url().trim()) return;
    setIsLoading(true);
    try {
      await props.onUpload?.(url());
      props.onClose?.();
    } catch (e) {
      // Error toast is handled by the parent
      console.error("Upload from URL failed:", e);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Show when={props.isOpen}>
      <div class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/40" onClick={props.onClose} />
        <div class="relative themed-dialog rounded-lg shadow-lg w-full max-w-md p-4 bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))]">
          <h3 class="text-lg font-semibold mb-3">{t("editor.files.uploadModalTitle")}</h3>
          <input
            type="text"
            value={url()}
            onInput={(e) => setUrl(e.currentTarget.value)}
            class="w-full px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
            placeholder={t("editor.files.uploadModalPlaceholder")}
          />
          <div class="flex gap-2 justify-end mt-4">
            <button
              class="px-3 py-2 rounded bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))] hover:opacity-90"
              onClick={props.onClose}
            >
              {t("common.cancel")}
            </button>
            <button
              class="px-3 py-2 rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] hover:opacity-90 disabled:opacity-60"
              onClick={handleUpload}
              disabled={isLoading()}
            >
              {isLoading() ? t("editor.files.uploading") : t("editor.files.uploadModalConfirm")}
            </button>
          </div>
        </div>
      </div>
    </Show>
  );
}
</file>

<file path="src/components/layout/Container.jsx">
// src/components/layout/Container.jsx
export default function Container(props) {
  return <div class={`sv-container ${props.class || ""}`}>{props.children}</div>;
}
</file>

<file path="src/components/layout/TwoColumn.jsx">
// src/components/layout/TwoColumn.jsx
export default function TwoColumn(props) {
  // props.aside is the node for the right column
  return (
    <div class="sv-content-grid">
      <section class="sv-main">{props.children}</section>
      {props.aside && <aside class="sv-aside">{props.aside}</aside>}
    </div>
  );
}
</file>

<file path="src/components/main/ConnectionError.jsx">
// src/components/main/ConnectionError.jsx
import { Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

export default function ConnectionError(props) {
  const { t } = useApp();

  const handleRetry = () => {
    window.location.reload();
  };

  return (
    <div class="fixed inset-0 flex items-center justify-center bg-[hsl(var(--background))] text-[hsl(var(--foreground))] p-4">
      <div class="w-full max-w-md p-6 rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] text-center shadow-lg">
        <h2 class="text-xl font-semibold mb-3">{t("error.connection.title")}</h2>
        <p class="mb-4 text-[hsl(var(--muted-foreground))]">
          {t("error.connection.message")}
        </p>
        <Show when={props.error}>
          <pre class="mb-4 p-2 text-xs text-left bg-[hsl(var(--muted))] rounded overflow-x-auto">
            {props.error.message || props.error.toString()}
          </pre>
        </Show>
        <button
          class="px-4 py-2 rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] hover:opacity-90"
          onClick={handleRetry}
        >
          {t("error.connection.retry")}
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/post/ChapterPager.jsx">
// src/components/post/ChapterPager.jsx
import { createMemo, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

export default function ChapterPager(props) {
  const { t } = useApp();

  const nav = createMemo(() => {
    const list = props.chapters || [];
    const idx = props.currentIndex;
    if (idx < 0 || list.length === 0) return { prev: null, next: null };
    
    const prev = list[idx - 1] ? { ...list[idx - 1], index: idx - 1 } : null;
    const next = list[idx + 1] ? { ...list[idx + 1], index: idx + 1 } : null;
    
    return { prev, next };
  });
  
  const go = (index) => props.onSelect?.(index);

  return (
    <Show when={nav().prev || nav().next}>
      <nav class="mt-8 pt-4 border-t border-[hsl(var(--border))] flex items-stretch justify-between gap-3 text-sm">
        {/* Prev (left) */}
        <div class="min-w-0 flex-1">
          <Show when={nav().prev}>
            {(p) => (
              <button
                type="button"
                class="w-full rounded-md px-3 py-2 bg-[hsl(var(--muted))] hover:bg-[hsl(var(--accent))] text-left"
                onClick={() => go(p().index)}
                aria-label={t("docs.prev")}
                title={p().title}
              >
                <div class="flex items-start gap-2">
                  <span aria-hidden="true">←</span>
                  <div class="min-w-0">
                    <div class="font-medium whitespace-normal break-words leading-snug">
                      {p().index > 0 ? `${p().index}. ${p().title}` : p().title}
                    </div>
                  </div>
                </div>
              </button>
            )}
          </Show>
        </div>

        {/* Next (right) */}
        <div class="min-w-0 flex-1 text-right">
          <Show when={nav().next}>
            {(n) => (
              <button
                type="button"
                class="w-full rounded-md px-3 py-2 bg-[hsl(var(--muted))] hover:bg-[hsl(var(--accent))]"
                onClick={() => go(n().index)}
                aria-label={t("docs.next")}
                title={n().title}
              >
                <div class="flex items-start gap-2 justify-end">
                  <div class="min-w-0">
                    <div class="font-medium whitespace-normal break-words leading-snug text-right">
                      {n().index > 0 ? `${n().index}. ${n().title}` : n().title}
                    </div>
                  </div>
                  <span aria-hidden="true">→</span>
                </div>
              </button>
            )}
          </Show>
        </div>
      </nav>
    </Show>
  );
}
</file>

<file path="src/components/post/ChapterSelector.jsx">
// src/components/post/ChapterSelector.jsx
import { createSignal, onMount, onCleanup, Show, For } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

function TocIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-5 h-5"} fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M4 6h16M4 12h16M4 18h16" />
    </svg>
  );
}

export default function ChapterSelector(props) {
  const { t } = useApp();
  const [isOpen, setIsOpen] = createSignal(false);
  let containerRef; 

  const chapters = () => props.chapters || [];
  const selectedIndex = () => props.selectedIndex;

  const selectedChapter = () => {
    const idx = selectedIndex();
    const list = chapters();
    return idx >= 0 && idx < list.length ? list[idx] : null;
  };
  
  const displayedTitle = () => {
    const chapter = selectedChapter();
    if (!chapter) return "";
    const idx = selectedIndex();
    return idx > 0 ? `${idx}. ${chapter.title}` : chapter.title;
  };

  const handleClickOutside = (event) => {
    if (containerRef && !containerRef.contains(event.target)) {
      setIsOpen(false);
    }
  };

  onMount(() => document.addEventListener("mousedown", handleClickOutside));
  onCleanup(() => document.removeEventListener("mousedown", handleClickOutside));

  return (
    <div class="relative" ref={containerRef}>
      <button
        class="flex items-center gap-2 px-2 py-1 rounded-md hover:bg-[hsl(var(--accent))]"
        onClick={() => setIsOpen(!isOpen())}
        aria-haspopup="true"
        aria-expanded={isOpen()}
        title={t("post.chapters.title")}
      >
        <Show when={selectedChapter()?.title} fallback={<span>{t("post.chapters.title")}</span>}>
          <span class="font-semibold text-sm">{displayedTitle()}</span>
        </Show>
        <TocIcon class="w-5 h-5" />
      </button>

      <Show when={isOpen()}>
        <div class="absolute top-full right-0 mt-2 w-64 max-h-[22rem] overflow-y-auto rounded-md shadow-lg bg-[hsl(var(--popover))] text-[hsl(var(--popover-foreground))] ring-1 ring-black ring-opacity-5 z-20">
          <ul class="py-1" role="menu">
            <For each={chapters()}>
              {(chapter, i) => (
                <li>
                  <a
                    href="#"
                    class={`block w-full text-left px-4 py-2 text-sm truncate ${selectedIndex() === i() ? 'bg-[hsl(var(--accent))]' : 'hover:bg-[hsl(var(--accent))]'}`}
                    onClick={(e) => {
                      e.preventDefault();
                      props.onSelect?.(i());
                      setIsOpen(false);
                    }}
                    title={chapter.title}
                  >
                    {i() > 0 ? `${i()}. ${chapter.title}` : chapter.title}
                  </a>
                </li>
              )}
            </For>
          </ul>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/post/PostTags.jsx">
// src/components/post/PostTags.jsx
import { createMemo, For, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

// A reusable pill component for consistent styling
function TagPill(props) {
    return (
        <div class="px-2.5 py-1 rounded-md bg-[hsl(var(--muted))] text-[hsl(var(--muted-foreground))] text-xs font-medium">
            {props.children}
        </div>
    );
}

export default function PostTags(props) {
    const { lang } = useApp();

    const localizedContent = createMemo(() => {
        const currentLang = lang();
        const locales = props.postData?.savva_content?.locales;
        if (!locales) return null;
        
        // Use the current language, fallback to English, or the first available locale
        const firstLocaleKey = Object.keys(locales)[0];
        return locales[currentLang] || locales.en || (firstLocaleKey ? locales[firstLocaleKey] : null);
    });

    // Categories are an array from the localized content
    const categories = createMemo(() => {
        const content = localizedContent();
        const cats = content?.categories;
        return Array.isArray(cats) ? cats : [];
    });

    // Tags are also an array from the localized content
    const tags = createMemo(() => {
        const content = localizedContent();
        const t = content?.tags;
        return Array.isArray(t) ? t : [];
    });

    return (
        <Show when={categories().length > 0 || tags().length > 0}>
            <div class="flex flex-wrap items-center gap-2 pt-1">
                <For each={categories()}>
                    {(category) => <TagPill>{category}</TagPill>}
                </For>
                <For each={tags()}>
                    {(tag) => <TagPill>#{tag}</TagPill>}
                </For>
            </div>
        </Show>
    );
}
</file>

<file path="src/components/profile/PostsTab.jsx">
// src/components/profile/PostsTab.jsx
import { createSignal, createResource, createMemo, For, Show, Switch, Match } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import ContentFeed from "../feed/ContentFeed.jsx";
import ViewModeToggle, { viewMode } from "../ui/ViewModeToggle.jsx";
import { toChecksumAddress } from "../../blockchain/utils.js";
import TagList from "./TagList.jsx";
import { useDomainCategories } from "../../hooks/useDomainCategories.js";

async function fetchUserTags(params) {
  const { app, user_addr, lang } = params;
  if (!app.wsMethod || !user_addr || !lang) return [];
  try {
    const getTags = app.wsMethod("get-user-tags");
    const res = await getTags({
      domain: app.selectedDomainName(),
      user_addr: user_addr,
      locale: lang,
    });
    return Array.isArray(res) ? res.sort() : [];
  } catch (e) {
    console.error("Failed to fetch user tags:", e);
    return [];
  }
}

export default function PostsTab(props) {
  const app = useApp();
  const { t } = app;
  const lang = () => app.lang();
  const user = () => props.user;

  const [selectedTags, setSelectedTags] = createSignal([]);
  const [selectedCategory, setSelectedCategory] = createSignal("ALL");

  const [tagsResource] = createResource(() => ({
    app,
    user_addr: user()?.address,
    lang: lang()
  }), fetchUserTags);

  const categoriesResource = useDomainCategories(app);
  const categoriesWithAll = createMemo(() => ["ALL", ...(categoriesResource() || [])]);

  const contentList = app.wsMethod ? app.wsMethod("content-list") : null;
  const feedResetKey = createMemo(() => `${selectedCategory()}|${selectedTags().join(',')}`);

  async function fetchPage(page, pageSize) {
    if (!contentList || !user()?.address) return [];
    
    const params = {
      domain: app.selectedDomainName(),
      author_addr: toChecksumAddress(user().address),
      my_addr: app.authorizedUser()?.address ? toChecksumAddress(app.authorizedUser().address) : undefined,
      content_type: "post",
      limit: pageSize,
      offset: (page - 1) * pageSize,
      lang: lang(),
    };

    const cat = selectedCategory();
    if (cat && cat !== "ALL") params.category = `${lang()}:${cat}`;
    
    const tags = selectedTags();
    if (tags.length > 0) params.tags = tags.map(tag => `${lang()}:${tag}`);

    try {
      const res = await contentList(params);
      const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];
      return arr.map((it) => ({ id: it.savva_cid, _raw: it }));
    } catch (err) {
      console.error("PostsTab fetchPage error:", err);
      return [];
    }
  }

  const handleTagToggle = (tag) => {
    setSelectedTags(prev => {
      const newSet = new Set(prev);
      if (newSet.has(tag)) newSet.delete(tag);
      else newSet.add(tag);
      return Array.from(newSet);
    });
  };

  const RightPanel = () => (
    <section class="w-full">
      <div class="mb-3 flex flex-wrap items-center gap-3">
        <ViewModeToggle size="md" />
        <div class="ml-auto flex items-center gap-2 min-w-[220px]">
          <span class="text-xs opacity-70">{t("newTab.category")}</span>
          <select
            class="flex-1 px-3 h-9 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
            value={selectedCategory()}
            onInput={(e) => setSelectedCategory(e.currentTarget.value)}
          >
            <For each={categoriesWithAll()}>
              {(c) => <option value={c}>{c === "ALL" ? t("categories.all") : c}</option>}
            </For>
          </select>
        </div>
      </div>
      <ContentFeed
        mode={viewMode()}
        fetchPage={fetchPage}
        pageSize={12}
        resetOn={feedResetKey()}
        isRailVisible={false}
        isActivated={true}
      />
    </section>
  );

  return (
    <Switch>
      <Match when={!tagsResource.loading && tagsResource()?.length > 0}>
        <div class="grid grid-cols-[180px_minmax(0,1fr)] gap-6 items-start">
          <aside class="sticky top-[120px]">
            <h4 class="text-sm font-semibold mb-2">{t("profile.tabs.tags")}</h4>
            <TagList 
              tags={tagsResource()} 
              loading={tagsResource.loading}
              selectedTags={selectedTags()} 
              onTagToggle={handleTagToggle} 
            />
          </aside>
          <RightPanel />
        </div>
      </Match>
      <Match when={true}>
        <RightPanel />
      </Match>
    </Switch>
  );
}
</file>

<file path="src/components/profile/SubscribersTab.jsx">
// src/components/profile/SubscribersTab.jsx
import { createSignal, createMemo, For, Show, createEffect, on, onMount, onCleanup } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import UserCard from "../ui/UserCard.jsx";
import Spinner from "../ui/Spinner.jsx";
import TokenValue from "../ui/TokenValue.jsx";

async function fetchSponsors(params) {
  const { app, user_addr, n_weeks, offset, limit } = params;
  if (!app.wsMethod || !user_addr) return { sponsors: [], next_offset: null };
  try {
    const getSponsors = app.wsMethod("get-sponsors");
    const res = await getSponsors({
      domain: "", // Empty domain to get sponsors across all domains
      user_addr,
      n_weeks,
      limit,
      offset,
    });
    return {
      sponsors: Array.isArray(res?.sponsors) ? res.sponsors : [],
      next_offset: res?.next_offset ?? null,
    };
  } catch (e) {
    console.error("Failed to fetch sponsors:", e);
    return { sponsors: [], next_offset: null };
  }
}

export default function SubscribersTab(props) {
  const app = useApp();
  const { t } = app;
  const user = () => props.user;

  const [showActiveOnly, setShowActiveOnly] = createSignal(true);
  const nWeeks = createMemo(() => showActiveOnly() ? 1 : 0);
  
  const [sponsors, setSponsors] = createSignal([]);
  const [offset, setOffset] = createSignal(0);
  const [hasMore, setHasMore] = createSignal(true);
  const [loading, setLoading] = createSignal(false);

  const loadMore = async () => {
    if (loading() || !hasMore()) return;
    setLoading(true);
    
    const result = await fetchSponsors({ 
      app, 
      user_addr: user().address, 
      n_weeks: nWeeks(), 
      offset: offset(), 
      limit: 20 
    });
    
    if (result.sponsors.length > 0) {
      setSponsors(prev => [...prev, ...result.sponsors]);
    }
    
    if (result.next_offset) {
      setOffset(result.next_offset);
    } else {
      setHasMore(false);
    }

    setLoading(false);
  };
  
  createEffect(on(nWeeks, () => {
    setSponsors([]);
    setOffset(0);
    setHasMore(true);
    loadMore();
  }));
  
  onMount(() => {
    loadMore(); // Initial load
    const handleScroll = () => {
      const scrollThreshold = 300;
      const nearBottom = window.innerHeight + window.scrollY >= document.documentElement.scrollHeight - scrollThreshold;
      if (nearBottom) {
        loadMore();
      }
    };
    window.addEventListener('scroll', handleScroll, { passive: true });
    onCleanup(() => window.removeEventListener('scroll', handleScroll));
  });

  return (
    <div class="px-2">
      <div class="flex items-center justify-end mb-4">
        <label class="flex items-center gap-2 text-sm cursor-pointer">
          <input 
            type="checkbox" 
            class="rounded"
            checked={showActiveOnly()} 
            onChange={e => setShowActiveOnly(e.currentTarget.checked)} 
          />
          {t("profile.subscribers.showActiveOnly")}
        </label>
      </div>

      <div class="overflow-x-auto">
        <table class="w-full text-sm text-left">
          <thead class="text-xs text-[hsl(var(--muted-foreground))] uppercase bg-[hsl(var(--muted))]">
            <tr>
              <th scope="col" class="px-4 py-2">{t("profile.subscribers.table.user")}</th>
              <th scope="col" class="px-4 py-2">{t("profile.subscribers.table.domain")}</th>
              <th scope="col" class="px-4 py-2 text-center">{t("profile.subscribers.table.weeks")}</th>
              <th scope="col" class="px-4 py-2 text-right">{t("profile.subscribers.table.amount")}</th>
            </tr>
          </thead>
          <tbody>
            <For each={sponsors()}>
              {(sponsor) => (
                <tr class="border-b border-[hsl(var(--border))]">
                  <td class="px-4 py-2 font-medium">
                    <UserCard author={sponsor.user} />
                  </td>
                  <td class="px-4 py-2">{sponsor.domain}</td>
                  <td class="px-4 py-2 text-center">
                    {sponsor.weeks < 1 ? t("profile.subscribers.table.expired") : sponsor.weeks}
                  </td>
                  <td class="px-4 py-2 flex justify-end">
                    <TokenValue amount={sponsor.amount} format="vertical" />
                  </td>
                </tr>
              )}
            </For>
          </tbody>
        </table>
        <Show when={loading()}>
          <div class="flex justify-center p-4"><Spinner /></div>
        </Show>
        <Show when={!loading() && sponsors().length === 0}>
          <p class="text-center text-sm text-[hsl(var(--muted-foreground))] py-8">
            {t("profile.subscribers.noResults")}
          </p>
        </Show>
      </div>
    </div>
  );
}
</file>

<file path="src/components/profile/TagList.jsx">
// src/pages/profile/TagList.jsx
import { For, Show } from "solid-js";
import Spinner from "../ui/Spinner.jsx";

export default function TagList(props) {
  const tags = () => props.tags || [];
  const selectedTags = () => props.selectedTags || [];

  const isSelected = (tag) => selectedTags().includes(tag);

  return (
    <div class="space-y-2">
      <Show when={!props.loading} fallback={<Spinner class="w-5 h-5" />}>
        <For each={tags()}>
          {(tag) => (
            <button
              onClick={() => props.onTagToggle?.(tag)}
              class="w-full text-left px-3 py-1.5 text-sm rounded-md border truncate"
              classList={{
                "bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] border-[hsl(var(--primary))]": isSelected(tag),
                "bg-transparent border-[hsl(var(--border))] hover:bg-[hsl(var(--accent))]": !isSelected(tag)
              }}
            >
              #{tag}
            </button>
          )}
        </For>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/settings/Assets.jsx">
// src/components/settings/Assets.jsx
import { createSignal, createMemo, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { assessAssets } from "../../utils/assetsDiagnostics";

export default function Assets() {
  const app = useApp();
  const { t } = app;

  const env = createMemo(() => app.assetsEnv?.() || "prod");
  const [busySwitch, setBusySwitch] = createSignal(false);
  async function switchEnv(next) {
    if (next === env()) return;
    try {
      setBusySwitch(true);
      app.setAssetsEnv?.(next);
      await app.refreshDomainAssets?.();
    } finally { setBusySwitch(false); }
  }

  const [busyDiag, setBusyDiag] = createSignal(false);
  const [report, setReport] = createSignal(null);
  const [err, setErr] = createSignal(null);

  async function runDiagnostics() {
    setBusyDiag(true); setErr(null);
    try {
      const r = await assessAssets({
        env: app.assetsEnv?.(),
        assetsBaseUrl: app.assetsBaseUrl?.(),
        selectedDomainName: (() => { const d = app.selectedDomain?.(); return typeof d === "string" ? d : (d?.name || ""); })(),
        domainAssetsPrefixActive: app.domainAssetsPrefix?.(),
        domainAssetsConfig: app.domainAssetsConfig?.(),
        domainAssetsSource: app.domainAssetsSource?.(),
      });
      setReport(r);
    } catch (e) { setErr(e); } finally { setBusyDiag(false); }
  }

  const Row = (props) => (
    <div class="grid grid-cols-[160px_1fr] gap-2 py-1">
      <div class="text-sm text-[hsl(var(--muted-foreground))]">{props.label}</div>
      <div class="text-sm break-all">{props.children}</div>
    </div>
  );

  return (
    <section class="bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] rounded-lg shadow p-4 space-y-4">
      <div class="flex flex-wrap items-center justify-between gap-3">
        <h3 class="text-lg font-medium">{t("settings.dev.assets.title")}</h3>
        <div class="flex items-center gap-2">
          <span class="text-sm text-[hsl(var(--muted-foreground))]">{t("settings.dev.assets.env")}</span>
          <div class="inline-flex rounded-md border border-[hsl(var(--border))] overflow-hidden">
            <button
              class={`px-3 py-1.5 text-sm ${env() === "prod" ? "bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))]" : "text-[hsl(var(--foreground))]"}`}
              disabled={busySwitch()} onClick={() => switchEnv("prod")}
            >
              {t("settings.dev.assets.env.prod")}
            </button>
            <button
              class={`px-3 py-1.5 text-sm border-l border-[hsl(var(--border))] ${env() === "test" ? "bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))]" : "text-[hsl(var(--foreground))]"}`}
              disabled={busySwitch()} onClick={() => switchEnv("test")}
            >
              {t("settings.dev.assets.env.test")}
            </button>
          </div>
        </div>
      </div>

      <div class="rounded-md bg-[hsl(var(--muted))] p-3 space-y-1">
        <Row label={t("settings.dev.assets.env")}>{env()}</Row>
        <Row label={t("settings.dev.assets.baseUrl")}>{app.assetsBaseUrl?.() || "—"}</Row>
        <Row label={t("settings.dev.assets.prefix.active")}>{app.domainAssetsPrefix?.() || "—"}</Row>
        <Row label={t("settings.dev.assets.source")}>{app.domainAssetsSource?.() || "—"}</Row>
      </div>

      <div class="flex items-center justify-between">
        <div class="text-sm font-medium">{t("settings.dev.assets.diagnostics.title")}</div>
        <button
          class="px-3 py-1.5 rounded-md border border-[hsl(var(--border))] text-sm hover:bg-[hsl(var(--accent))]"
          onClick={runDiagnostics}
          disabled={busyDiag()}
        >
          {busyDiag() ? t("common.loading") : t("settings.dev.assets.diagnostics.run")}
        </button>
      </div>

      {err() && <div class="text-sm text-[hsl(var(--destructive))]">
        {t("settings.dev.assets.diagnostics.error")}: {String(err())}
      </div>}

      <Show when={report()}>
        <div class="space-y-2">
          <Row label={t("settings.dev.assets.domain")}>{report().domain || "—"}</Row>
          <Row label={t("settings.dev.assets.prefix.computed")}>{report().computedDomainPrefix || "—"}</Row>

          {/* Active config (what the app is really using) */}
          <Row label={t("settings.dev.assets.configUrl")}>
            <Show when={report().appConfigUrl} fallback={"—"}>
              <span class="inline-flex items-center gap-2">
                <a href={report().appConfigUrl} target="_blank" rel="noreferrer" class="underline">{report().appConfigUrl}</a>
                <a href={report().appConfigUrl} target="_blank" rel="noreferrer" class="px-2 py-0.5 rounded-md border border-[hsl(var(--border))] text-xs hover:bg-[hsl(var(--accent))]" aria-label={t("settings.dev.assets.configUrl.open")} title={t("settings.dev.assets.configUrl.open")}>↗</a>
              </span>
            </Show>
          </Row>

          {/* Also show the env+domain computed config */}
          <Row label={t("settings.dev.assets.configUrl.computed")}>
            <Show when={report().computedDomainPrefix} fallback={"—"}>
              <span class="inline-flex items-center gap-2">
                <a href={report().computedDomainPrefix + "config.yaml"} target="_blank" rel="noreferrer" class="underline">
                  {report().computedDomainPrefix + "config.yaml"}
                </a>
                <a href={report().computedDomainPrefix + "config.yaml"} target="_blank" rel="noreferrer" class="px-2 py-0.5 rounded-md border border-[hsl(var(--border))] text-xs hover:bg-[hsl(var(--accent))]" aria-label={t("settings.dev.assets.configUrl.open")} title={t("settings.dev.assets.configUrl.open")}>↗</a>
              </span>
            </Show>
          </Row>

          {/* Checks */}
          <div class="pt-2 text-xs space-y-1">
            <div><b>{t("settings.dev.assets.diagnostics.primary")}</b>: {report().primaryConfig.url} — {report().primaryConfig.exists ? t("common.exists") : t("common.notFound")} ({report().primaryConfig.status})</div>
            <Show when={report().primaryConfig.status === -1 && report().primaryConfig.error}>
              <div class="text-[hsl(var(--muted-foreground))]">{t("settings.dev.assets.diagnostics.noteNetwork")} {report().primaryConfig.error}</div>
            </Show>
            <div><b>{t("settings.dev.assets.diagnostics.default")}</b>: {report().defaultConfig.url} — {report().defaultConfig.exists ? t("common.exists") : t("common.notFound")} ({report().defaultConfig.status})</div>
          </div>

          {/* Summary */}
          <div class="pt-2 text-xs space-y-1">
            <div>• {t("settings.dev.assets.diagnostics.hasConfig")}: {String(report().appParsedConfigPresence.hasConfigObject)}</div>
            <div>• {t("settings.dev.assets.diagnostics.hasLogos")}: {String(report().appParsedConfigPresence.hasLogos)} ({(report().appParsedConfigPresence.logoFields || []).join(", ") || "—"})</div>
            <div>• {t("settings.dev.assets.diagnostics.hasLocales")}: {String(report().appParsedConfigPresence.hasLocales)}</div>
            <div>• {t("settings.dev.assets.diagnostics.hasTabs")}: {String(report().appParsedConfigPresence.hasTabs)}</div>
            <div>• {t("settings.dev.assets.diagnostics.hasCategories")}: {String(report().appParsedConfigPresence.hasCategories)}</div>
            <div>• {t("settings.dev.assets.diagnostics.hasFavicon")}: {String(report().appParsedConfigPresence.hasFavicon)}</div>
          </div>

          {/* Sample fetches */}
          <Show when={report().resolvedSamples?.length}>
            <div class="pt-2">
              <div class="text-sm font-semibold">{t("settings.dev.assets.diagnostics.sampleFetches")}</div>
              <ul class="mt-1 space-y-1 text-xs">
                {report().resolvedSamples.map((s) => (
                  <li>{s.kind}: {s.url} — {s.exists ? t("common.ok") : t("common.fail")} ({s.status})</li>
                ))}
              </ul>
            </div>
          </Show>
        </div>
      </Show>
    </section>
  );
}
</file>

<file path="src/components/tabs/NILRightPanel.jsx">
// src/components/tabs/NILRightPanel.jsx
import { useApp } from "../../context/AppContext.jsx";

const HEADER_H = 48; // keep synced with header height

export default function NILRightPanel() {
  const { t } = useApp();

  return (
    <aside
      class="hidden lg:block"
      style={{ position: "sticky", top: `${HEADER_H}px` }}
    >
      <div
        class="rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))]"
        style={{
          "max-height": `calc(100vh - ${HEADER_H}px)`,
          overflow: "hidden",
        }}
      >
        <div
          class="p-3 space-y-3 overflow-auto"
          style={{ "max-height": `calc(100vh - ${HEADER_H}px - 1px - 1px)` }}
        >
          <h4 class="font-semibold">Right Panel</h4>
          <p class="text-sm">
            {t("main.tabs.empty")} — this content is intentionally long to
            demonstrate internal scrolling:
          </p>

          {/* demo long content */}
          <ul class="list-disc ml-5 text-sm space-y-1">
            <li>Example item A</li>
            <li>Example item B</li>
            <li>Example item C</li>
          </ul>
          <div class="text-sm leading-snug space-y-2">
            <p>
              Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis
              congue, magna non gravida finibus, felis nisl finibus nunc,
              laoreet imperdiet arcu erat in felis.
            </p>
            <p>
              Sed vitae lectus nec nisl elementum bibendum. Phasellus vel orci
              vitae lectus dapibus rhoncus. Suspendisse vehicula arcu a sem
              pharetra, at pulvinar ex gravida.
            </p>
            <p>
              Maecenas at urna sed turpis pretium volutpat. Aliquam vulputate
              porttitor metus, ut interdum ante semper quis.
            </p>
            <p>
              Praesent fermentum, justo eu volutpat ultricies, eros ante
              facilisis risus, eget dictum quam nibh a neque. Integer
              ullamcorper, ipsum non consequat sollicitudin, arcu massa
              elementum est, vitae gravida nibh nibh vel eros.
            </p>
            <p>
              Ut at vestibulum nibh. Vivamus euismod, justo vitae dictum
              posuere, mi quam viverra quam, et dictum ex tellus non augue.
            </p>
            <p>
              Integer dignissim lacus sed nibh posuere, vitae luctus lectus
              rhoncus. Vestibulum ante ipsum primis in faucibus orci luctus et
              ultrices posuere cubilia curae; Quisque ut odio non velit maximus
              mollis.
            </p>
          </div>
        </div>
      </div>
    </aside>
  );
}
</file>

<file path="src/components/tabs/NILTab.jsx">
// src/components/tabs/NILTab.jsx
import ContentFeed from "../feed/ContentFeed.jsx";

const HEADER_H = 48; // header height for min page height

export default function NILTab(props) {
  // mock async page loader; replace with backend fetcher later
  async function fetchPage(page, pageSize) {
    await new Promise((r) => setTimeout(r, 250));
    if (page > 6) return [];
    return Array.from({ length: pageSize }, (_, i) => ({
      id: `nil_${page}_${i}`,
      text: `NIL content item ${page}-${i}: long text to demonstrate scrolling.`,
    }));
  }

  return (
    <section class="w-full" style={{ "min-height": `calc(100vh - ${HEADER_H}px)` }}>
      <ContentFeed
        mode={props.tab?._raw?.mode === "grid" ? "grid" : "list"}
        fetchPage={fetchPage}
      />
    </section>
  );
}
</file>

<file path="src/components/tabs/TabPanelScaffold.jsx">
// src/components/tabs/TabPanelScaffold.jsx
import { useApp } from "../../context/AppContext";

/**
 * Minimal shared scaffold for tab content: title + body container.
 */
export default function TabPanelScaffold(props) {
  const { t } = useApp();
  return (
    <section class="space-y-2">
      <h3 class="text-base font-semibold text-[hsl(var(--foreground))]">
        {props.title || t("main.tabs.untitled")}
      </h3>
      <div class="text-sm text-[hsl(var(--muted-foreground))]">
        {props.children ?? t("main.tabs.empty")}
      </div>
    </section>
  );
}
</file>

<file path="src/components/ui/icons/ActionIcons.jsx">
// src/components/ui/icons/ActionIcons.jsx
export function EditIcon(props) {
  return (
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class={props.class || "w-5 h-5"} fill="currentColor">
      <path d="M20.71,3.29a2.91,2.91,0,0,0-2.2-.84,3.25,3.25,0,0,0-2.17,1L9.46,10.29s0,0,0,0a.62.62,0,0,0-.11.17,1,1,0,0,0-.1.18l0,0,L8,14.72A1,1,0,0,0,9,16a.9.9,0,0,0,.28,0l4-1.17,0,0,.18-.1a.62.62,0,0,0,.17-.11l0,0,6.87-6.88a3.25,3.25,0,0,0,1-2.17A2.91,2.91,0,0,0,20.71,3.29Z"></path>
      <path d="M20,22H4a2,2,0,0,1-2-2V4A2,2,0,0,1,4,2h8a1,1,0,0,1,0,2H4V20H20V12a1,1,0,0,1,2,0v8A2,2,0,0,1,20,22Z"></path>
    </svg>
  );
}

export function TrashIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-5 h-5"} fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="3 6 5 6 21 6"></polyline>
      <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
    </svg>
  );
}
</file>

<file path="src/components/ui/icons/CopyIcon.jsx">
// src/components/ui/icons/CopyIcon.jsx
export default function CopyIcon(props) {
  return (
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" {...props}>
      <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
      <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
      <g id="SVGRepo_iconCarrier">
        <path
          fill-rule="evenodd"
          clip-rule="evenodd"
          d="M19.5 16.5L19.5 4.5L18.75 3.75H9L8.25 4.5L8.25 7.5L5.25 7.5L4.5 8.25V20.25L5.25 21H15L15.75 20.25V17.25H18.75L19.5 16.5ZM15.75 15.75L15.75 8.25L15 7.5L9.75 7.5V5.25L18 5.25V15.75H15.75ZM6 9L14.25 9L14.25 19.5L6 19.5L6 9Z"
          fill="currentColor"
        ></path>
      </g>
    </svg>
  );
}
</file>

<file path="src/components/ui/icons/NftBadge.jsx">
// src/components/ui/icons/NftBadge.jsx
export default function NftBadge(props) {
  return (
    <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg" class={props.class || "z-10"}>
      <path d="M15 30C23.2843 30 30 23.2843 30 15C30 6.71573 23.2843 0 15 0C6.71573 0 0 6.71573 0 15C0 23.2843 6.71573 30 15 30Z" fill="#337DB2"></path>
      <path fill-rule="evenodd" clip-rule="evenodd" d="M21.0014 6.1499C22.1844 6.1499 22.88 6.8262 22.88 7.72792C22.88 8.36247 22.3957 8.83003 21.7946 8.83003C21.2185 8.83003 20.7426 8.35412 20.7426 7.74462C20.7426 7.41065 20.8929 7.11842 21.1183 6.92639C19.8327 6.98589 19.2477 8.43568 18.8427 10.3811C18.689 11.1098 18.4541 12.2187 18.2026 13.4043L20.3273 13.1558L20.8155 10.8974L23.3325 10.6083L22.8434 12.8617L29.7119 12.059C29.7937 12.4704 29.8586 12.8878 29.906 13.3105L22.6366 13.8149L21.9478 16.9887C21.7349 18.008 22.0455 18.4588 22.7252 18.4736L22.7601 18.474C23.1908 18.474 23.5645 18.3314 23.8264 18.0941L23.8585 18.064L23.7502 18.5977C23.3248 19.263 22.3191 19.7116 21.3367 19.7116C19.8447 19.7116 19.1474 18.7656 19.4842 17.0607L19.4957 17.0042L20.1475 13.9877L18.0478 14.1334L18.019 14.2691L17.9646 14.5253L17.9221 14.7255C17.6107 16.1914 17.3097 17.6055 17.1364 18.416C16.3808 21.8002 15.0895 24.2249 12.0956 24.2249C10.9127 24.2249 10.217 23.5486 10.217 22.6469C10.217 22.0123 10.7013 21.5448 11.3024 21.5448C11.8785 21.5448 12.3545 22.0207 12.3545 22.6302C12.3545 22.9642 12.2042 23.2564 11.9787 23.4484C13.2643 23.3889 13.8494 21.9391 14.2544 19.9937C14.4203 19.2069 14.6809 17.9768 14.9549 16.6856L15.0007 16.4699C15.0084 16.4339 15.016 16.3978 15.0237 16.3618L15.078 16.1057L15.1202 15.907L15.1624 15.7085C15.2635 15.2324 15.3637 14.7609 15.459 14.313L14.3593 14.3895L14.4825 13.8389L15.5873 13.7098C15.7366 13.0083 15.8672 12.3958 15.9607 11.9588C16.7162 8.57461 18.0075 6.1499 21.0014 6.1499ZM11.4274 11.6513C12.9347 11.6513 13.6322 12.5822 13.2879 14.2867L13.2762 14.3432L12.5645 17.6617C12.4485 18.2032 12.6032 18.4585 12.9745 18.4585C13.2074 18.4585 13.5089 18.3694 13.7242 18.2106L13.7635 18.18L13.6475 18.7138C13.2143 19.2785 12.317 19.6962 11.3887 19.6962C10.328 19.6962 9.84693 19.1015 10.1015 17.8007L10.1123 17.7468L10.8704 14.1653C11.0561 13.2989 10.8008 12.8038 10.1588 12.8038C9.43613 12.8038 8.69854 13.5892 8.42408 14.7187L8.41053 14.7764L7.38944 19.5724H4.95276L6.17669 13.8481C6.26713 13.4185 6.10427 13.1725 5.68304 13.1842L5.64924 13.1857L0.0639648 13.6065C0.0800724 13.4316 0.0991812 13.2576 0.121239 13.0845L8.99069 11.7131L8.5343 13.8481C9.08352 12.4248 10.1433 11.6513 11.4274 11.6513Z" fill="white"></path>
    </svg>
  );
}
</file>

<file path="src/components/ui/icons/SavvaTokenIcon.jsx">
// src/components/ui/icons/SavvaTokenIcon.jsx
export default function SavvaTokenIcon(props) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 25 25"
      class={props.class || "w-4 h-4"}
      aria-hidden="true"
    >
      <g>
        <path
          d="M 12.035156 19.488281 C 8.757812 18.808594 7.097656 16.25 7.304688 14 C 8.429688 16.339844 10.179688 17.542969 12.644531 17.542969 C 17.105469 17.542969 19.667969 12.167969 24.933594 11.21875 C 24.632812 8.28125 23.304688 5.546875 21.179688 3.496094 C 19.054688 1.445312 16.273438 0.214844 13.328125 0.0195312 C 10.382812 -0.175781 7.460938 0.675781 5.085938 2.429688 C 2.707031 4.179688 1.027344 6.714844 0.34375 9.585938 C 4.355469 8.675781 8.09375 4.496094 12.96875 5.511719 C 16.25 6.191406 17.902344 8.75 17.695312 11 C 16.570312 8.660156 14.820312 7.457031 12.355469 7.457031 C 7.894531 7.457031 5.332031 12.832031 0.0664062 13.78125 C 0.367188 16.71875 1.695312 19.453125 3.820312 21.503906 C 5.945312 23.554688 8.726562 24.785156 11.671875 24.984375 C 14.617188 25.179688 17.535156 24.324219 19.914062 22.574219 C 22.289062 20.824219 23.972656 18.289062 24.65625 15.417969 C 20.644531 16.324219 16.914062 20.5 12.035156 19.488281 Z M 12.5 9.601562 C 13.074219 9.601562 13.632812 9.769531 14.109375 10.089844 C 14.585938 10.410156 14.957031 10.859375 15.179688 11.390625 C 15.398438 11.921875 15.453125 12.503906 15.34375 13.066406 C 15.230469 13.628906 14.957031 14.144531 14.550781 14.550781 C 14.144531 14.957031 13.628906 15.230469 13.066406 15.34375 C 12.503906 15.453125 11.921875 15.398438 11.390625 15.179688 C 10.859375 14.957031 10.410156 14.585938 10.089844 14.109375 C 9.769531 13.632812 9.601562 13.074219 9.601562 12.5 C 9.601562 11.730469 9.90625 10.992188 10.449219 10.449219 C 10.992188 9.90625 11.730469 9.601562 12.5 9.601562 Z M 12.5 9.601562 "
          style="stroke: none; fill-rule: nonzero; fill: rgb(255, 113, 0); fill-opacity: 1;"
        ></path>
      </g>
    </svg>
  );
}
</file>

<file path="src/components/ui/Address.jsx">
// src/components/ui/Address.jsx
import { createMemo } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { pushToast } from "../../ui/toast.js";
import CopyIcon from "./icons/CopyIcon.jsx";
import { toChecksumAddress } from "../../blockchain/utils.js";

function shortAddr(addr) {
  if (!addr) return "";
  return addr.slice(0, 6) + "…" + addr.slice(-4);
}

export default function Address(props) {
  const { t } = useApp();
  const checksummedAddress = createMemo(() => {
    try {
      return toChecksumAddress(props.address);
    } catch {
      return "";
    }
  });

  const displayAddress = createMemo(() => {
    const addr = checksummedAddress();
    if (!addr) return "";
    return props.format === 'full' ? addr : shortAddr(addr);
  });

  const handleCopy = (e) => {
    e.stopPropagation();
    const addr = checksummedAddress();
    if (!addr) return;
    navigator.clipboard.writeText(addr).then(() => {
      pushToast({ type: "success", message: t("profile.addressCopied") });
    });
  };

  return (
    <div 
      class="flex items-center gap-1.5 text-sm text-[hsl(var(--muted-foreground))] font-mono"
      title={checksummedAddress()}
    >
      <span>{displayAddress()}</span>
      <button onClick={handleCopy} class="hover:text-[hsl(var(--foreground))]">
        <CopyIcon class="w-4 h-4" />
      </button>
    </div>
  );
}
</file>

<file path="src/components/ui/ClosePageButton.jsx">
// src/components/ui/ClosePageButton.jsx
import { useApp } from "../../context/AppContext.jsx";
import { useHashRouter } from "../../routing/hashRouter";

/**
 * Close (go to main tabs view) or Back (go to previous history entry) floating button.
 * @param {object} props
 * @param {string} [props.mode='back'] - 'back' for history.back(), 'close' to navigate to the main feed.
 */
export default function ClosePageButton(props) {
  const app = useApp();
  const { navigate } = useHashRouter();
  const { t } = app;
  const label = props.title || t("settings.back");
  const offsetTop = props.offsetTop ?? 56;
  const mode = props.mode || 'back';

  const handleClick = () => {
    if (mode === 'close') {
      navigate(app.lastTabRoute() || "/");
    } else {
      window.history.back();
    }
  };

  return (
    <button
      type="button"
      onClick={handleClick}
      aria-label={label}
      title={label}
      class="fixed right-3 z-20 p-2 rounded-full
             bg-[hsl(var(--background))]/70
             hover:bg-[hsl(var(--accent))] hover:text-[hsl(var(--accent-foreground))] 
             shadow-sm transition-colors"
      style={{ top: `${offsetTop}px` }}
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        class="w-5 h-5"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
        aria-hidden="true"
      >
        <line x1="18" y1="6" x2="6" y2="18" />
        <line x1="6" y1="6" x2="18" y2="18" />
      </svg>
    </button>
  );
}
</file>

<file path="src/components/ui/ConfirmModal.jsx">
// src/components/ui/ConfirmModal.jsx
import { Show } from "solid-js";
import { useApp } from "../../context/AppContext";

export default function ConfirmModal(props) {
  const { t } = useApp();

  return (
    <Show when={props.isOpen}>
      <div class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/40" onClick={props.onClose} />
        <div class="relative themed-dialog rounded-lg shadow-lg w-full max-w-md p-4 bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))]">
          <h3 class="text-lg font-semibold mb-2">{props.title}</h3>
          <p class="text-sm text-[hsl(var(--muted-foreground))] mb-4">{props.message}</p>
          <div class="flex gap-2 justify-end">
            <button
              class="px-3 py-2 rounded bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))] hover:opacity-90"
              onClick={props.onClose}
            >
              {props.cancelText || t("common.cancel")}
            </button>
            <button
              class="px-3 py-2 rounded bg-[hsl(var(--destructive))] text-[hsl(var(--destructive-foreground))] hover:opacity-90"
              onClick={() => {
                props.onConfirm?.();
                props.onClose?.();
              }}
            >
              {props.confirmText || t("common.confirm")}
            </button>
          </div>
        </div>
      </div>
    </Show>
  );
}
</file>

<file path="src/components/ui/PostFundBadge.jsx">
// src/components/ui/PostFundBadge.jsx
import { createSignal, createEffect, on, createMemo } from "solid-js";
import SavvaTokenIcon from "./icons/SavvaTokenIcon";
import { formatRewardAmount } from "../../blockchain/utils";

export default function PostFundBadge(props) {
  const [isAnimating, setIsAnimating] = createSignal(false);

  const formattedAmount = createMemo(() => {
    return formatRewardAmount(props.amount);
  });

  const triggerAnimation = () => {
    if (isAnimating()) return;
    setIsAnimating(true);
    setTimeout(() => setIsAnimating(false), 300);
  };

  createEffect(on(() => props.amount, triggerAnimation, { defer: true }));

  return (
    <div
      // MODIFICATION: Replaced 'text-white' with the theme-aware card foreground color.
      class="flex items-center gap-2 pl-3 pr-4 py-1.5 rounded-l-full text-[hsl(var(--card))] font-semibold text-base shadow-lg cursor-pointer"
      style={{ background: "var(--gradient)" }}
      classList={{ "animate-bounce-short": isAnimating() }}
      onClick={triggerAnimation}
    >
      <SavvaTokenIcon class="w-5 h-5" />
      <span>{formattedAmount()}</span>
    </div>
  );
}
</file>

<file path="src/components/ui/Spinner.jsx">
// src/components/ui/Spinner.jsx

export default function Spinner(props) {
  return (
    <svg
      class={`animate-spin ${props.class || "h-5 w-5 text-[hsl(var(--foreground))]"}`}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        class="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        stroke-width="4"
      />
      <path
        class="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      />
    </svg>
  );
}
</file>

<file path="src/components/ui/TokenValue.jsx">
// src/components/ui/TokenValue.jsx
import { createMemo, Show, createSignal, createEffect, on } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { formatUnits } from "viem";
import SavvaTokenIcon from "./icons/SavvaTokenIcon.jsx";
import { getChainLogo } from "../../blockchain/chainLogos.js";

export default function TokenValue(props) {
  const app = useApp();
  const savvaTokenAddress = () => app.info()?.savva_contracts?.SavvaToken?.address;
  const desiredChain = createMemo(() => app.desiredChain());

  const isBaseToken = createMemo(() => props.tokenAddress === "0");
  const tokenAddress = createMemo(() => props.tokenAddress || savvaTokenAddress());
  const isSavvaToken = createMemo(() => !isBaseToken() && tokenAddress()?.toLowerCase() === savvaTokenAddress()?.toLowerCase());

  const formattedAmount = createMemo(() => {
    try {
      const amount = parseFloat(formatUnits(BigInt(props.amount || 0), 18));
      return amount.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    } catch {
      return "0.00";
    }
  });

  const sourceUsdValue = createMemo(() => {
    let priceData = null;
    if (isSavvaToken()) {
      priceData = app.savvaTokenPrice();
    } else if (isBaseToken()) {
      priceData = app.baseTokenPrice();
    }
    
    if (!priceData?.price) return null;

    try {
      const amount = parseFloat(formatUnits(BigInt(props.amount || 0), 18));
      const price = priceData.price;
      const total = amount * price;
      return total.toLocaleString(undefined, { style: 'currency', currency: 'USD' });
    } catch {
      return null;
    }
  });

  const [displayUsdValue, setDisplayUsdValue] = createSignal(sourceUsdValue());
  const [isAnimating, setIsAnimating] = createSignal(false);

  createEffect(on(sourceUsdValue, (newValue, prevValue) => {
    if (prevValue === undefined || prevValue === null) {
      setDisplayUsdValue(newValue);
      return;
    }
    setDisplayUsdValue(prevValue);
    setIsAnimating(true);
    setTimeout(() => { setDisplayUsdValue(newValue); }, 200);
    setTimeout(() => { setIsAnimating(false); }, 400);
  }, { defer: true }));

  const TokenIcon = () => {
    if (isSavvaToken()) {
      return <SavvaTokenIcon class="w-4 h-4" />;
    }
    if (isBaseToken()) {
        const logoSrc = getChainLogo(desiredChain()?.id);
        if (logoSrc) {
            return <img src={logoSrc} alt={desiredChain()?.nativeCurrency.symbol} class="w-5 h-5" />;
        }
    }
    return null;
  };

  const isVertical = () => props.format === 'vertical';

  return (
    <Show
      when={isVertical()}
      fallback={
        <div class={`flex items-center gap-1.5 text-sm ${props.class || ''}`}>
          <TokenIcon />
          <span class="font-semibold">{formattedAmount()}</span>
          <Show when={displayUsdValue()}>
            <span class="text-xs text-[hsl(var(--muted-foreground))]" classList={{ "default-animation": isAnimating() }}>
              ({displayUsdValue()})
            </span>
          </Show>
        </div>
      }
    >
      <div class={`flex flex-col items-end text-sm ${props.class || ''}`}>
        <div class="flex items-center gap-1.5">
          <TokenIcon />
          <span class="font-semibold">{formattedAmount()}</span>
        </div>
        <Show when={displayUsdValue()}>
          <span class="text-xs text-[hsl(var(--muted-foreground))]" classList={{ "default-animation": isAnimating() }}>
            ({displayUsdValue()})
          </span>
        </Show>
      </div>
    </Show>
  );
}
</file>

<file path="src/components/ui/ToTopButton.jsx">
// src/components/ui/ToTopButton.jsx
import { createSignal, onMount, onCleanup, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

/**
 * ToTopButton
 * - Appears when scrolled beyond `threshold` (default: 240px)
 * - By default listens to window scroll; pass `targetEl` to watch a specific container
 * - Position: bottom-center (fixed) – style via .sv-to-top classes
 */
export default function ToTopButton(props) {
  const app = useApp();
  const threshold = typeof props.threshold === "number" ? props.threshold : 240;

  const [visible, setVisible] = createSignal(false);

  let el; // button node (not strictly needed, but handy if you want to focus etc.)

  function getScrollTop() {
    const t = props.targetEl;
    if (t && t.scrollTop != null) return t.scrollTop;
    return window.scrollY || document.documentElement.scrollTop || 0;
  }

  function onScroll() {
    setVisible(getScrollTop() > threshold);
  }

  function scrollToTop() {
    const t = props.targetEl;
    if (t && typeof t.scrollTo === "function") {
      t.scrollTo({ top: 0, behavior: "smooth" });
    } else {
      window.scrollTo({ top: 0, behavior: "smooth" });
    }
  }

  onMount(() => {
    const target = props.targetEl || window;
    target.addEventListener("scroll", onScroll, { passive: true });
    // initial state
    onScroll();

    onCleanup(() => {
      target.removeEventListener("scroll", onScroll);
    });
  });

  return (
    <Show when={visible()}>
      <button
        ref={el}
        type="button"
        class={`sv-to-top ${props.class || ""}`}
        aria-label={app.t("ui.toTop")}
        title={app.t("ui.toTop")}
        onClick={scrollToTop}
      >
        {/* up arrow */}
        <svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
          <path
            d="M12 4l-7 7m7-7l7 7M12 4v16"
            fill="none"
            stroke="currentColor"
            stroke-width="2.2"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </button>
    </Show>
  );
}
</file>

<file path="src/components/RightPaneFooter.jsx">
// File: src/components/ui/RightPaneFooter.jsx
import { APP_VERSION } from "../version.js";
import { useApp } from "../context/AppContext.jsx";

export default function RightPaneFooter() {
  const app = useApp();
  const { t } = app;
  const WEBSITE_URL = import.meta.env.VITE_WEBSITE_URL || "https://savva.app";

  return (
    <div class="mt-auto pt-3 border-t border-[hsl(var(--border))] text-sm text-[hsl(var(--muted-foreground))]">
      <div class=" items-center justify-between">
        <div>{t("app.versionLabel")} <b>v{APP_VERSION}</b></div>
        <div>
          Powered by{" "}
          <b><a
            href={WEBSITE_URL}
            target="_blank"
            rel="noreferrer"
            class="underline hover:opacity-80 text-[hsl(var(--foreground))]"
          >
            SAVVA Platform
          </a>
          </b>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/context/useTokenPrices.js">
// src/context/useTokenPrices.js
import { createSignal, onMount, onCleanup, createMemo } from "solid-js";
import { whenWsOpen, getWsApi } from "../net/wsRuntime";
import { dbg } from "../utils/debug";

export function useTokenPrices(app) {
  const [prices, setPrices] = createSignal({});

  const updatePrices = (data) => {
    if (!data || !data.tokens) return;
    setPrices(prev => ({ ...prev, ...data.tokens }));
  };

  const fetchInitialPrices = async () => {
    try {
      await whenWsOpen();
      const api = getWsApi();
      const data = await api.call("get-token-prices");
      dbg.log("TokenPrices", "Fetched initial prices", data);
      updatePrices(data);
    } catch (error) {
      dbg.error("TokenPrices", "Failed to fetch initial token prices", error);
    }
  };

  onMount(() => {
    fetchInitialPrices();
  });
  
  const savvaTokenPrice = createMemo(() => {
    const savvaTokenAddress = app.info()?.savva_contracts?.SavvaToken?.address;
    if (!savvaTokenAddress) return null;
    return prices()[savvaTokenAddress] || null;
  });
  
  const baseTokenPrice = createMemo(() => {
    // The key for the base/native token is an empty string
    return prices()[""] || null; 
  });

  return {
    allTokenPrices: prices,
    savvaTokenPrice,
    baseTokenPrice,
    updateTokenPrices: updatePrices
  };
}
</file>

<file path="src/dev/AssetDebugTap.jsx">
// src/dev/AssetDebugTap.jsx
/* src/dev/AssetDebugTap.jsx */
import { createEffect } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import { dbg } from "../utils/debug";

const dn = (d) => (typeof d === "string" ? d : d?.name || "");

export default function AssetDebugTap() {
    const app = useApp();

    // Track & log env
    let prevEnv;
    createEffect(() => {
        const next = app.assetsEnv?.();
        if (prevEnv !== next) {
            dbg.log("assets", "assetsEnv changed:", { prev: prevEnv, next });
            prevEnv = next;
        }
    });

    // Track & log base URL from /info
    let prevBase;
    createEffect(() => {
        const next = app.assetsBaseUrl?.();
        if (prevBase !== next) {
            dbg.log("assets", "assetsBaseUrl changed:", { prev: prevBase, next });
            prevBase = next;
        }
    });

    // Track & log selected domain
    let prevDomain;
    createEffect(() => {
        const next = dn(app.selectedDomain?.());
        if (prevDomain !== next) {
            dbg.log("assets", "selectedDomain changed:", { prev: prevDomain, next });
            prevDomain = next;
        }
    });

    // Track & log ACTIVE prefix the app uses for all assets
    let prevPrefix;
    createEffect(() => {
        const next = app.domainAssetsPrefix?.();
        if (prevPrefix !== next) {
            dbg.log("assets", "domainAssetsPrefix (ACTIVE) changed:", { prev: prevPrefix, next });
            prevPrefix = next;
        }
    });

    // Track & log where the config came from: remote (domain) vs default pack
    let prevSource;
    createEffect(() => {
        const next = app.domainAssetsSource?.();
        if (prevSource !== next) {
            dbg.log("assets", "domainAssetsSource changed:", { prev: prevSource, next });
            prevSource = next;
        }
    });

    // Track & log parsed config.yaml presence and key fields (logos/tabs)
    let prevStamp;
    createEffect(() => {
        const cfg = app.domainAssetsConfig?.();
        const stamp = cfg
            ? JSON.stringify({
                cid: cfg.assets_cid || cfg.cid || null,
                gotLogos: !!(cfg.logos || cfg.logo),
                tabs: !!cfg.modules?.tabs,
            })
            : "null";

        if (prevStamp !== stamp) {
            dbg.group("assets: domainAssetsConfig loaded/changed");
            dbg.log("assets", "summary:", {
                hasConfig: !!cfg,
                hasLogos: !!(cfg?.logos || cfg?.logo),
                tabsPath: cfg?.modules?.tabs || null,
                assets_cid: cfg?.assets_cid || cfg?.cid || null,
            });
            dbg.groupEnd();
            prevStamp = stamp;
        }
    });

    // Nothing to render
    return null;
}
</file>

<file path="src/docs/rehype-media-players.js">
// src/docs/rehype-media-players.js
import { visit } from "unist-util-visit";

const YOUTUBE_REGEX = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
const VIDEO_EXTENSIONS = /\.(mp4|webm|ogg)$/i;
const AUDIO_EXTENSIONS = /\.(mp3|wav|ogg|m4a)$/i;

function isVideoUrl(url, altText = "") {
  return VIDEO_EXTENSIONS.test(url) || VIDEO_EXTENSIONS.test(altText);
}

function isAudioUrl(url, altText = "") {
  return AUDIO_EXTENSIONS.test(url) || AUDIO_EXTENSIONS.test(altText);
}

function getYouTubeId(url) {
  const match = url.match(YOUTUBE_REGEX);
  return match ? match[1] : null;
}

export function rehypeMediaPlayers() {
  return (tree) => {
    visit(tree, "element", (node) => {
      if (node.tagName !== "img" || !node.properties?.src) {
        return;
      }

      const url = node.properties.src;
      const alt = node.properties.alt;
      const youtubeId = getYouTubeId(url);

      if (youtubeId) {
        node.tagName = "div";
        node.properties = {
          className: "youtube-container",
          style: "position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;"
        };
        node.children = [{
          type: "element",
          tagName: "iframe",
          properties: {
            src: `https://www.youtube.com/embed/${youtubeId}`,
            frameborder: "0",
            allowfullscreen: true,
            style: "position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
          },
          children: []
        }];
      } else if (isVideoUrl(url, alt)) {
        node.tagName = "video";
        node.properties = {
          src: url,
          controls: true,
          style: "width: 100%; border-radius: 0.5rem;"
        };
        node.children = [];
      } else if (isAudioUrl(url, alt)) {
        node.tagName = "audio";
        node.properties = {
          src: url,
          controls: true,
          style: "width: 100%;"
        };
        node.children = [];
      }
    });
    return tree;
  };
}
</file>

<file path="src/docs/rehype-rewrite-links.js">
// src/components/docs/rehype-rewrite-links.js
import { visit } from "unist-util-visit";

/**
 * A rehype plugin that rewrites relative image and link URLs to be absolute,
 * based on a provided base URL.
 * @param {object} options - The options object.
 * @param {string} options.base - The base URL to prepend to relative paths.
 */
export function rehypeRewriteLinks(options = {}) {
  return (tree) => {
    // FIX: Always return the tree, even if there's no base URL.
    if (!options.base) {
      return tree;
    }
    
    const base = options.base.endsWith('/') ? options.base : `${options.base}/`;
    const isRelative = (url) => !/^(#|\/|[a-z]+:)/i.test(url);
    
    visit(tree, "element", (node) => {
      if (node.tagName === 'a' || node.tagName === 'img') {
        const prop = node.tagName === 'a' ? 'href' : 'src';
        const url = node.properties?.[prop];
        if (typeof url === 'string' && isRelative(url)) {
          node.properties[prop] = base + url;
        }
      }
    });

    return tree;
  };
}
</file>

<file path="src/editor/text-utils.js">
// src/components/editor/text-utils.js

/**
 * Inserts a given string of text at the current cursor position in a textarea.
 * @param {HTMLTextAreaElement} textarea - The textarea element.
 * @param {string} text - The text to insert.
 * @param {function(string): void} onUpdate - Callback to update the signal holding the textarea's value.
 */
export function insertTextAtCursor(textarea, text, onUpdate) {
  if (!textarea || !text) return;

  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const fullText = textarea.value;

  const newText = fullText.substring(0, start) + text + fullText.substring(end);
  onUpdate(newText);

  requestAnimationFrame(() => {
    textarea.focus();
    const newCursorPos = start + text.length;
    textarea.setSelectionRange(newCursorPos, newCursorPos);
  });
}


/**
 * Applies markdown formatting to the selected text in a textarea.
 * @param {HTMLTextAreaElement} textarea - The textarea element.
 * @param {'bold' | 'italic' | 'link' | 'image'} format - The markdown format to apply.
 * @param {function(string): void} onUpdate - Callback to update the signal holding the textarea's value.
 */
export function applyMarkdownFormat(textarea, format, onUpdate) {
  if (!textarea) return;

  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const selectedText = textarea.value.substring(start, end);
  const fullText = textarea.value;

  let replacement;
  let prefix, suffix, placeholder;

  // Special handling for 'image' format
  if (format === 'image') {
    replacement = `![alt text](${selectedText || 'image_url'})`;
  } else {
    // Standard handling for other formats
    switch (format) {
      case 'bold':
        prefix = '**';
        suffix = '**';
        placeholder = 'bold text';
        break;
      case 'italic':
        prefix = '*';
        suffix = '*';
        placeholder = 'italic text';
        break;
      case 'link':
        prefix = '[';
        suffix = '](url)';
        placeholder = 'link text';
        break;
      default:
        return;
    }
    const textToWrap = selectedText || placeholder;
    replacement = prefix + textToWrap + suffix;
  }
  
  textarea.focus();
  textarea.setSelectionRange(start, end);

  const success = document.execCommand('insertText', false, replacement);

  if (!success) {
    const newText = fullText.substring(0, start) + replacement + fullText.substring(end);
    onUpdate(newText);
  }

  requestAnimationFrame(() => {
    textarea.focus();
    
    if (format === 'image') {
      if (selectedText) {
        const altTextStart = start + '!['.length;
        const altTextEnd = altTextStart + 'alt text'.length;
        textarea.setSelectionRange(altTextStart, altTextEnd);
      } else {
        const urlStart = start + '![alt text]('.length;
        const urlEnd = urlStart + 'image_url'.length;
        textarea.setSelectionRange(urlStart, urlEnd);
      }
    } else {
      if (selectedText) {
        textarea.setSelectionRange(start, start + replacement.length);
      } else {
        const cursorPosStart = start + prefix.length;
        const cursorPosEnd = cursorPosStart + placeholder.length;
        textarea.setSelectionRange(cursorPosStart, cursorPosEnd);
      }
    }
  });
}
</file>

<file path="src/hooks/useDeleteAction.js">
// src/hooks/useDeleteAction.js
import { createSignal, createMemo } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import { getSavvaContract } from "../blockchain/contracts.js";
import { toHexBytes32 } from "../blockchain/utils.js";
import { navigate } from "../routing/hashRouter.js";
import { pushToast, pushErrorToast } from "../ui/toast.js";

export function useDeleteAction(contentObjectAccessor) {
  const app = useApp();
  const { t } = app;
  const [isDeleting, setIsDeleting] = createSignal(false);
  const [showConfirm, setShowConfirm] = createSignal(false);

  const isComment = createMemo(() => !!contentObjectAccessor()?.parent_savva_cid);

  const openConfirm = (e) => {
    e?.stopPropagation();
    setShowConfirm(true);
  };
  
  const closeConfirm = () => setShowConfirm(false);

  const confirmDelete = async () => {
    const content = contentObjectAccessor();
    if (!content) return;

    setIsDeleting(true);
    try {
      const contract = await getSavvaContract(app, "ContentRegistry", { write: true });
      
      const contentType = isComment() ? "comment" : "post";
      
      await contract.write.reg([
          content.domain,
          content.author.address,
          content.guid,
          "", // Empty IPFS field indicates deletion
          toHexBytes32(contentType)
      ]);

      navigate("/");
      pushToast({ type: "success", message: t("delete.toast.success") });
    } catch (err) {
      pushErrorToast(err, { context: t("delete.toast.error") });
    } finally {
      setIsDeleting(false);
      closeConfirm();
    }
  };
  
  const modalProps = createMemo(() => {
    const type = isComment() ? "comment" : "post";
    return {
      title: t(`delete.confirm.${type}.title`),
      message: t("delete.confirm.message"),
      confirmText: isDeleting() ? t("delete.confirm.deleting") : t("delete.confirm.confirm"),
    };
  });

  return { isDeleting, showConfirm, openConfirm, closeConfirm, confirmDelete, modalProps };
}
</file>

<file path="src/hooks/useDomainCategories.js">
// src/hooks/useDomainCategories.js
import { createMemo, createResource } from "solid-js";
import { loadAssetResource } from "../utils/assetLoader.js";

export function useDomainCategories(app) {
  const cfg = () => app.domainAssetsConfig?.();
  const relPath = createMemo(() => cfg()?.modules?.categories || null);
  const lang = () => (app.lang?.() || "en").toLowerCase();
  const params = createMemo(() => ({ rel: relPath(), lang: lang() }));
  
  const [cats] = createResource(params, async ({ rel, lang }) => {
    if (!rel) return [];
    try {
      const data = await loadAssetResource(app, rel, { type: "yaml" });
      const listByLang = data?.locales?.[lang] || data?.locales?.en || [];
      return (Array.isArray(listByLang) ? listByLang : []).map(String);
    } catch (err) {
      console.error(`Failed to load categories from ${rel}:`, err);
      return [];
    }
  });
  return cats;
}
</file>

<file path="src/net/wsApi.js">
// File: src/net/wsApi.js
// Thin helper over WsClient for JSON-RPC-like calls and simple method sugar.

export function createWsApi(wsClient) {
  function call(method, params = {}, opts) {
    return wsClient.call(String(method), params, opts);
  }

  // Sugar: api.method("get-user") returns (...args) => call("get-user", ...mergedParams)
  function method(name, fixedParams = {}) {
    const m = String(name);
    return (params = {}, opts) => call(m, { ...fixedParams, ...params }, opts);
  }

  // Optional: define a few common factories here as you add them over time.
  const api = { call, method };

  return api;
}
</file>

<file path="src/net/wsBus.js">
// File: src/net/wsBus.js
// Lightweight event bus for WS alerts (type-based) with a small replay buffer.

export function createWsBus({ replay = 0 } = {}) {
  const map = new Map();          // type -> Set<fn>
  const any = new Set();          // watchers of all events
  const buf = [];                 // [{type, payload, ts}]
  const max = Math.max(0, replay | 0);

  function on(type, fn) {
    if (!type || type === "*") { any.add(fn); return () => any.delete(fn); }
    let set = map.get(type); if (!set) { set = new Set(); map.set(type, set); }
    set.add(fn);
    if (max > 0) {
      for (let i = 0; i < buf.length; i++) if (buf[i].type === type) try { fn(buf[i].payload); } catch {}
    }
    return () => set.delete(fn);
  }

  function off(type, fn) {
    if (!type || type === "*") { any.delete(fn); return; }
    const set = map.get(type); if (set) set.delete(fn);
  }

  function emit(type, payload) {
    if (max > 0) {
      buf.push({ type, payload, ts: Date.now() });
      if (buf.length > max) buf.splice(0, buf.length - max);
    }
    const set = map.get(type);
    if (set) for (const fn of Array.from(set)) try { fn(payload); } catch {}
    for (const fn of Array.from(any)) try { fn({ type, payload }); } catch {}
  }

  function clear() { map.clear(); any.clear(); buf.length = 0; }

  return { on, off, emit, clear };
}
</file>

<file path="src/net/wsUrl.js">
// File: src/net/wsUrl.js
export function toWsUrl(backendHttpUrl, { path = "/ws", query = {} } = {}) {
  if (!backendHttpUrl) return "";
  const u = new URL(backendHttpUrl);
  u.protocol = u.protocol === "https:" ? "wss:" : "ws:";
  const basePath = u.pathname.endsWith("/") ? u.pathname : (u.pathname + "/");
  const wsPath = path.startsWith("/") ? path.slice(1) : path;
  u.pathname = basePath + wsPath;

  const params = new URLSearchParams(u.search);
  for (const [k, v] of Object.entries(query)) {
    if (v != null && v !== "") params.set(k, String(v));
  }
  u.search = params.toString() ? `?${params.toString()}` : "";
  return u.toString();
}
</file>

<file path="src/routing/hashRouter.js">
// src/routing/hashRouter.js
import { createSignal } from "solid-js";

function readHashPath() {
  const raw = window.location.hash || "";
  return raw.replace(/^#/, "") || "/";
}

const [route, setRoute] = createSignal(readHashPath());

function setFromHash() {
  const newPath = readHashPath();
  setRoute(newPath);
}

if (typeof window !== "undefined") {
  window.addEventListener("hashchange", setFromHash);
}

export function navigate(path, { replace = false } = {}) {
  const target = path.startsWith("#") ? path : `#${path}`;
  if (replace) window.location.replace(target);
  else window.location.hash = path.startsWith("#") ? path.slice(1) : path;
}

export function useHashRouter() {
  return { route, navigate };
}
</file>

<file path="src/routing/tabRoutes.js">
// src/routing/tabRoutes.js
// Tiny helpers for tab <-> URL
export const TAB_PREFIX = "/t";

function slug(s) {
  return String(s || "").trim().toLowerCase();
}

/** e.g., "leaders" -> "/t/leaders" */
export function tabPath(idOrType) {
  const key = slug(idOrType);
  return `${TAB_PREFIX}/${encodeURIComponent(key)}`;
}

/** If route is "/t/<key>" returns "<key>", else "" */
export function tabKeyFromRoute(route) {
  const r = String(route || "");
  if (!r.startsWith(TAB_PREFIX + "/")) return "";
  const key = r.slice((TAB_PREFIX + "/").length);
  return decodeURIComponent(key || "");
}
</file>

<file path="src/ui/toast.js">
// src/components/ui/toast.js
import { createSignal } from "solid-js";

export const [toasts, setToasts] = createSignal([]); // {id, type, message, details, expanded}

let counter = 0;

export function pushToast({ type = "info", message = "", details = null, autohideMs = 5000 }) {
  const id = ++counter;
  const item = { id, type, message: String(message || ""), details, expanded: false };
  setToasts((curr) => [...curr, item]);

  // MODIFICATION: Removed '&& type !== "error"' to allow the timer to apply to all toast types.
  if (autohideMs > 0) {
    setTimeout(() => dismissToast(id), autohideMs);
  }
  return id;
}

export function dismissToast(id) {
  setToasts((curr) => curr.filter((t) => t.id !== id));
}

export function toggleToast(id) {
  setToasts((curr) =>
    curr.map((t) => (t.id === id ? { ...t, expanded: !t.expanded } : t))
  );
}

/** Convenience: turn any Error (or unknown) into a compact, useful details object */
export function errorDetails(err, extra = {}) {
  if (!err) return extra || {};
  const base = {
    name: err.name,
    message: err.message,
    code: err.code,
    type: err.type,
    status: err.status,
    stack: err.stack,
    cause: err.cause && typeof err.cause === "object" ? {
      name: err.cause.name,
      message: err.cause.message,
      code: err.cause.code,
      status: err.cause.status,
    } : undefined,
  };
  
  if (Array.isArray(err.causes)) {
    base.causes = err.causes.map((e) => ({
      name: e?.name,
      message: e?.message,
      code: e?.code,
      status: e?.status,
      url: e?.url 
    }));
  }
  
  return { ...base, ...extra };
}

/** push an error toast with extracted details */
export function pushErrorToast(err, context = {}) {
  return pushToast({
    type: "error",
    message: err?.message || "Unexpected error",
    details: errorDetails(err, context),
    // MODIFICATION: Changed from 0 to 60000ms (1 minute).
    autohideMs: 60000,
  });
}
</file>

<file path="src/utils/assetsDiagnostics.js">
// src/utils/assetsDiagnostics.js
// Utility to assess domain asset resources and common pitfalls.

import { fetchWithTimeout } from "./net";

function join(base, rel) {
  const b = base?.endsWith("/") ? base : (base || "") + "/";
  const r = String(rel || "").replace(/^\/+/, "");
  return b + r;
}

function summarizeLogos(cfg) {
  if (!cfg) return { has: false, fields: [], pickable: [] };
  const raw = cfg.logos ?? cfg.logo ?? null;
  if (!raw) return { has: false, fields: [], pickable: [] };
  if (typeof raw === "string") return { has: true, fields: ["default"], pickable: ["default"] };
  const l = {
    dark_mobile:  raw.dark_mobile  ?? raw.mobile_dark  ?? null,
    light_mobile: raw.light_mobile ?? raw.mobile_light ?? null,
    mobile:       raw.mobile ?? null,
    dark:         raw.dark   ?? null,
    light:        raw.light  ?? null,
    default:      raw.default?? raw.fallback ?? null,
  };
  const fields = Object.entries(l).filter(([,v]) => !!v).map(([k]) => k);
  return { has: fields.length > 0, fields, pickable: fields };
}

export async function assessAssets(p) {
  const fetcher = p.fetcher || ((url, opts) => fetchWithTimeout(url, { timeoutMs: 8000, ...(opts || {}) }));
  const base = String(p.assetsBaseUrl || "");
  const domain = String(p.selectedDomainName || "");
  const computedDomainPrefix = base && domain ? join(base, domain + "/") : "";
  const activePrefix = String(p.domainAssetsPrefixActive || "");
  const primaryConfigUrl = computedDomainPrefix ? join(computedDomainPrefix, "config.yaml") : "";
  const defaultConfigUrl = "/domain_default/config.yaml";

  async function check(url) {
    if (!url) return { url, ok: false, status: 0, exists: false, error: null };
    let res, method = "HEAD";
    try {
      res = await fetcher(url, { method, cache: "no-store" });
    } catch (e) {
      try { method = "GET"; res = await fetcher(url, { method, cache: "no-store" }); }
      catch (e2) { return { url, ok: false, status: -1, exists: false, error: String(e2) }; }
    }
    if (method === "HEAD" && !res.ok && res.status !== 404) {
      try { method = "GET"; res = await fetcher(url, { method, cache: "no-store" }); }
      catch (e3) { return { url, ok: false, status: -1, exists: false, error: String(e3) }; }
    }
    const exists = res.ok && res.status !== 404;
    return { url, ok: res.ok, status: res.status, exists, error: null };
  }

  const primary = primaryConfigUrl ? await check(primaryConfigUrl) : { url: primaryConfigUrl, ok: false, status: 0, exists: false };
  const fallback = await check(defaultConfigUrl);

  const appConfigUrl = join(activePrefix, "config.yaml");

  const cfg = p.domainAssetsConfig || null;
  const logos = summarizeLogos(cfg);
  const hasLocales    = !!(cfg && (cfg.locales || cfg.i18n));
  const hasTabs       = !!(cfg && (cfg.modules?.tabs || cfg.tabs || cfg.ui?.tabs));            // fixed
  const hasCategories = !!(cfg && (cfg.modules?.categories || cfg.categories || cfg.ui?.categories)); // fixed

  const fav = cfg?.favicon || null;
  const hasFavicon = !!(fav && (fav.base || fav["16"] || fav["32"] || fav["apple-touch-icon"] || fav.manifest || fav["mask-icon"]?.href));

  const sampleFiles = [];
  if (logos.has) {
    const key = logos.pickable[0];
    const rel = (typeof (cfg?.logos ?? cfg?.logo) === "string")
      ? (cfg?.logos ?? cfg?.logo)
      : (cfg?.logos?.[key] ?? cfg?.logo?.[key]);
    if (rel) sampleFiles.push({ kind: "logo", relPath: rel });
  }
  if (cfg?.locales?.length) {
    const fr = cfg.locales.find(x => x?.path || x?.dictionary) || cfg.locales[0];
    const rel = fr?.path || fr?.dictionary;
    if (rel) sampleFiles.push({ kind: "locale", relPath: rel });
  }
  if (cfg?.modules?.tabs || cfg?.tabs?.path) {
    const rel = cfg?.modules?.tabs || cfg?.tabs?.path;
    sampleFiles.push({ kind: "tabs", relPath: rel });
  }
  if (hasFavicon) {
    const favRel = fav["32"] || fav["16"] || fav.base || fav["apple-touch-icon"] || fav.manifest || fav["mask-icon"]?.href;
    if (favRel) sampleFiles.push({ kind: "favicon", relPath: favRel });
  }

  const resolvedSamples = await Promise.all(sampleFiles.map(async (sf) => {
    const url = join(activePrefix, sf.relPath);
    const r = await check(url);
    return { ...sf, url, exists: r.exists, status: r.status };
  }));

  return {
    env: p.env || "prod",
    domain,
    assetsBaseUrl: base,
    computedDomainPrefix,
    activePrefix,
    appSource: p.domainAssetsSource || null,
    appConfigUrl,                   // active pack’s config (may be /domain_default/)
    primaryConfig: { url: primary.url, exists: !!primary.exists, status: primary.status, error: primary.error },
    defaultConfig: { url: fallback.url, exists: !!fallback.exists, status: fallback.status },
    appParsedConfigPresence: {
      hasConfigObject: !!cfg,
      hasLogos: !!logos.has, logoFields: logos.fields,
      hasLocales, hasTabs, hasCategories, hasFavicon
    },
    resolvedSamples,
  };
}
</file>

<file path="src/utils/debug.js">
// src/utils/debug.js
const STORE_KEY = "savva_debug_enabled";

const state = {
  enabled: (() => { try { return localStorage.getItem(STORE_KEY) === "1"; } catch { return false; } })(),
};

function logWithScope(method, scope, args) {
  if (!state.enabled) return;
  const c = console[method] || console.log;
  c.call(console, `${scope}:`, ...args);
}

export const dbg = {
  enable(on = true) {
    state.enabled = !!on;
    try { localStorage.setItem(STORE_KEY, state.enabled ? "1" : "0"); } catch {}
    return state.enabled;
  },
  enabled: () => !!state.enabled,

  log(scope, ...args)  { logWithScope("log", scope, args); },
  info(scope, ...args) { logWithScope("info", scope, args); },
  warn(scope, ...args) { logWithScope("warn", scope, args); },
  error(scope, ...args){ logWithScope("error", scope, args); },

  group(label) {
    if (state.enabled && console.groupCollapsed) console.groupCollapsed(label);
  },
  groupEnd() {
    if (state.enabled && console.groupEnd) console.groupEnd();
  },
};

export default dbg;
</file>

<file path="src/utils/format.js">
// src/utils/format.js
export function formatBytes(bytes, decimals = 2) {
  if (!+bytes) return '0 Bytes';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
</file>

<file path="src/utils/net.js">
// src/utils/net.js
export async function fetchWithTimeout(
  url,
  { timeoutMs = 7000, method = "GET", headers, signal, body } = {}
) {
  const controller = new AbortController();
  const timer = setTimeout(
    () => controller.abort(new DOMException("Timeout", "TimeoutError")),
    timeoutMs
  );
  if (signal) {
    signal.addEventListener("abort", () => controller.abort(signal.reason), { once: true });
  }
  try {
    return await fetch(url, {
      method,
      headers,
      body,
      signal: controller.signal,
      // Change 'no-store' to 'force-cache' for aggressive caching of immutable assets.
      cache: "force-cache",
    });
  } finally {
    clearTimeout(timer);
  }
}
</file>

<file path="public/dev_docs/en/core-concepts/showing-posts.md">
# Showing Posts

Displaying a SAVVA post is a two-step process.

1. Fetch a list of post metadata objects from the SAVVA backend.
2. Use the IPFS information from that metadata to fetch the actual content (title, text, images, etc.) from the decentralized network.

---

## Step 1: Fetch Post Metadata from the Backend

The primary way to get a list of posts is through the **`content-list`** WebSocket method.
It supports pagination, sorting, and filtering.

### Calling `content-list`

You call the method with parameters specifying which content you need. Example:

```js
// Example call using the app's wsMethod helper
const posts = await app.wsMethod("content-list")({
  domain: "savva.app",      // Domain to fetch posts from
  limit: 12,                // Number of items per page
  offset: 0,                // Start index (for pagination)
  lang: "en",               // Preferred language for metadata
  order_by: "fund_amount",  // Sort by total funds received
  content_type: "post",     // We only want posts
  category: "en:SAVVA Talk" // Optional: filter by category
});
```

---

## The Post Object Structure

The `content-list` method returns an array of **post objects**.
Each contains metadata and pointers needed to fetch the full content.

Example:

```json
{
  "author": {
    "address": "0x1234...",
    "avatar": "Qm...",
    "name": "alexna",
    "display_name": "Alex Na",
    "staked": "5000000000000000000000"
  },
  "category": "en:SAVVA Talk",
  "domain": "savva.app",
  "effective_time": "2025-08-20T10:30:00Z",
  "fund": {
    "amount": "125000000000000000000",
    "round_time": 1672531200,
    "total_author_share": "100000000000000000000"
  },
  "ipfs": "bafybeig.../info.yaml",
  "reactions": [10, 2, 0, 1],
  "savva_cid": "0x01701...cfa2",
  "short_cid": "aBcDeF1",
  "tags": ["decentralization", "social"],
  "savva_content": {
    "data_cid": "bafybeig...",
    "locales": {
      "en": {
        "text_preview": "This is a short preview of the post content...",
        "title": "My First Post on SAVVA"
      },
      "ru": {
        "text_preview": "Это короткий анонс содержания поста...",
        "title": "Мой первый пост на SAVVA"
      }
    },
    "thumbnail": "thumbnail.jpg"
  }
}
```

### Key Fields Explained

* **author** — profile info of the author (including staked amount).
* **savva\_cid / short\_cid** — unique IDs. Use them to build URLs (`/post/<short_cid>`).
* **ipfs / savva\_content.data\_cid** — pointers to IPFS content.
* **savva\_content** — backend-cached metadata (titles, previews, thumbnails). Great for feed rendering without IPFS fetch.
* **fund** — post’s funding pool information.
* **reactions** — array of counts for each reaction type.

---

## Step 2: Resolve Full Content from IPFS

While `savva_content` is useful for previews, full content must be fetched from IPFS (post body, chapters, assets).

### Resolving Content Paths

The location of `info.yaml` depends on format:

* **Modern format**

  * `savva_content.data_cid` = base CID for assets.
  * `ipfs` = direct path to `info.yaml`.
* **Legacy format**

  * No `data_cid`.
  * `ipfs` = base CID. Descriptor assumed at `<ipfs>/info.yaml`.

### Utility Functions

Use helpers from `src/ipfs/utils.js`:

```js
import {
  getPostDescriptorPath,
  getPostContentBaseCid,
  resolvePostCidPath
} from "../../ipfs/utils.js";

const post = { ... };

// 1. Path to descriptor file
const descriptorPath = getPostDescriptorPath(post);

// 2. Base CID for assets
const contentBaseCid = getPostContentBaseCid(post);

// 3. Resolve relative path (e.g., thumbnail)
const fullThumbnailPath = resolvePostCidPath(post, post.savva_content.thumbnail);
```

---

## IPFS Gateway Prioritization

Fetch order:

1. **Local node** (if enabled).
2. **Post-specific gateways** (listed in descriptor).
3. **System gateways** (backend `/info`).

This ensures best speed and availability.

---

## The Post Descriptor (`info.yaml`)

A YAML file defining the full structure: languages, chapters, metadata.

### Example `info.yaml`

```yaml
thumbnail: assets/post_thumbnail.png
gateways:
  - https://my-fast-pinning-service.cloud

locales:
  en:
    title: "Understanding Decentralized Systems"
    text_preview: "A deep dive into the core concepts of decentralization..."
    tags: ["blockchain", "systems", "web3"]
    categories: ["Technology"]
    data_path: content/en/main.md
    chapters:
      - title: "What is a Blockchain?"
        data_path: content/en/chapter1.md
      - title: "IPFS and Content Addressing"
        data_path: content/en/chapter2.md
  
  ru:
    title: "Понимание децентрализованных систем"
    text_preview: "Глубокое погружение в основные концепции децентрализации..."
    tags: ["блокчейн", "системы", "web3"]
    categories: ["Технологии"]
    data_path: content/ru/main.md
    chapters:
      - title: "Что такое блокчейн?"
        data_path: content/ru/chapter1.md
      - title: "IPFS и контентная адресация"
        data_path: content/ru/chapter2.md
```

### Key Descriptor Fields

* **thumbnail** — relative path to main image.
* **gateways** — optional recommended IPFS gateways.
* **locales** — object keyed by language codes.

  * **title / text\_preview / tags / categories** — language-specific metadata.
  * **data\_path** — main Markdown content for that language.
  * **chapters** — array of chapters, each with `title` and `data_path`.

To fetch full chapter content:

```txt
<content_base_cid>/content/en/chapter1.md
```
</file>

<file path="public/dev_docs/en/index.md">
# SAVVA Developer Documentation

Welcome to the **SAVVA Platform** developer docs.


## What is SAVVA?

SAVVA is an **open-source platform** for building next-generation social networks.  
Unlike traditional platforms, SAVVA combines **blockchain** and **IPFS** to create a decentralized, trustable, and censorship-resistant foundation.

- **Blockchain-anchored posts**  
  Every piece of content is registered on-chain and signed with the author’s cryptographic key. This ensures authenticity and makes it possible to trust that the post truly comes from its stated author.

- **Decentralized storage with IPFS**  
  Content is stored in the InterPlanetary File System rather than in a single company’s database. This removes single points of failure and makes the system more resilient.

Together, blockchain and IPFS form a new kind of social network: one without centralized control, without a single company behind it, and without a pressure point that can be exploited.


## About This Documentation

This is **developer documentation**, not end-user help.  
SAVVA is open source, and we actively encourage developers to fork, extend, and adapt the codebase.  

Here you’ll find:

- The **core principles** behind the architecture.  
- How the **interfaces and APIs** are structured.  
- Best practices for extending and integrating the platform.

If you are a developer exploring SAVVA, this is the place to start. 🚀
</file>

<file path="public/dev_docs/fr/core-concepts/showing-posts.md">
# Affichage des Publications

Afficher un post SAVVA est un processus en deux étapes.

1. Récupérer une liste d'objets de métadonnées de post depuis le backend SAVVA.
2. Utiliser les informations IPFS de ces métadonnées pour récupérer le contenu réel (titre, texte, images, etc.) depuis le réseau décentralisé.

---

## Étape 1 : Récupérer les Métadonnées des Posts depuis le Backend

La principale façon d'obtenir une liste de posts est via la méthode WebSocket **`content-list`**. Elle prend en charge la pagination, le tri et le filtrage.

### Appel de `content-list`

Vous appelez la méthode avec des paramètres spécifiant quel contenu vous avez besoin. Exemple :

```js
// Exemple d'appel utilisant l'assistant wsMethod de l'application
const posts = await app.wsMethod("content-list")({
  domain: "savva.app",      // Domaine pour récupérer les posts
  limit: 12,                // Nombre d'éléments par page
  offset: 0,                // Index de départ (pour la pagination)
  lang: "en",               // Langue préférée pour les métadonnées
  order_by: "fund_amount",  // Trier par le montant total des fonds reçus
  content_type: "post",     // Nous voulons uniquement des posts
  category: "en:SAVVA Talk" // Optionnel : filtrer par catégorie
});
```

---

## La Structure de l'Objet Post

La méthode `content-list` retourne un tableau d'**objets de post**. Chacun contient des métadonnées et des pointeurs nécessaires pour récupérer le contenu complet.

Exemple :

```json
{
  "author": {
    "address": "0x1234...",
    "avatar": "Qm...",
    "name": "alexna",
    "display_name": "Alex Na",
    "staked": "5000000000000000000000"
  },
  "category": "en:SAVVA Talk",
  "domain": "savva.app",
  "effective_time": "2025-08-20T10:30:00Z",
  "fund": {
    "amount": "125000000000000000000",
    "round_time": 1672531200,
    "total_author_share": "100000000000000000000"
  },
  "ipfs": "bafybeig.../info.yaml",
  "reactions": [10, 2, 0, 1],
  "savva_cid": "0x01701...cfa2",
  "short_cid": "aBcDeF1",
  "tags": ["décentralisation", "social"],
  "savva_content": {
    "data_cid": "bafybeig...",
    "locales": {
      "en": {
        "text_preview": "Ceci est un court aperçu du contenu du post...",
        "title": "Mon Premier Post sur SAVVA"
      },
      "ru": {
        "text_preview": "Это короткий анонс содержания поста...",
        "title": "Мой первый пост на SAVVA"
      }
    },
    "thumbnail": "thumbnail.jpg"
  }
}
```

### Explication des Champs Clés

* **author** — informations de profil de l'auteur (y compris le montant misé).
* **savva\_cid / short\_cid** — identifiants uniques. Utilisez-les pour construire des URLs (`/post/<short_cid>`).
* **ipfs / savva\_content.data\_cid** — pointeurs vers le contenu IPFS.
* **savva\_content** — métadonnées mises en cache par le backend (titres, aperçus, vignettes). Idéal pour le rendu du fil sans récupération IPFS.
* **fund** — informations sur le pool de financement du post.
* **reactions** — tableau des comptes pour chaque type de réaction.

---

## Étape 2 : Résoudre le Contenu Complet depuis IPFS

Bien que `savva_content` soit utile pour les aperçus, le contenu complet doit être récupéré depuis IPFS (corps du post, chapitres, actifs).

### Résolution des Chemins de Contenu

L'emplacement de `info.yaml` dépend du format :

* **Format moderne**

  * `savva_content.data_cid` = CID de base pour les actifs.
  * `ipfs` = chemin direct vers `info.yaml`.
* **Format hérité**

  * Pas de `data_cid`.
  * `ipfs` = CID de base. Descripteur supposé à `<ipfs>/info.yaml`.

### Fonctions Utilitaires

Utilisez les helpers de `src/ipfs/utils.js` :

```js
import {
  getPostDescriptorPath,
  getPostContentBaseCid,
  resolvePostCidPath
} from "../../ipfs/utils.js";

const post = { ... };

// 1. Chemin vers le fichier descripteur
const descriptorPath = getPostDescriptorPath(post);

// 2. CID de base pour les actifs
const contentBaseCid = getPostContentBaseCid(post);

// 3. Résoudre le chemin relatif (par exemple, vignette)
const fullThumbnailPath = resolvePostCidPath(post, post.savva_content.thumbnail);
```

---

## Priorisation des Passerelles IPFS

Ordre de récupération :

1. **Nœud local** (si activé).
2. **Passerelles spécifiques au post** (listées dans le descripteur).
3. **Passerelles système** (backend `/info`).

Cela garantit la meilleure vitesse et disponibilité.

---

## Le Descripteur de Post (`info.yaml`)

Un fichier YAML définissant la structure complète : langues, chapitres, métadonnées.

### Exemple `info.yaml`

```yaml
thumbnail: assets/post_thumbnail.png
gateways:
  - https://my-fast-pinning-service.cloud

locales:
  en:
    title: "Comprendre les Systèmes Décentralisés"
    text_preview: "Une plongée approfondie dans les concepts fondamentaux de la décentralisation..."
    tags: ["blockchain", "systèmes", "web3"]
    categories: ["Technologie"]
    data_path: content/en/main.md
    chapters:
      - title: "Qu'est-ce qu'une Blockchain ?"
        data_path: content/en/chapter1.md
      - title: "IPFS et l'Adressage de Contenu"
        data_path: content/en/chapter2.md
  
  ru:
    title: "Понимание децентрализованных систем"
    text_preview: "Глубокое погружение в основные концепции децентрализации..."
    tags: ["блокчейн", "системы", "web3"]
    categories: ["Технологии"]
    data_path: content/ru/main.md
    chapters:
      - title: "Что такое блокчейн?"
        data_path: content/ru/chapter1.md
      - title: "IPFS и контентная адресация"
        data_path: content/ru/chapter2.md
```

### Champs Clés du Descripteur

* **thumbnail** — chemin relatif vers l'image principale.
* **gateways** — passerelles IPFS recommandées optionnelles.
* **locales** — objet indexé par les codes de langue.

  * **title / text\_preview / tags / categories** — métadonnées spécifiques à la langue.
  * **data\_path** — contenu principal en Markdown pour cette langue.
  * **chapters** — tableau de chapitres, chacun avec `title` et `data_path`.

Pour récupérer le contenu complet d'un chapitre :

```txt
<content_base_cid>/content/en/chapter1.md
```
</file>

<file path="public/dev_docs/ru/core-concepts/showing-posts.md">
# Отображение Постов

Отображение поста SAVVA — это двухэтапный процесс.

1. Получите список объектов метаданных постов из бэкенда SAVVA.
2. Используйте информацию IPFS из этих метаданных, чтобы получить фактическое содержание (заголовок, текст, изображения и т. д.) из децентрализованной сети.

---

## Шаг 1: Получение Метаданных Постов из Бэкенда

Основной способ получить список постов — это метод WebSocket **`content-list`**. Он поддерживает пагинацию, сортировку и фильтрацию.

### Вызов `content-list`

Вы вызываете метод с параметрами, указывающими, какой контент вам нужен. Пример:

```js
// Пример вызова с использованием помощника wsMethod приложения
const posts = await app.wsMethod("content-list")({
  domain: "savva.app",      // Домен для получения постов
  limit: 12,                // Количество элементов на странице
  offset: 0,                // Начальный индекс (для пагинации)
  lang: "en",               // Предпочитаемый язык для метаданных
  order_by: "fund_amount",  // Сортировка по общей сумме полученных средств
  content_type: "post",     // Нам нужны только посты
  category: "en:SAVVA Talk" // Необязательно: фильтрация по категории
});
```

---

## Структура Объекта Поста

Метод `content-list` возвращает массив **объектов постов**. Каждый из них содержит метаданные и указатели, необходимые для получения полного содержания.

Пример:

```json
{
  "author": {
    "address": "0x1234...",
    "avatar": "Qm...",
    "name": "alexna",
    "display_name": "Alex Na",
    "staked": "5000000000000000000000"
  },
  "category": "en:SAVVA Talk",
  "domain": "savva.app",
  "effective_time": "2025-08-20T10:30:00Z",
  "fund": {
    "amount": "125000000000000000000",
    "round_time": 1672531200,
    "total_author_share": "100000000000000000000"
  },
  "ipfs": "bafybeig.../info.yaml",
  "reactions": [10, 2, 0, 1],
  "savva_cid": "0x01701...cfa2",
  "short_cid": "aBcDeF1",
  "tags": ["децентрализация", "социальные"],
  "savva_content": {
    "data_cid": "bafybeig...",
    "locales": {
      "en": {
        "text_preview": "This is a short preview of the post content...",
        "title": "My First Post on SAVVA"
      },
      "ru": {
        "text_preview": "Это короткий анонс содержания поста...",
        "title": "Мой первый пост на SAVVA"
      }
    },
    "thumbnail": "thumbnail.jpg"
  }
}
```

### Объяснение Ключевых Полей

* **author** — информация о профиле автора (включая сумму стейка).
* **savva\_cid / short\_cid** — уникальные идентификаторы. Используйте их для построения URL (`/post/<short_cid>`).
* **ipfs / savva\_content.data\_cid** — указатели на контент IPFS.
* **savva\_content** — кэшированные метаданные бэкенда (заголовки, превью, миниатюры). Отлично подходит для рендеринга ленты без получения IPFS.
* **fund** — информация о фонде поста.
* **reactions** — массив счетчиков для каждого типа реакции.

---

## Шаг 2: Получение Полного Содержания из IPFS

Хотя `savva_content` полезен для превью, полное содержание должно быть получено из IPFS (тело поста, главы, активы).

### Разрешение Путей Содержания

Местоположение `info.yaml` зависит от формата:

* **Современный формат**

  * `savva_content.data_cid` = базовый CID для активов.
  * `ipfs` = прямой путь к `info.yaml`.
* **Устаревший формат**

  * Нет `data_cid`.
  * `ipfs` = базовый CID. Описание предполагается по адресу `<ipfs>/info.yaml`.

### Утилитные Функции

Используйте помощники из `src/ipfs/utils.js`:

```js
import {
  getPostDescriptorPath,
  getPostContentBaseCid,
  resolvePostCidPath
} from "../../ipfs/utils.js";

const post = { ... };

// 1. Путь к файлу описания
const descriptorPath = getPostDescriptorPath(post);

// 2. Базовый CID для активов
const contentBaseCid = getPostContentBaseCid(post);

// 3. Разрешение относительного пути (например, миниатюра)
const fullThumbnailPath = resolvePostCidPath(post, post.savva_content.thumbnail);
```

---

## Приоритизация Шлюзов IPFS

Порядок получения:

1. **Локальный узел** (если включен).
2. **Специфические шлюзы для постов** (указаны в описании).
3. **Системные шлюзы** (бэкенд `/info`).

Это обеспечивает наилучшую скорость и доступность.

---

## Описание Поста (`info.yaml`)

Файл YAML, определяющий полную структуру: языки, главы, метаданные.

### Пример `info.yaml`

```yaml
thumbnail: assets/post_thumbnail.png
gateways:
  - https://my-fast-pinning-service.cloud

locales:
  en:
    title: "Understanding Decentralized Systems"
    text_preview: "A deep dive into the core concepts of decentralization..."
    tags: ["blockchain", "systems", "web3"]
    categories: ["Technology"]
    data_path: content/en/main.md
    chapters:
      - title: "What is a Blockchain?"
        data_path: content/en/chapter1.md
      - title: "IPFS and Content Addressing"
        data_path: content/en/chapter2.md
  
  ru:
    title: "Понимание децентрализованных систем"
    text_preview: "Глубокое погружение в основные концепции децентрализации..."
    tags: ["блокчейн", "системы", "web3"]
    categories: ["Технологии"]
    data_path: content/ru/main.md
    chapters:
      - title: "Что такое блокчейн?"
        data_path: content/ru/chapter1.md
      - title: "IPFS и контентная адресация"
        data_path: content/ru/chapter2.md
```

### Ключевые Поля Описания

* **thumbnail** — относительный путь к главному изображению.
* **gateways** — необязательные рекомендуемые шлюзы IPFS.
* **locales** — объект, ключи которого — языковые коды.

  * **title / text\_preview / tags / categories** — метаданные, специфичные для языка.
  * **data\_path** — основной Markdown контент для этого языка.
  * **chapters** — массив глав, каждая с `title` и `data_path`.

Чтобы получить полное содержание главы:

```txt
<content_base_cid>/content/en/chapter1.md
```
</file>

<file path="public/dev_docs/sr/core-concepts/showing-posts.md">
# Prikaz Postova

Prikaz SAVVA posta je proces u dva koraka.

1. Preuzmite listu objekata metapodataka postova sa SAVVA backend-a.
2. Iskoristite IPFS informacije iz tih metapodataka da preuzmete stvarni sadržaj (naslov, tekst, slike, itd.) sa decentralizovane mreže.

---

## Korak 1: Preuzimanje Metapodataka Postova sa Backend-a

Primarni način za dobijanje liste postova je putem **`content-list`** WebSocket metode. 
Podržava paginaciju, sortiranje i filtriranje.

### Pozivanje `content-list`

Pozivate metodu sa parametrima koji specificiraju koji sadržaj vam je potreban. Primer:

```js
// Primer poziva koristeći wsMethod pomoćnika aplikacije
const posts = await app.wsMethod("content-list")({
  domain: "savva.app",      // Domen sa kojeg se preuzimaju postovi
  limit: 12,                // Broj stavki po stranici
  offset: 0,                // Početni indeks (za paginaciju)
  lang: "en",               // Preferirani jezik za metapodatke
  order_by: "fund_amount",  // Sortiraj po ukupnim primljenim sredstvima
  content_type: "post",     // Želimo samo postove
  category: "en:SAVVA Talk" // Opcionalno: filtriraj po kategoriji
});
```

---

## Struktura Objekta Posta

Metoda `content-list` vraća niz **objekata postova**. 
Svaki sadrži metapodatke i pokazivače potrebne za preuzimanje celokupnog sadržaja.

Primer:

```json
{
  "author": {
    "address": "0x1234...",
    "avatar": "Qm...",
    "name": "alexna",
    "display_name": "Alex Na",
    "staked": "5000000000000000000000"
  },
  "category": "en:SAVVA Talk",
  "domain": "savva.app",
  "effective_time": "2025-08-20T10:30:00Z",
  "fund": {
    "amount": "125000000000000000000",
    "round_time": 1672531200,
    "total_author_share": "100000000000000000000"
  },
  "ipfs": "bafybeig.../info.yaml",
  "reactions": [10, 2, 0, 1],
  "savva_cid": "0x01701...cfa2",
  "short_cid": "aBcDeF1",
  "tags": ["decentralization", "social"],
  "savva_content": {
    "data_cid": "bafybeig...",
    "locales": {
      "en": {
        "text_preview": "This is a short preview of the post content...",
        "title": "My First Post on SAVVA"
      },
      "ru": {
        "text_preview": "Это короткий анонс содержания поста...",
        "title": "Мой первый пост на SAVVA"
      }
    },
    "thumbnail": "thumbnail.jpg"
  }
}
```

### Objašnjenje Ključnih Polja

* **author** — profil informacije autora (uključujući iznos koji je uložio).
* **savva\_cid / short\_cid** — jedinstveni ID-ovi. Koristite ih za izgradnju URL-ova (`/post/<short_cid>`).
* **ipfs / savva\_content.data\_cid** — pokazivači na IPFS sadržaj.
* **savva\_content** — metapodaci keširani na backend-u (naslovi, pregledi, sličice). Odlično za prikazivanje feed-a bez preuzimanja sa IPFS-a.
* **fund** — informacije o fondu postova.
* **reactions** — niz brojeva za svaki tip reakcije.

---

## Korak 2: Rešavanje Celokupnog Sadržaja sa IPFS-a

Dok je `savva_content` koristan za preglede, celokupan sadržaj mora biti preuzet sa IPFS-a (telo posta, poglavlja, resursi).

### Rešavanje Putanja Sadržaja

Lokacija `info.yaml` zavisi od formata:

* **Savremeni format**

  * `savva_content.data_cid` = osnovni CID za resurse.
  * `ipfs` = direktna putanja do `info.yaml`.
* **Legacijski format**

  * Nema `data_cid`.
  * `ipfs` = osnovni CID. Pretpostavlja se da je deskriptor na `<ipfs>/info.yaml`.

### Funkcije Pomoći

Koristite pomoćnike iz `src/ipfs/utils.js`:

```js
import {
  getPostDescriptorPath,
  getPostContentBaseCid,
  resolvePostCidPath
} from "../../ipfs/utils.js";

const post = { ... };

// 1. Putanja do deskriptorskog fajla
const descriptorPath = getPostDescriptorPath(post);

// 2. Osnovni CID za resurse
const contentBaseCid = getPostContentBaseCid(post);

// 3. Rešavanje relativne putanje (npr., sličica)
const fullThumbnailPath = resolvePostCidPath(post, post.savva_content.thumbnail);
```

---

## Prioritet IPFS Gateway-a

Redosled preuzimanja:

1. **Lokalni čvor** (ako je omogućen).
2. **Specifični gateway-evi za postove** (navedeni u deskriptoru).
3. **Sistemski gateway-evi** (backend `/info`).

Ovo osigurava najbolju brzinu i dostupnost.

---

## Deskriptor Posta (`info.yaml`)

YAML fajl koji definiše celokupnu strukturu: jezici, poglavlja, metapodaci.

### Primer `info.yaml`

```yaml
thumbnail: assets/post_thumbnail.png
gateways:
  - https://my-fast-pinning-service.cloud

locales:
  en:
    title: "Razumevanje Decentralizovanih Sistema"
    text_preview: "Dubinsko istraživanje osnovnih koncepata decentralizacije..."
    tags: ["blockchain", "systems", "web3"]
    categories: ["Tehnologija"]
    data_path: content/en/main.md
    chapters:
      - title: "Šta je Blockchain?"
        data_path: content/en/chapter1.md
      - title: "IPFS i Adresiranje Sadržaja"
        data_path: content/en/chapter2.md
  
  ru:
    title: "Понимание децентрализованных систем"
    text_preview: "Глубокое погружение в основные концепции децентрализации..."
    tags: ["блокчейн", "системы", "web3"]
    categories: ["Технологии"]
    data_path: content/ru/main.md
    chapters:
      - title: "Что такое блокчейн?"
        data_path: content/ru/chapter1.md
      - title: "IPFS и контентная адресация"
        data_path: content/ru/chapter2.md
```

### Ključna Polja Deskriptora

* **thumbnail** — relativna putanja do glavne slike.
* **gateways** — opcioni preporučeni IPFS gateway-evi.
* **locales** — objekat sa ključevima prema kodovima jezika.

  * **title / text\_preview / tags / categories** — metapodaci specifični za jezik.
  * **data\_path** — glavni Markdown sadržaj za taj jezik.
  * **chapters** — niz poglavlja, svako sa `title` i `data_path`.

Da preuzmete celokupan sadržaj poglavlja:

```txt
<content_base_cid>/content/en/chapter1.md
```
</file>

<file path="public/dev_docs/ua/core-concepts/showing-posts.md">
# Показ Постів

Відображення поста SAVVA є двоетапним процесом.

1. Отримати список об'єктів метаданих постів з бекенду SAVVA.
2. Використати інформацію IPFS з цих метаданих для отримання фактичного контенту (назва, текст, зображення тощо) з децентралізованої мережі.

---

## Крок 1: Отримання Метаданих Постів з Бекенду

Основний спосіб отримати список постів - це метод WebSocket **`content-list`**.
Він підтримує пагінацію, сортування та фільтрацію.

### Виклик `content-list`

Ви викликаєте метод з параметрами, що вказують, який контент вам потрібен. Приклад:

```js
// Приклад виклику з використанням допоміжного методу wsMethod програми
const posts = await app.wsMethod("content-list")({
  domain: "savva.app",      // Домен для отримання постів
  limit: 12,                // Кількість елементів на сторінці
  offset: 0,                // Початковий індекс (для пагінації)
  lang: "en",               // Бажана мова для метаданих
  order_by: "fund_amount",  // Сортувати за загальною сумою отриманих коштів
  content_type: "post",     // Ми хочемо лише пости
  category: "en:SAVVA Talk" // Необов'язково: фільтрувати за категорією
});
```

---

## Структура Об'єкта Поста

Метод `content-list` повертає масив **об'єктів постів**.
Кожен містить метадані та вказівники, необхідні для отримання повного контенту.

Приклад:

```json
{
  "author": {
    "address": "0x1234...",
    "avatar": "Qm...",
    "name": "alexna",
    "display_name": "Alex Na",
    "staked": "5000000000000000000000"
  },
  "category": "en:SAVVA Talk",
  "domain": "savva.app",
  "effective_time": "2025-08-20T10:30:00Z",
  "fund": {
    "amount": "125000000000000000000",
    "round_time": 1672531200,
    "total_author_share": "100000000000000000000"
  },
  "ipfs": "bafybeig.../info.yaml",
  "reactions": [10, 2, 0, 1],
  "savva_cid": "0x01701...cfa2",
  "short_cid": "aBcDeF1",
  "tags": ["децентралізація", "соціальні"],
  "savva_content": {
    "data_cid": "bafybeig...",
    "locales": {
      "en": {
        "text_preview": "Це короткий анонс змісту поста...",
        "title": "Мій перший пост на SAVVA"
      },
      "ru": {
        "text_preview": "Это короткий анонс содержания поста...",
        "title": "Мой первый пост на SAVVA"
      }
    },
    "thumbnail": "thumbnail.jpg"
  }
}
```

### Пояснення Ключових Полів

* **author** — інформація профілю автора (включаючи суму, що була вкладена).
* **savva\_cid / short\_cid** — унікальні ідентифікатори. Використовуйте їх для побудови URL (`/post/<short_cid>`).
* **ipfs / savva\_content.data\_cid** — вказівники на контент IPFS.
* **savva\_content** — метадані, кешовані на бекенді (назви, анонси, ескізи). Чудово підходять для рендерингу стрічки без отримання з IPFS.
* **fund** — інформація про фонд поста.
* **reactions** — масив кількостей для кожного типу реакції.

---

## Крок 2: Отримання Повного Контенту з IPFS

Хоча `savva_content` корисний для попереднього перегляду, повний контент потрібно отримати з IPFS (тіло поста, глави, активи).

### Вирішення Шляхів Контенту

Розташування `info.yaml` залежить від формату:

* **Сучасний формат**

  * `savva_content.data_cid` = базовий CID для активів.
  * `ipfs` = прямий шлях до `info.yaml`.
* **Спадковий формат**

  * Немає `data_cid`.
  * `ipfs` = базовий CID. Описувач вважається на `<ipfs>/info.yaml`.

### Утиліти

Використовуйте допоміжні функції з `src/ipfs/utils.js`:

```js
import {
  getPostDescriptorPath,
  getPostContentBaseCid,
  resolvePostCidPath
} from "../../ipfs/utils.js";

const post = { ... };

// 1. Шлях до файлу описувача
const descriptorPath = getPostDescriptorPath(post);

// 2. Базовий CID для активів
const contentBaseCid = getPostContentBaseCid(post);

// 3. Вирішити відносний шлях (наприклад, ескіз)
const fullThumbnailPath = resolvePostCidPath(post, post.savva_content.thumbnail);
```

---

## Пріоритетність Шлюзів IPFS

Порядок отримання:

1. **Локальний вузол** (якщо увімкнено).
2. **Специфічні шлюзи постів** (перераховані в описувачі).
3. **Системні шлюзи** (бекенд `/info`).

Це забезпечує найкращу швидкість і доступність.

---

## Опис Поста (`info.yaml`)

Файл YAML, що визначає повну структуру: мови, глави, метадані.

### Приклад `info.yaml`

```yaml
thumbnail: assets/post_thumbnail.png
gateways:
  - https://my-fast-pinning-service.cloud

locales:
  en:
    title: "Розуміння децентралізованих систем"
    text_preview: "Глибоке занурення в основні концепції децентралізації..."
    tags: ["блокчейн", "системи", "web3"]
    categories: ["Технології"]
    data_path: content/en/main.md
    chapters:
      - title: "Що таке блокчейн?"
        data_path: content/en/chapter1.md
      - title: "IPFS та адресація контенту"
        data_path: content/en/chapter2.md
  
  ru:
    title: "Понимание децентрализованных систем"
    text_preview: "Глубокое погружение в основные концепции децентрализации..."
    tags: ["блокчейн", "системы", "web3"]
    categories: ["Технологии"]
    data_path: content/ru/main.md
    chapters:
      - title: "Что такое блокчейн?"
        data_path: content/ru/chapter1.md
      - title: "IPFS и контентная адресация"
        data_path: content/ru/chapter2.md
```

### Ключові Поля Описувача

* **thumbnail** — відносний шлях до основного зображення.
* **gateways** — необов'язкові рекомендовані шлюзи IPFS.
* **locales** — об'єкт, ключований кодами мов.

  * **title / text\_preview / tags / categories** — метадані, специфічні для мови.
  * **data\_path** — основний Markdown контент для цієї мови.
  * **chapters** — масив глав, кожна з яких має `title` та `data_path`.

Щоб отримати повний контент глави:

```txt
<content_base_cid>/content/en/chapter1.md
```
</file>

<file path="public/default_connect.yaml">
domain: savva.app
backendLink: https://ui.savva.app/api/
gear: true
</file>

<file path="scripts/release.mjs">
// scripts/release.mjs
import fs from "node:fs";
import path from "node:path";
import { execSync } from "node:child_process";
import dotenv from "dotenv";

const ROOT = process.cwd();
dotenv.config({ path: path.join(ROOT, ".env") });

const VERSION_FILE = path.join(ROOT, "src", "version.js");
const MAIN_BRANCH = process.env.GIT_MAIN_BRANCH || "main";
const PROD_BRANCH = process.env.PROD_BRANCH || "Prod";

const DEPLOY_HOST = process.env.DEPLOY_HOST || "";
const DEPLOY_USER = process.env.DEPLOY_USER || "";
const DEPLOY_PATH = process.env.DEPLOY_PATH || "";
const DEPLOY_PORT = process.env.DEPLOY_PORT || "";
const DEPLOY_SSH_KEY = process.env.DEPLOY_SSH_KEY || "";

function sh(cmd, opts = {}) {
  console.log(`$ ${cmd}`);
  return execSync(cmd, { stdio: "inherit", ...opts });
}

function readVersion() {
  const text = fs.readFileSync(VERSION_FILE, "utf8");
  const m = text.match(/APP_VERSION\s*=\s*["'`](\d+)\.(\d+)["'`]/);
  if (!m) throw new Error("Could not parse APP_VERSION in src/version.js");
  return { major: Number(m[1]), minor: Number(m[2]), text };
}

function writeVersion(major, minor, prevText) {
  const next = `${major}.${minor}`;
  const out = prevText.replace(/APP_VERSION\s*=\s*["'`](\d+\.\d+)["'`]/, `APP_VERSION = "${next}"`);
  fs.writeFileSync(VERSION_FILE, out, "utf8");
  return next;
}

function runI18nScripts() {
  console.log("Running i18n scripts...");
  sh("node scripts/i18n.mjs");
  sh("node scripts/i18n-docs.mjs");
}

function build() {
  sh("npm run build");
}

function gitCommitAndPush(version) {
  try { sh("git add -A"); } catch {}
  try { sh(`git commit -m "release: v${version}"`); }
  catch { console.warn("No changes to commit."); }
  // Push current branch
  try { sh("git rev-parse --abbrev-ref HEAD"); } catch {}
  try { sh("git push"); } catch {}
  // Also push HEAD to Prod branch (without switching)
  try { sh(`git push origin HEAD:${PROD_BRANCH}`); } catch {}
}

function deploy() {
  if (!DEPLOY_HOST || !DEPLOY_USER || !DEPLOY_PATH) {
    console.error("Missing DEPLOY_HOST / DEPLOY_USER / DEPLOY_PATH in .env — skipping SCP.");
    return;
  }
  const keyOpt = DEPLOY_SSH_KEY ? `-i "${DEPLOY_SSH_KEY}"` : "";
  const portOpt = DEPLOY_PORT ? `-P ${DEPLOY_PORT}` : "";

  // Ensure path exists, then scp
  sh(`ssh ${keyOpt} ${portOpt} ${DEPLOY_USER}@${DEPLOY_HOST} "mkdir -p '${DEPLOY_PATH}'"`);
  sh(`scp ${keyOpt} ${portOpt} -r dist/* ${DEPLOY_USER}@${DEPLOY_HOST}:"${DEPLOY_PATH}/"`);
}

(async function main() {
  const { major, minor, text } = readVersion();
  const nextVersion = writeVersion(major, minor + 1, text);
  console.log(`Bumped version to ${nextVersion}`);

  runI18nScripts();
  build();
  gitCommitAndPush(nextVersion);
  deploy();

  console.log(`Done. Released v${nextVersion}.`);
})().catch((err) => {
  console.error(err);
  process.exit(1);
});
</file>

<file path="src/blockchain/contracts.js">
// src/blockchain/contracts.js
import { createPublicClient, http, getContract } from "viem";
import { CHAINS } from "./chains.js";

// A cache to hold instantiated viem clients per chainId.
const clientCache = new Map();

/**
 * Gets a memoized viem public client for a given chain ID.
 * @param {number} chainId - The ID of the chain.
 * @returns {import("viem").PublicClient} A viem public client instance.
 */
function getPublicClient(chainId) {
  if (clientCache.has(chainId)) {
    return clientCache.get(chainId);
  }

  const chainInfo = CHAINS[chainId];
  if (!chainInfo || !chainInfo.rpcUrls?.[0]) {
    throw new Error(`Configuration for chainId ${chainId} not found.`);
  }

  const client = createPublicClient({
    chain: chainInfo,
    transport: http(chainInfo.rpcUrls[0]),
  });

  clientCache.set(chainId, client);
  return client;
}

/**
 * Dynamically loads an ABI and creates a viem contract instance.
 * @param {object} app - The application context from useApp().
 * @param {string} contractName - The name of the contract (e.g., "Post", "Config").
 * @param {object} [options] - Optional settings.
 * @param {boolean} [options.write=false] - If true, gets a write-enabled instance using the wallet client.
 * @returns {Promise<import("viem").Contract>} A promise that resolves to a viem contract instance.
 */
export async function getSavvaContract(app, contractName, options = {}) {
  const info = app.info();
  if (!info) {
    throw new Error("Backend /info not loaded yet.");
  }
  
  const chainId = info.blockchain_id;
  if (!chainId) {
    throw new Error("blockchain_id not found in /info response.");
  }

  const contractInfo = info.savva_contracts?.[contractName];
  if (!contractInfo?.address) {
    throw new Error(`Address for contract "${contractName}" not found in /info response.`);
  }

  const abiModule = await import(`./abi/${contractName}.json`);
  const abi = abiModule.default;

  let client;
  if (options.write) {
    client = await app.getGuardedWalletClient();
  } else {
    client = getPublicClient(chainId);
  }

  return getContract({
    address: contractInfo.address,
    abi,
    client,
  });
}
</file>

<file path="src/blockchain/utils.js">
// src/blockchain/utils.js
import { stringToBytes, bytesToHex, getAddress, formatUnits } from "viem";

/**
 * Converts a JavaScript string into a hex-formatted bytes32 string.
 * The string is padded with null characters to 32 bytes.
 * @param {string} str The string to convert.
 * @returns {`0x${string}`} The hex-formatted bytes32 string.
 */
export function toHexBytes32(str) {
  const bytes = stringToBytes(str, { size: 32 });
  return bytesToHex(bytes);
}

/**
 * Converts an Ethereum address to its EIP-55 checksummed format.
 * Throws an error if the address is invalid.
 * @param {string} address The address to convert.
 * @returns {`0x${string}`} The checksummed address.
 */
export function toChecksumAddress(address) {
  if (!address) return address;
  return getAddress(address);
}

/**
 * Formats a large number (in wei) into a compact, human-readable string (e.g., 900, 1.8K, 2.25M).
 * @param {string | number | bigint} weiValue The value in wei.
 * @returns {string} The formatted string.
 */
export function formatRewardAmount(weiValue) {
  try {
    const numberValue = parseFloat(formatUnits(BigInt(weiValue || 0), 18));
    if (isNaN(numberValue)) return "0";

    return new Intl.NumberFormat('en-US', {
      notation: 'compact',
      maximumFractionDigits: 2
    }).format(numberValue);
  } catch {
    return "0";
  }
}
</file>

<file path="src/components/docs/DocsPager.jsx">
// src/components/docs/DocsPager.jsx
import { createMemo, createResource, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

async function fetchSidebar(lang) {
  const res = await fetch(`/dev_docs/${lang}/sidebar.yaml`, { cache: "no-store" });
  if (!res.ok) return { sections: [] };
  const text = await res.text();
  try {
    const y = (await import("js-yaml")).default.load(text) || {};
    if (Array.isArray(y.sections)) return { sections: y.sections };
    if (Array.isArray(y.items)) return { sections: [{ title: "Docs", items: y.items }] };
    if (Array.isArray(y)) return { sections: [{ title: "Docs", items: y }] };
  } catch {}
  return { sections: [] };
}

export default function DocsPager(props) {
  const app = useApp();
  const lang = createMemo(() => (app.lang?.() || "en").toLowerCase());
  const [data] = createResource(lang, fetchSidebar);

  const flat = createMemo(() => {
    const sections = data()?.sections || [];
    const items = [];
    sections.forEach((s) => (s.items || []).forEach((it) => {
      const label = it.label || it.title || it.file || "";
      const file  = it.file || it.path  || "";
      if (file) items.push({ label, file, section: s.title || "" });
    }));
    return items;
  });

  const nav = createMemo(() => {
    const list = flat();
    const idx = list.findIndex((x) => String(x.file) === String(props.activeRelPath || ""));
    if (idx < 0) return { prev: null, next: null };
    return { prev: list[idx - 1] || null, next: list[idx + 1] || null };
  });

  const go = (file) => props.onPick?.(file);

  return (
    <Show when={!data.loading && (nav().prev || nav().next)}>
      <nav class="mt-8 pt-4 border-t border-[hsl(var(--border))] flex items-stretch justify-between gap-3 text-sm">
        {/* Prev (left) */}
        <div class="min-w-0 flex-1">
          <Show when={nav().prev}>
            {(p) => (
              <button
                type="button"
                class="w-full rounded-md px-3 py-2 bg-[hsl(var(--muted))] hover:bg-[hsl(var(--accent))] text-left"
                onClick={() => go(p().file)}
                aria-label={app.t("docs.prev")}
                title={p().label}
              >
                <div class="flex items-start gap-2">
                  <span aria-hidden="true">←</span>
                  <div class="min-w-0">
                    <div class="font-medium whitespace-normal break-words leading-snug">
                      {p().label}
                    </div>
                    <div class="opacity-70 text-xs whitespace-normal break-words leading-snug">
                      {p().section}
                    </div>
                  </div>
                </div>
              </button>
            )}
          </Show>
        </div>

        {/* Next (right) */}
        <div class="min-w-0 flex-1 text-right">
          <Show when={nav().next}>
            {(n) => (
              <button
                type="button"
                class="w-full rounded-md px-3 py-2 bg-[hsl(var(--muted))] hover:bg-[hsl(var(--accent))]"
                onClick={() => go(n().file)}
                aria-label={app.t("docs.next")}
                title={n().label}
              >
                <div class="flex items-start gap-2 justify-end">
                  <div class="min-w-0">
                    <div class="font-medium whitespace-normal break-words leading-snug text-right">
                      {n().label}
                    </div>
                    <div class="opacity-70 text-xs whitespace-normal break-words leading-snug text-right">
                      {n().section}
                    </div>
                  </div>
                  <span aria-hidden="true">→</span>
                </div>
              </button>
            )}
          </Show>
        </div>
      </nav>
    </Show>
  );
}
</file>

<file path="src/components/editor/wizard_steps/StepValidate.jsx">
// src/components/editor/wizard_steps/StepValidate.jsx
import { createSignal, onMount, Show } from "solid-js";
import { useApp } from "../../../context/AppContext.jsx";
import Spinner from "../../ui/Spinner.jsx";

export default function StepValidate(props) {
  const { t } = useApp();
  const [error, setError] = createSignal(null);
  const [isValidating, setIsValidating] = createSignal(true);

  const validate = () => {
    const { postData, editorMode } = props;
    const data = postData();
    if (!data) {
      throw new Error("Post data is missing or not a function.");
    }

    const isComment = editorMode === 'new_comment' || editorMode === 'edit_comment';

    for (const langCode in data) {
      const langData = data[langCode];
      
      const hasTitle = langData.title?.trim().length > 0;
      const hasBody = langData.body?.trim().length > 0;
      const hasChapters = langData.chapters?.some(c => c.body?.trim().length > 0);
      
      const hasAnyMeaningfulContent = hasTitle || hasBody || hasChapters;
      
      let isComplete;
      if (isComment) {
        // For comments, only a body is required. A title is not.
        isComplete = hasBody;
      } else {
        // For posts, a title and either a body or chapters are required.
        isComplete = hasTitle && (hasBody || hasChapters);
      }

      if (hasAnyMeaningfulContent && !isComplete) {
        throw new Error(t("editor.publish.validation.errorIncomplete", { lang: langCode }));
      }
    }
  };

  onMount(() => {
    setTimeout(() => {
      try {
        validate();
        props.onComplete?.();
      } catch (e) {
        setError(e.message);
      } finally {
        setIsValidating(false);
      }
    }, 500);
  });

  return (
    <div class="flex flex-col items-center justify-center h-full">
      <Show when={isValidating()}>
        <Spinner />
        <p class="mt-2 text-sm">{t("common.checking")}...</p>
      </Show>
      <Show when={error()}>
        <div class="text-center p-4">
          <h4 class="font-bold text-red-600">{t("editor.publish.validation.errorTitle")}</h4>
          <p class="mt-2 text-sm">{error()}</p>
          <button onClick={props.onCancel} class="mt-4 px-4 py-2 rounded border border-[hsl(var(--input))] hover:bg-[hsl(var(--accent))]">
            {t("editor.publish.validation.backToEditor")}
          </button>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/EditorFilesButton.jsx">
// src/components/editor/EditorFilesButton.jsx
import { useApp } from "../../context/AppContext.jsx";

function FilesIcon(props) {
  return (
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class={props.class || "w-5 h-5"}>
      <path d="M9 6H9.33687C9.58146 6 9.70385 6 9.81893 6.02763C9.92097 6.05213 10.0189 6.09263 10.1084 6.14746C10.2093 6.20928 10.2959 6.29591 10.4688 6.46875L13.5315 9.53149C13.7044 9.70444 13.7904 9.79044 13.8523 9.89135C13.9071 9.98082 13.9482 10.0786 13.9727 10.1807C14 10.2946 14 10.4155 14 10.6552V18M9 6H4.59961C4.03956 6 3.75981 6 3.5459 6.10899C3.35774 6.20487 3.20487 6.35774 3.10899 6.5459C3 6.75981 3 7.04004 3 7.6001V19.4001C3 19.9601 3 20.2398 3.10899 20.4537C3.20487 20.6419 3.35774 20.7952 3.5459 20.8911C3.7596 21 4.03902 21 4.598 21L12.4011 21C12.96 21 13.2405 21 13.4542 20.8911C13.6423 20.7952 13.7948 20.6421 13.8906 20.4539C13.9996 20.24 14 19.9599 14 19.3999V18M9 6V9.4C9 9.96005 9 10.2399 9.10899 10.4538C9.20487 10.642 9.35774 10.7952 9.5459 10.8911C9.7596 11 10.039 11 10.598 11H13.9996M10 6.0001V4.6001C10 4.04005 10 3.75981 10.109 3.5459C10.2049 3.35774 10.3577 3.20487 10.5459 3.10899C10.7598 3 11.0396 3 11.5996 3H16M16 3H16.3369C16.5815 3 16.7038 3 16.8189 3.02763C16.921 3.05213 17.0189 3.09263 17.1084 3.14746C17.2093 3.20928 17.2959 3.29592 17.4688 3.46875L20.5315 6.53149C20.7044 6.70444 20.7904 6.79044 20.8523 6.89135C20.9071 6.98082 20.9482 7.07863 20.9727 7.18066C21 7.29458 21 7.41552 21 7.65515V16.3999C21 16.9599 20.9996 17.24 20.8906 17.4539C20.7948 17.6421 20.6429 17.7952 20.4548 17.8911C20.2411 18 19.961 18 19.402 18H14M16 3V6.4C16 6.96005 16 7.23988 16.109 7.4538C16.2049 7.64196 16.3577 7.79524 16.5459 7.89111C16.7596 8 17.039 8 17.598 8H20.9996" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
    </svg>
  );
}

export default function EditorFilesButton(props) {
  const { t } = useApp();
  return (
    <button
      onClick={props.onClick}
      class="flex items-center gap-2 pl-3 pr-4 py-1.5 rounded-l-full text-[hsl(var(--card))] font-semibold text-sm shadow-lg cursor-pointer"
      style={{ background: "var(--gradient)" }}
    >
      <FilesIcon class="w-5 h-5" />
      <span>{t("editor.toolbar.files")}</span>
    </button>
  );
}
</file>

<file path="src/components/editor/ToolbarIcons.jsx">
// src/components/editor/ToolbarIcons.jsx

// A generic wrapper for toolbar buttons
export function ToolbarButton(props) {
  return (
    <button
      type="button"
      onClick={props.onClick}
      title={props.title}
      class="p-2 rounded-md hover:bg-[hsl(var(--accent))]"
      aria-label={props.title}
    >
      {props.children}
    </button>
  );
}

// --- SVG Icons ---

export function BoldIcon() {
  return (
    <svg viewBox="0 0 24 24" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>
      <path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>
    </svg>
  );
}

export function ItalicIcon() {
  return (
    <svg viewBox="0 0 24 24" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="19" y1="4" x2="10" y2="4"></line>
      <line x1="14" y1="20" x2="5" y2="20"></line>
      <line x1="15" y1="4" x2="9" y2="20"></line>
    </svg>
  );
}

export function LinkIcon() {
  return (
    <svg viewBox="0 0 24 24" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
      <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
    </svg>
  );
}

export function ImageIcon() {
  return (
    <svg viewBox="0 0 24 24" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
      <circle cx="8.5" cy="8.5" r="1.5"></circle>
      <polyline points="21 15 16 10 5 21"></polyline>
    </svg>
  );
}

export function MaximizeIcon() {
  return (
    <svg viewBox="0 0 24 24" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
    </svg>
  );
}

export function MinimizeIcon() {
  return (
    <svg viewBox="0 0 24 24" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" />
    </svg>
  );
}
</file>

<file path="src/components/layout/RightRail.jsx">
// src/components/layout/RightRail.jsx
import { For, Switch, Match } from "solid-js";
import HtmlBlock from "../widgets/HtmlBlock.jsx";
import ContentListBlock from "../widgets/ContentListBlock.jsx";

export default function RightRail(props) {
  const blocks = () => props.config?.blocks || [];

  return (
    <For each={blocks()}>
      {(block) => (
        <Switch>
          <Match when={block.type === 'html'}>
            <HtmlBlock block={block} />
          </Match>
          <Match when={block.type === 'content_List'}>
            <ContentListBlock block={block} />
          </Match>
        </Switch>
      )}
    </For>
  );
}
</file>

<file path="src/components/main/TokenPrice.jsx">
// src/components/main/TokenPrice.jsx
import { createSignal, createEffect, on, Show } from "solid-js";
import { useApp } from "../../context/AppContext";
import SavvaTokenIcon from "../ui/icons/SavvaTokenIcon";

function UpArrow() {
  return (
    <svg viewBox="0 0 24 24" class="w-3 h-3" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 19V5M5 12l7-7 7 7" />
    </svg>
  );
}

function DownArrow() {
  return (
    <svg viewBox="0 0 24 24" class="w-3 h-3" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 5v14M19 12l-7 7-7-7" />
    </svg>
  );
}

export default function TokenPrice() {
  const app = useApp();
  const [isAnimating, setIsAnimating] = createSignal(false);
  const sourceData = () => app.savvaTokenPrice();
  
  // This signal holds the price data that is currently visible on screen.
  const [displayData, setDisplayData] = createSignal(sourceData());

  // Effect to handle the animation logic.
  createEffect(on(sourceData, (newValue, prevValue) => {
    // Don't animate on initial render
    if (prevValue === undefined || prevValue === null) {
      setDisplayData(newValue);
      return;
    }

    // 1. Start the animation, showing the OLD value first.
    setDisplayData(prevValue);
    setIsAnimating(true);

    // 2. Halfway through the 400ms animation, swap to the NEW value.
    setTimeout(() => {
      setDisplayData(newValue);
    }, 200);

    // 3. After the animation is complete, remove the animation class.
    setTimeout(() => {
      setIsAnimating(false);
    }, 400);

  }, { defer: true }));

  const formatPrice = (price) => {
    if (typeof price !== 'number') return '$0.0000';
    return `$${price.toFixed(4)}`;
  };

  const formatGain = (gain) => {
    if (typeof gain !== 'number') return '0.00%';
    return `${gain.toFixed(2)}%`;
  };

  return (
    <Show when={displayData()}>
      {(data) => (
        <div class="flex items-center gap-2">
          <SavvaTokenIcon class="w-5 h-5" />
          <div classList={{ "default-animation": isAnimating() }} class="flex items-center gap-2 text-sm">
            <span class="font-semibold">{formatPrice(data().price)}</span>
            <div classList={{ "text-emerald-500": data().gain >= 0, "text-red-500": data().gain < 0 }} class="flex items-center gap-1 text-xs">
              <Show when={data().gain >= 0} fallback={<DownArrow />}>
                <UpArrow />
              </Show>
              <span>{formatGain(data().gain)}</span>
            </div>
          </div>
        </div>
      )}
    </Show>
  );
}
</file>

<file path="src/components/net/WsConnector.jsx">
// src/components/net/WsConnector.jsx
import { onMount, onCleanup, createSignal } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { ensureWsStarted, getWsClient, getWsApi, onAlert, offAlert } from "../../net/wsRuntime";
import { wsUrl } from "../../net/endpoints";
import { pushToast } from "../../ui/toast.js";
import { useI18n } from "../../i18n/useI18n.js";

let _mounted = false;

export default function WsConnector() {
  if (_mounted) return null;
  _mounted = true;

  const app = useApp();
  const { t } = useI18n();

  const ws = getWsClient();
  const api = getWsApi();

  app.ws = ws;
  app.wsUrl = wsUrl;
  app.wsStatus = () => ws.status();
  app.wsConnected = () => ws.status() === "open";
  app.wsReconnect = (r) => ws.reconnect(r || "manual");
  app.wsCall = api.call;
  app.wsMethod = api.method;
  app.alertBus = { on: onAlert, off: offAlert };
  app.onAlert = onAlert;
  app.offAlert = offAlert;

  onMount(() => {
    ensureWsStarted("connector-mount");

    const [hasConnectedOnce, setHasConnectedOnce] = createSignal(false);

    const onOpen = () => {
      setHasConnectedOnce(true);
    };

    const onClose = () => {
      if (!hasConnectedOnce()) {
        pushToast({
          type: "warning",
          message: t("error.ws.title"),
          details: t("error.ws.message"),
          autohideMs: 15000,
        });
      }
    };

    const onAuthError = () => {
      app.handleAuthError?.();
    };

    ws.on("open", onOpen);
    ws.on("close", onClose);
    ws.on("auth_error", onAuthError);

    onCleanup(() => {
      ws.off("open", onOpen);
      ws.off("close", onClose);
      ws.off("auth_error", onAuthError);
    });
  });

  return null;
}
</file>

<file path="src/components/settings/DeveloperSection.jsx">
// src/components/settings/DeveloperSection.jsx
import { useApp } from "../../context/AppContext.jsx";
import { dbg } from "../../utils/debug";

export default function DeveloperSection() {
  const app = useApp();
  const { t } = app;

  return (
    <section class="bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] rounded-lg shadow p-4 space-y-3">
      <h3 class="text-lg font-medium">{t("settings.developer.title")}</h3>

      {/* Show translation keys */}
      <label class="flex items-center gap-2">
        <input
          type="checkbox"
          checked={app.showKeys()}
          onInput={(e) => app.setShowKeys(e.currentTarget.checked)}
        />
        <span>{t("settings.developer.showKeys")}</span>
      </label>

      {/* Enable debug logging */}
      <label class="flex items-center gap-2">
        <input
          type="checkbox"
          checked={dbg.enabled()}
          onInput={(e) => dbg.enable(e.currentTarget.checked)}
        />
        <span>{t("settings.developer.debug.enable")}</span>
      </label>
    </section>
  );
}
</file>

<file path="src/components/tabs/CommentsTab.jsx">
// src/components/tabs/CommentsTab.jsx
import { createSignal, onCleanup, onMount, For, Show, createEffect, on } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { dbg } from "../../utils/debug.js";
import { toChecksumAddress } from "../../blockchain/utils.js";
import CommentThread from "../comments/CommentThread.jsx";

export default function CommentsTab(props) {
  const { t } = useApp();
  const app = useApp();
  const [items, setItems] = createSignal([]);
  const [page, setPage] = createSignal(0);
  const [hasMore, setHasMore] = createSignal(true);
  const [loading, setLoading] = createSignal(false);
  const [hasLoadedOnce, setHasLoadedOnce] = createSignal(false);

  const commentListFetcher = app.wsMethod ? app.wsMethod("latest-comments-new") : null;

  async function loadMore() {
    if (loading() || !hasMore()) return;
    setLoading(true);

    try {
      const nextPage = page() + 1;
      const pageSize = 10;

      const params = {
        domain: app.selectedDomainName(),
        limit: pageSize,
        offset: (nextPage - 1) * pageSize,
      };

      const user = app.authorizedUser();
      if (user?.address) {
        params.my_addr = toChecksumAddress(user.address);
      }

      if (!commentListFetcher) throw new Error("API method not available.");

      const res = await commentListFetcher(params);
      const chunk = res?.list || [];

      if (chunk.length < pageSize) setHasMore(false);

      const newItems = chunk.map(it => ({ id: it.savva_cid, _raw: it }));
      setItems(prev => [...prev, ...newItems]);
      setPage(nextPage);

    } catch (e) {
      dbg.error("CommentsTab", "Failed to fetch comments", e);
    } finally {
      setLoading(false);
    }
  }

  createEffect(() => {
    if (props.isActivated && !hasLoadedOnce()) {
      setHasLoadedOnce(true);
      loadMore();
    }
  });

  onMount(() => {
    const handleScroll = () => {
      if (!props.isActivated) return;
      const scrollThreshold = 400;
      const scrolledToBottom = window.innerHeight + window.scrollY >= document.documentElement.scrollHeight - scrollThreshold;
      if (scrolledToBottom) loadMore();
    };

    let timeoutId = null;
    const throttledHandleScroll = () => {
      if (timeoutId === null) {
        timeoutId = setTimeout(() => { handleScroll(); timeoutId = null; }, 200);
      }
    };
    window.addEventListener('scroll', throttledHandleScroll, { passive: true });

    onCleanup(() => {
      window.removeEventListener('scroll', throttledHandleScroll);
      if (timeoutId) clearTimeout(timeoutId);
    });
  });

  return (
    <section class="w-full space-y-4">
      <For each={items()}>
        {(item) => <CommentThread thread={item} />}
      </For>
      <Show when={loading()}>
        <div class="py-4 text-sm text-[hsl(var(--muted-foreground))] text-center">{t("common.loading")}</div>
      </Show>
    </section>
  );
}
</file>

<file path="src/components/ui/icons/FishIcons.jsx">
// src/components/ui/icon/FishIcons.jsx
// Icons sized by parent via Tailwind classes. We enforce a safe default (w-4 h-4)
// and make sure `class` actually reaches the <svg>. All other props pass through.

function Svg(props) {
  // This robustly gets the class from props, falling back to a default.
  const cls = props.class || props.className || "w-4 h-4";

  // This removes class and children from `rest` so they aren't passed twice.
  const { class: _, className: __, children, viewBox, ...rest } = props;

  return (
    <svg
      viewBox={props.viewBox}
      fill="currentColor"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid meet"
      class={cls}
      role="img"
      focusable="false"
      {...rest}
    >
      {props.children}
    </svg>
  );
}

export function ClamIcon(props) {
  return (
    <Svg  {...props} viewBox="0 0 50 50" >
      <g transform="translate(0,8 ) scale(0.6)">
        <path d="M 28.34375 1.8125 C 28.023438 1.816406 27.703125 1.867188 27.40625 1.9375 C 26.8125 2.082031 26.273438 2.371094 25.8125 2.71875 C 25.460938 2.984375 25.199219 3.316406 24.9375 3.65625 C 23.851563 2.4375 22.117188 1.667969 20.125 2.0625 C 20.101563 2.066406 20.085938 2.058594 20.0625 2.0625 C 17.347656 2.441406 14.894531 3.179688 12.6875 4.125 C 10.332031 5.132813 9.207031 6.75 9 8.25 C 7.671875 8.105469 6.128906 8.539063 4.90625 9.9375 C 4.90625 9.949219 4.90625 9.957031 4.90625 9.96875 C 3.5625 11.613281 2.425781 13.480469 1.65625 15.5625 C 1.113281 17.027344 0.976563 18.4375 1.21875 19.65625 C 1.316406 20.140625 1.53125 20.585938 1.75 21 C 1.476563 21.148438 1.171875 21.253906 0.96875 21.5 C 0.296875 22.308594 0.0507813 23.402344 0 24.8125 C 0 24.832031 0 24.855469 0 24.875 C 0 28.109375 0.636719 30.453125 1.78125 32.21875 C 2.925781 33.984375 4.535156 35.082031 6.25 35.90625 C 9.269531 37.359375 12.621094 38.167969 15.40625 40.15625 C 15.140625 40.410156 14.878906 40.667969 14.65625 40.96875 C 14.09375 41.726563 13.617188 42.65625 13.28125 43.53125 C 13.121094 43.941406 13.003906 44.347656 13 44.8125 C 12.996094 45.277344 13.175781 45.855469 13.5625 46.21875 C 14.335938 46.945313 15.359375 47 16.875 47 C 18.855469 47 19.996094 47.007813 20.8125 46.90625 C 21.097656 46.871094 21.359375 46.746094 21.625 46.625 C 22.582031 47.472656 23.664063 48.15625 25.15625 48.15625 C 26.226563 48.15625 27.15625 47.820313 27.90625 47.28125 C 28.308594 46.992188 28.582031 46.578125 28.90625 46.21875 C 29.085938 46.335938 29.226563 46.515625 29.4375 46.59375 C 30.273438 46.898438 31.371094 47 33.125 47 C 34.640625 47 35.664063 46.945313 36.4375 46.21875 C 36.824219 45.855469 37.003906 45.277344 37 44.8125 C 36.996094 44.347656 36.878906 43.941406 36.71875 43.53125 C 36.355469 42.582031 35.746094 41.644531 35.0625 40.875 C 34.847656 40.632813 34.605469 40.449219 34.375 40.25 C 37.554688 38.003906 41.050781 37.246094 44.09375 35.75 C 45.75 34.9375 47.277344 33.832031 48.34375 32.09375 C 49.410156 30.355469 50 28.050781 50 24.875 C 50 24.277344 49.859375 23.296875 49.40625 22.28125 C 49.179688 21.773438 48.875 21.230469 48.34375 20.84375 C 48.59375 20.445313 48.796875 20.03125 48.90625 19.53125 C 49.148438 18.433594 48.953125 17.207031 48.375 15.5625 C 47.558594 13.25 46.398438 11.519531 45 9.75 C 45 9.738281 45 9.730469 45 9.71875 C 43.980469 8.4375 42.238281 7.972656 40.65625 8.34375 C 40.523438 6.65625 39.410156 4.980469 37.53125 4.15625 C 35.261719 3.160156 31.992188 2.589844 29.3125 1.9375 C 28.984375 1.859375 28.664063 1.808594 28.34375 1.8125 Z M 28.3125 3.8125 C 28.472656 3.808594 28.640625 3.832031 28.8125 3.875 C 31.582031 4.546875 34.898438 5.1875 36.75 6 C 38.65625 6.835938 39.171875 8.433594 38.5 9.59375 C 38.460938 9.652344 38.429688 9.714844 38.40625 9.78125 C 38.394531 9.820313 38.382813 9.863281 38.375 9.90625 L 30.09375 29.34375 C 29.894531 29.675781 29.90625 30.089844 30.117188 30.410156 C 30.332031 30.730469 30.710938 30.902344 31.09375 30.847656 C 31.472656 30.792969 31.792969 30.523438 31.90625 30.15625 L 40.15625 10.78125 C 41.121094 9.898438 42.746094 10.097656 43.4375 10.96875 C 44.785156 12.667969 45.78125 14.175781 46.5 16.21875 C 47.019531 17.691406 47.09375 18.535156 46.96875 19.09375 C 46.84375 19.652344 46.507813 20.09375 45.84375 20.78125 C 45.820313 20.800781 45.800781 20.820313 45.78125 20.84375 L 34.15625 32.40625 C 33.757813 32.804688 33.757813 33.445313 34.15625 33.84375 C 34.554688 34.242188 35.195313 34.242188 35.59375 33.84375 L 47 22.46875 C 47.039063 22.476563 47.101563 22.429688 47.15625 22.46875 C 47.261719 22.546875 47.453125 22.777344 47.59375 23.09375 C 47.875 23.722656 48 24.726563 48 24.875 C 48 27.808594 47.480469 29.691406 46.65625 31.03125 C 45.832031 32.371094 44.683594 33.21875 43.21875 33.9375 C 40.289063 35.378906 36.105469 36.171875 32.28125 39.28125 C 32.199219 39.347656 32.171875 39.433594 32.09375 39.5 C 32.074219 39.515625 32.050781 39.515625 32.03125 39.53125 C 31.949219 39.59375 31.875 39.667969 31.8125 39.75 C 31.765625 39.796875 31.722656 39.851563 31.6875 39.90625 C 30.164063 41.335938 29.117188 42.859375 28.25 44.03125 C 28.234375 44.050781 28.203125 44.074219 28.1875 44.09375 C 28.164063 44.125 28.144531 44.15625 28.125 44.1875 C 27.652344 44.8125 27.191406 45.339844 26.75 45.65625 C 26.28125 45.992188 25.832031 46.15625 25.15625 46.15625 C 23.746094 46.15625 23.054688 45.546875 22.03125 44.3125 C 21.007813 43.078125 19.847656 41.289063 17.875 39.5 C 14.417969 36.367188 10.1875 35.601563 7.125 34.125 C 5.59375 33.386719 4.359375 32.496094 3.46875 31.125 C 2.582031 29.757813 2.003906 27.855469 2 24.90625 C 2 24.894531 2 24.886719 2 24.875 C 2.046875 23.71875 2.292969 23.027344 2.5 22.78125 C 2.660156 22.589844 2.914063 22.609375 3.21875 22.625 L 15 33.3125 C 15.253906 33.59375 15.648438 33.710938 16.015625 33.605469 C 16.378906 33.503906 16.65625 33.203125 16.726563 32.828125 C 16.796875 32.453125 16.648438 32.070313 16.34375 31.84375 L 4.40625 20.96875 C 4.367188 20.921875 4.328125 20.882813 4.28125 20.84375 C 4.269531 20.832031 4.261719 20.824219 4.25 20.8125 C 4.230469 20.800781 4.207031 20.789063 4.1875 20.78125 C 4.15625 20.757813 4.125 20.738281 4.09375 20.71875 C 4.082031 20.707031 4.074219 20.699219 4.0625 20.6875 C 3.71875 20.515625 3.34375 20.070313 3.1875 19.28125 C 3.03125 18.492188 3.101563 17.410156 3.53125 16.25 C 4.214844 14.402344 5.214844 12.746094 6.4375 11.25 C 7.585938 9.933594 8.703125 10.070313 9.34375 10.40625 L 18.34375 29.90625 C 18.457031 30.273438 18.777344 30.542969 19.15625 30.597656 C 19.539063 30.652344 19.917969 30.480469 20.132813 30.160156 C 20.34375 29.839844 20.355469 29.425781 20.15625 29.09375 L 11.03125 9.25 L 11 9.15625 C 10.777344 8.542969 10.871094 7.082031 13.46875 5.96875 C 15.539063 5.082031 17.851563 4.382813 20.40625 4.03125 C 20.425781 4.03125 20.449219 4.03125 20.46875 4.03125 C 22.347656 3.636719 23.722656 4.835938 24 5.875 L 24 28.625 C 23.996094 28.984375 24.183594 29.320313 24.496094 29.503906 C 24.808594 29.683594 25.191406 29.683594 25.503906 29.503906 C 25.816406 29.320313 26.003906 28.984375 26 28.625 L 26 5.8125 C 26.128906 5.277344 26.492188 4.695313 27 4.3125 C 27.398438 4.011719 27.832031 3.820313 28.3125 3.8125 Z" />
      </g>
    </Svg>
  );
}

export function ShrimpIcon(props) {
  return (
    <Svg  {...props} viewBox="0 0 64 64" >
      <g transform="translate(2.5, 7.5) scale(0.7)">
        <path d="M 15.771484 4.0019531 A 14 14 0 0 0 16 32 C 16.359 32 16.677469 31.982031 16.980469 31.957031 L 21.449219 36.082031 A 10.971 10.971 0 0 0 28.910156 39 L 43.683594 39 A 4.281 4.281 0 0 1 45.435547 39.380859 A 4.191 4.191 0 0 1 46.517578 40.087891 C 46.541578 40.108891 46.568797 40.126438 46.591797 40.148438 A 4.389 4.389 0 0 1 47.052734 40.648438 A 4.452 4.452 0 0 1 47.441406 41.240234 A 4.545 4.545 0 0 1 47.804688 42.101562 C 47.824688 42.167563 47.850187 42.232734 47.867188 42.302734 C 47.893188 42.402734 47.909734 42.501563 47.927734 42.601562 A 3.53 3.53 0 0 1 47.955078 43.867188 A 4.19 4.19 0 0 1 47.837891 44.435547 C 47.837891 44.453547 47.829219 44.472234 47.824219 44.490234 A 4.147 4.147 0 0 1 47.640625 44.996094 C 47.628625 45.025094 47.618469 45.055984 47.605469 45.083984 A 4.311 4.311 0 0 1 47.351562 45.556641 C 47.336562 45.581641 47.322641 45.607813 47.306641 45.632812 A 4.364 4.364 0 0 1 46.972656 46.082031 C 46.958656 46.099031 46.944688 46.119719 46.929688 46.136719 C 46.829687 46.247719 46.728906 46.348266 46.628906 46.447266 C 46.583906 46.490266 46.539187 46.531266 46.492188 46.572266 C 46.404187 46.649266 46.312703 46.722016 46.220703 46.791016 C 46.128703 46.860016 46.043172 46.913703 45.951172 46.970703 C 45.882172 47.013703 45.814188 47.060609 45.742188 47.099609 A 4.21 4.21 0 0 1 45.199219 47.353516 L 41.748047 48.646484 A 3.993 3.993 0 0 0 38 46 L 30 46 A 1 1 0 0 0 29.419922 47.8125 L 33.164062 50.488281 A 13.468 13.468 0 0 0 35.900391 52 A 13.565 13.565 0 0 0 33.167969 53.511719 L 29.421875 56.1875 A 1 1 0 0 0 30 58 L 38 58 A 3.987 3.987 0 0 0 41.443359 56 L 46.5 56 C 46.914 56 47.320563 55.971453 47.726562 55.939453 L 47.742188 55.939453 C 48.036187 55.915453 48.328188 55.880844 48.617188 55.839844 C 48.744188 55.822844 48.868141 55.80225 48.994141 55.78125 A 15.369 15.369 0 0 0 51.658203 55.099609 C 51.778203 55.056609 51.898578 55.01375 52.017578 54.96875 C 52.283578 54.86875 52.547641 54.767484 52.806641 54.646484 C 52.879641 54.613484 52.950437 54.576969 53.023438 54.542969 A 15.407 15.407 0 0 0 54.398438 53.814453 C 54.543438 53.728453 54.686125 53.642734 54.828125 53.552734 C 55.037125 53.418734 55.243312 53.280719 55.445312 53.136719 C 55.487313 53.107719 55.531266 53.080781 55.572266 53.050781 C 55.645266 52.997781 55.713156 52.936812 55.785156 52.882812 C 56.054156 52.682812 56.321172 52.474859 56.576172 52.255859 C 56.668172 52.176859 56.75375 52.092719 56.84375 52.011719 C 57.10575 51.776719 57.364375 51.538156 57.609375 51.285156 C 57.651375 51.242156 57.689469 51.196344 57.730469 51.152344 A 15.488 15.488 0 0 0 61.125 45.587891 L 61.146484 45.53125 C 61.283484 45.13125 61.400859 44.731453 61.505859 44.314453 C 61.511859 44.290453 61.521344 44.266188 61.527344 44.242188 C 61.533344 44.218187 61.536969 44.193922 61.542969 44.169922 C 61.626969 43.827922 61.699766 43.484766 61.759766 43.134766 C 61.808766 42.856766 61.853719 42.578734 61.886719 42.302734 C 61.906719 42.136734 61.919594 41.970734 61.933594 41.802734 C 61.972594 41.365734 62 40.931906 62 40.503906 C 62 40.041906 61.970688 39.580094 61.929688 39.121094 C 61.916687 38.973094 61.899766 38.8315 61.884766 38.6875 C 61.844766 38.354167 61.793755 38.023932 61.732422 37.697266 C 61.696422 37.503266 61.659187 37.310141 61.617188 37.119141 C 61.543854 36.795807 61.461141 36.475536 61.369141 36.158203 C 61.303141 35.933203 61.229297 35.714141 61.154297 35.494141 C 61.093297 35.317141 61.028938 35.141797 60.960938 34.966797 A 15.314 15.314 0 0 0 59.8125 32.599609 C 59.7645 32.518609 59.723828 32.434516 59.673828 32.353516 C 59.651828 32.319516 59.626469 32.289906 59.605469 32.253906 C 59.393469 31.917906 59.167641 31.592391 58.931641 31.275391 C 58.854641 31.175391 58.780172 31.06975 58.701172 30.96875 C 58.489172 30.69875 58.267062 30.436641 58.039062 30.181641 C 57.918062 30.045641 57.796875 29.90825 57.671875 29.78125 C 57.471875 29.57325 57.265688 29.375641 57.054688 29.181641 C 56.889688 29.026641 56.724687 28.871609 56.554688 28.724609 C 56.354687 28.556609 56.154266 28.397281 55.947266 28.238281 C 55.757266 28.092281 55.569047 27.947547 55.373047 27.810547 C 55.148047 27.652547 54.916594 27.509328 54.683594 27.361328 C 54.502594 27.248328 54.324672 27.134297 54.138672 27.029297 C 53.853672 26.867297 53.560625 26.720172 53.265625 26.576172 C 53.127625 26.509172 52.991563 26.439953 52.851562 26.376953 C 52.486562 26.212953 52.111422 26.066687 51.732422 25.929688 C 51.654422 25.901688 51.579 25.871703 51.5 25.845703 C 51.068 25.697703 50.625734 25.570938 50.177734 25.460938 C 50.150734 25.454937 50.125609 25.445453 50.099609 25.439453 L 50.066406 25.433594 A 15.275 15.275 0 0 0 48.332031 25.121094 L 48.271484 25.111328 A 15.4 15.4 0 0 0 46.5 25 L 12.175781 25 A 7.99 7.99 0 1 1 24 18 A 7.926 7.926 0 0 1 23.111328 21.671875 A 1.0002716 1.0002716 0 1 0 24.888672 22.587891 A 10 10 0 1 0 6 18 A 10.017 10.017 0 0 0 11.527344 26.925781 L 14.792969 29.939453 A 12 12 0 1 1 28 18 A 11.877 11.877 0 0 1 27.419922 21.689453 A 1 1 0 0 0 29.318359 22.310547 A 14 14 0 0 0 15.771484 4.0019531 z" />
      </g>
    </Svg>
  );
}

export function SeahorseIcon(props) {
  return (
    <Svg  {...props} viewBox="0 0 100 100" >
      <path d="M 50.898438 2.0097656 C 50.776313 1.99325 50.650891 1.9995 50.525391 2.03125 C 37.155391 5.37025 36.115234 17.542359 36.115234 21.193359 C 36.115234 25.487359 38.245047 29.32975 40.123047 32.71875 C 41.877047 35.88175 43.392219 38.614719 42.324219 40.386719 C 42.021219 40.890719 41.832469 40.928625 41.730469 40.890625 C 40.005469 40.888625 36.624688 35.236266 35.179688 32.822266 L 34.773438 32.146484 C 34.295437 31.355484 33.426859 30.876453 32.505859 30.939453 C 31.572859 30.987453 30.744703 31.545531 30.345703 32.394531 C 29.002703 35.248531 27.015625 41.853797 27.015625 46.966797 C 27.015625 52.288797 29.865063 59.159953 31.789062 62.126953 C 32.275063 62.877953 33.082234 63.317438 33.990234 63.273438 C 34.882234 63.240437 35.671562 62.752797 36.101562 61.966797 L 36.753906 60.765625 C 40.439906 53.948625 42.823688 50.498047 43.804688 50.498047 C 43.806688 50.498047 43.788719 50.449031 43.886719 50.582031 C 45.764719 53.184031 44.375188 57.522625 42.617188 63.015625 C 40.990187 68.100625 39.146484 73.863312 39.146484 80.320312 C 39.146484 88.834312 44.207453 97.998047 55.314453 97.998047 C 59.036453 97.998047 62.414172 96.579 64.826172 94 C 67.172172 91.494 68.384344 88.062031 68.152344 84.582031 C 67.806344 79.391031 63.476953 74.327875 58.501953 73.296875 C 57.488953 73.088875 56.504594 73.057219 55.558594 73.199219 C 55.736594 73.013219 55.915656 72.829625 56.097656 72.640625 C 61.950656 66.564625 69.964844 58.243609 69.964844 47.724609 C 69.964844 40.941609 63.872828 36.397891 57.423828 31.587891 C 56.504828 30.901891 55.571672 30.207187 54.638672 29.492188 C 56.622672 30.087187 58.747922 30.335547 60.669922 30.560547 C 62.488922 30.773547 64.208844 30.974063 65.464844 31.414062 C 67.918844 32.274062 69.599172 31.627547 70.576172 30.935547 C 72.072172 29.878547 73 27.888188 73 25.742188 C 73 22.969188 70.480766 21.602484 68.259766 20.396484 C 66.240766 19.300484 64.335141 18.265297 63.869141 16.404297 C 63.495141 14.906297 62.713375 13.590359 61.734375 12.443359 C 61.935375 10.149359 64.087687 9.088875 64.179688 9.046875 C 64.682688 8.817875 64.902828 8.2246562 64.673828 7.7226562 C 64.444828 7.2196562 63.852609 6.9985625 63.349609 7.2265625 C 63.229609 7.2815625 60.938828 8.3603437 60.048828 10.777344 C 57.418828 8.5453438 54.272125 7.2224375 53.078125 6.7734375 L 51.714844 2.6855469 C 51.590344 2.3135469 51.264812 2.0593125 50.898438 2.0097656 z" />
    </Svg>
  );
}

export function FishIcon(props) {
  return (
    <Svg  {...props} viewBox="0 0 50 50" >
      <g transform="translate(-4, 7.5) scale(0.7)">
        <path d="M 4.5039062 0.20898438 C 4.270002 0.23072292 4.0374397 0.27702534 3.8144531 0.34375 C 2.922507 0.61064864 2.0852782 1.1885241 1.40625 2.0078125 C 0.72729902 2.8270078 0.31552594 3.7577873 0.21875 4.6835938 C 0.12197406 5.6094001 0.37308219 6.6074318 1.1386719 7.2421875 C 1.43736 7.4893777 1.8198467 7.4359783 2.1757812 7.5234375 C 2.4225489 11.09635 4.525241 15.440882 7.8164062 18.134766 C 9.5864535 19.584191 11.359848 20.69642 13.121094 21.65625 C 13.103526 22.162235 13.10425 23.075854 13.398438 24.574219 C 13.80211 26.630219 14.74083 29.449618 16.845703 32.558594 A 1.0001 1.0001 0 0 0 18.65625 32.177734 C 19.134059 29.549783 19.60628 27.105743 20.519531 25.171875 C 21.616408 25.674639 22.699505 26.188944 23.755859 26.765625 C 28.735333 29.483999 33.350052 33.416251 37.494141 43.083984 C 37.524051 43.305713 37.548231 43.501404 37.625 43.818359 C 37.734856 44.271895 37.893465 44.837198 38.107422 45.445312 C 38.535335 46.661544 39.146562 48.049412 40.144531 49.058594 A 1.0001 1.0001 0 0 0 41.558594 49.066406 C 43.114842 47.52782 45.505072 45.357545 48.664062 46.039062 A 1.0001 1.0001 0 0 0 49.703125 44.5 C 48.611812 42.890775 46.55504 41.747146 44.716797 40.855469 C 43.797675 40.40963 42.934551 40.049973 42.275391 39.800781 C 42.023197 39.705441 41.832107 39.642515 41.644531 39.580078 C 39.202514 28.271869 34.796589 19.708091 29.560547 13.513672 C 30.850875 12.338725 32.379531 11.242945 34.085938 10.183594 A 1.0001 1.0001 0 0 0 33.746094 8.3515625 C 31.677205 7.9570182 29.804401 7.8578073 28.181641 7.9199219 C 26.707354 7.9763533 25.472282 8.1722455 24.451172 8.3925781 C 22.752925 6.9642462 21.012111 5.7401109 19.257812 4.7109375 C 15.38605 2.4404773 10.794582 1.0474109 6.9609375 1.7402344 C 6.8099329 1.4073736 6.8004425 1.0214779 6.5019531 0.7734375 A 1.0001 1.0001 0 0 0 6.5 0.7734375 C 6.1170809 0.45595918 5.6691208 0.28196704 5.2050781 0.22070312 C 4.9730568 0.19007117 4.7378105 0.18724583 4.5039062 0.20898438 z" />
      </g>
    </Svg>
  );
}

export function DolphinIcon(props) {
  return (
    <Svg  {...props} viewBox="0 0 512 512" >
      <g transform="translate(5, 5) scale(0.8)">
        <path d="M 156.81445 44.033203 C 82.753209 44.885544 54.486344 91.555047 46.675781 108.53711 A 16.152 16.152 0 0 1 39.265625 116.1543 C 22.925625 124.3873 13.571844 132.68527 11.464844 140.82227 A 13.693 13.693 0 0 0 13.5 152.24219 C 20.068 161.89719 35.662828 163.52756 61.173828 157.22656 C 62.061161 157.00656 62.94174 156.78273 63.816406 156.55273 C 69.267406 160.41573 84.459859 168.07597 121.13086 170.54297 A 91.95 91.95 0 0 0 117.14844 196.00586 C 116.97544 212.78986 121.95669 236.62438 146.67969 254.85938 A 12.446 12.446 0 0 0 166.48047 245.61328 C 166.68947 240.52428 164.78086 235.78628 164.38086 230.23828 C 161.86086 202.08828 177.04686 190.14683 182.50586 186.79883 A 373.73 373.73 0 0 1 234.52734 216.62305 C 248.50034 231.87205 269.25528 247.90812 299.98828 260.57812 A 7.488 7.488 0 0 0 309.76172 250.79297 C 309.21172 249.46497 308.61514 247.90636 307.99414 246.19336 C 358.88114 260.69336 383.56352 299.70325 395.35352 330.53125 C 400.53552 344.07725 396.28053 359.70211 384.76953 369.41211 C 380.31653 373.16711 375.72409 377.27414 371.12109 381.61914 C 354.61109 397.19614 359.30584 420.11991 362.08984 429.25391 A 6.471 6.471 0 0 0 374.28125 429.80078 C 381.55725 411.71378 397.34152 412.69172 406.10352 414.88672 C 415.76452 417.30472 422.32486 416.63508 426.75586 414.83008 C 427.90586 420.77908 430.36277 427.49602 435.50977 432.04102 C 439.80977 435.84102 445.20955 437.47311 451.56055 436.91211 C 473.09955 435.00011 482.89933 455.05934 486.11133 463.77734 C 488.04233 469.59234 497.01178 469.17638 498.42578 463.23438 C 510.13778 420.57538 479.53114 394.53364 460.24414 382.80664 A 33.133 33.133 0 0 1 444.41992 358.05859 C 433.33392 259.96859 410.36191 191.72306 372.12891 143.28906 A 223.674 223.674 0 0 0 323.37109 97.511719 C 325.25509 80.526719 335.90755 74.529078 342.31055 72.455078 A 6.531 6.531 0 0 0 342.86914 60.25 C 306.56114 44.469 270.35333 60.963031 261.23633 65.707031 A 430.966 430.966 0 0 0 215.71484 51.691406 C 193.43497 46.080281 173.90551 43.836509 156.81445 44.033203 z" />
      </g>
    </Svg>
  );
}

export function SharkIcon(props) {
  return (
    <Svg  {...props} viewBox="0 0 64 64" >
      <path d="M 1.5253906 9 A 1.0001 1.0001 0 0 0 0.609375 9.7753906 C -0.74611553 15.632047 0.63420421 20.604254 2.53125 25.009766 C 2.4325452 25.011589 2.0586928 25 2 25 A 1.0001 1.0001 0 0 0 1.0117188 26.152344 C 2.8993434 38.421904 12.827344 45.149616 14.755859 46.363281 L 12.080078 52.605469 A 1.0001 1.0001 0 0 0 12.990234 54 C 16.769393 54.03749 20.02326 52.520915 22.660156 49.785156 C 23.228073 51.114373 25.312061 55.970583 27.072266 60.371094 A 1.0001 1.0001 0 0 0 28.513672 60.857422 C 31.257469 59.211144 33.12469 56.526277 34.068359 53.830078 C 34.545777 52.466027 34.802775 51.087731 34.779297 49.806641 C 38.002478 49.181617 42.906276 47.513443 47.435547 44.453125 C 51.961389 41.395124 55.916969 36.918323 56.779297 31.011719 C 58.321083 31.168728 59.8423 30.82914 61.039062 30.285156 C 62.522143 29.611029 63.599609 28.800781 63.599609 28.800781 A 1.0001 1.0001 0 0 0 63.416016 27.091797 C 59.382578 25.242803 57.787642 22.75908 57.109375 20.085938 C 56.431108 17.412795 56.774948 14.514855 56.996094 12.089844 A 1.0001 1.0001 0 0 0 55.400391 11.199219 C 51.083708 14.43673 48.694338 21.437051 50.958984 27.835938 C 49.792363 30.539973 47.328731 32.620257 44.59375 33.519531 C 41.9334 34.394266 39.150455 34.127063 37.03125 32.488281 C 37.0635 29.804082 37.313275 27.587952 38.154297 25.800781 C 39.052974 23.891092 40.586399 22.324965 43.447266 20.894531 A 1.0001 1.0001 0 0 0 43.447266 19.105469 C 41.208752 17.986212 38.542199 17.738801 36.138672 18.005859 C 33.735145 18.272918 31.587597 18.998341 30.292969 20.292969 A 1.0001 1.0001 0 1 0 31.707031 21.707031 C 32.412403 21.001659 34.264855 20.227082 36.361328 19.994141 C 37.808594 19.833333 39.305608 20.008491 40.712891 20.357422 C 38.73207 21.687542 37.185086 23.16553 36.345703 24.949219 C 35.24438 27.28953 35 29.944444 35 33 A 1.0001 1.0001 0 0 0 35.337891 33.75 C 38.101193 36.1851 41.881358 36.515318 45.21875 35.417969 C 48.556142 34.320619 51.552233 31.809846 52.927734 28.371094 A 1.0001 1.0001 0 0 0 52.929688 27.630859 C 51.116127 23.066571 52.372628 18.01894 54.791016 14.806641 C 54.676652 16.620508 54.65694 18.556394 55.169922 20.578125 C 55.863738 23.312551 57.657274 25.979529 61.025391 27.994141 C 60.679302 28.198329 60.682193 28.250636 60.210938 28.464844 C 58.944018 29.040716 57.40531 29.413749 56.316406 29.050781 A 1.0001 1.0001 0 0 0 55.003906 29.916016 C 54.537124 35.517397 50.792075 39.771455 46.314453 42.796875 C 42.082932 45.656011 37.349807 47.2585 34.453125 47.832031 C 34.299345 47.341082 34.112481 46.865988 33.832031 46.445312 C 33.182689 45.4713 32.112689 44.980236 31.210938 45.220703 C 30.309186 45.46117 29.735142 46.184433 29.529297 47.007812 C 29.323452 47.831193 29.599307 48.899831 30.455078 49.503906 C 31.023654 49.905254 31.815991 50.035086 32.720703 50.044922 C 32.718503 50.995854 32.566975 52.068968 32.181641 53.169922 C 31.500664 55.115569 30.122439 56.948305 28.384766 58.324219 C 26.444103 53.558932 23.919922 47.605469 23.919922 47.605469 A 1.0001 1.0001 0 0 0 22.214844 47.380859 C 20.090749 50.073951 17.58772 51.489086 14.583984 51.845703 L 16.919922 46.394531 A 1.0001 1.0001 0 0 0 16.503906 45.136719 C 16.503906 45.136719 5.7425103 38.702065 3.2890625 27.021484 C 3.3178865 27.021137 3.3589159 27.023737 3.3886719 27.023438 C 4.3127762 28.943531 5.2665346 30.769398 6.1054688 32.447266 A 1.0001 1.0001 0 0 0 6.7578125 32.970703 C 10.948037 34.018259 15.528258 33.912893 22.349609 39.759766 A 1.0001 1.0001 0 0 0 23.978516 38.791016 C 22.401131 31.430057 17.270675 27.867611 12.433594 26.298828 C 10.015053 25.514437 7.6562889 25.193329 5.7714844 25.064453 C 5.2463582 25.028547 5.1676081 25.058388 4.7207031 25.046875 C 2.8447955 20.922473 1.4690843 16.424263 2.4140625 11.177734 C 8.4623746 12.164816 12.505101 13.93755 16.761719 16.304688 C 16.280001 16.480981 15.732013 16.559996 15.392578 16.908203 C 14.81943 17.496164 14.473819 18.286921 14.494141 19.125 C 14.514461 19.963079 14.937769 20.82134 15.699219 21.423828 C 16.479133 22.040974 17.491787 22.091461 18.314453 21.818359 C 19.137119 21.545258 19.849172 20.982636 20.320312 20.216797 C 20.496934 19.929699 20.586449 19.582394 20.673828 19.238281 C 23.538852 21.140241 26.968113 23.494282 31.265625 29.578125 A 1.0006075 1.0006075 0 1 0 32.900391 28.423828 C 27.899108 21.343681 23.608111 18.720512 20.640625 16.742188 C 20.459028 16.621105 20.275008 16.580558 20.091797 16.486328 C 19.654328 15.864345 19.080559 15.27754 18.212891 14.789062 C 13.444357 12.103419 8.8510985 10.027836 1.7246094 9.0097656 A 1.0001 1.0001 0 0 0 1.625 9 A 1.0001 1.0001 0 0 0 1.5253906 9 z M 17.835938 17.835938 C 18.078688 17.819897 18.442878 18.036632 18.753906 18.144531 C 18.850896 18.517018 18.813815 18.850308 18.617188 19.169922 C 18.404077 19.516333 18.02349 19.807086 17.683594 19.919922 C 17.343697 20.032758 17.125039 20.002319 16.939453 19.855469 C 16.582403 19.572957 16.498272 19.327125 16.492188 19.076172 C 16.486088 18.825219 16.594492 18.540351 16.824219 18.304688 C 17.053945 18.069024 17.388056 17.865539 17.835938 17.835938 z M 5.5996094 27.060547 C 5.6166464 27.061647 5.6176366 27.059347 5.6347656 27.060547 C 7.4062111 27.181671 9.6099472 27.485563 11.816406 28.201172 C 15.497296 29.394974 19.040911 31.779818 20.976562 36.34375 C 15.359785 32.43424 10.950806 31.892342 7.6796875 31.134766 C 7.008568 29.809156 6.295292 28.457886 5.5996094 27.060547 z M 31.761719 47.138672 C 31.808707 47.126668 31.904976 47.160197 32.167969 47.554688 C 32.222479 47.636448 32.208579 47.817319 32.255859 47.912109 C 32.112142 47.869579 31.667571 47.913514 31.607422 47.871094 C 31.400695 47.725169 31.426548 47.668807 31.470703 47.492188 C 31.514853 47.315568 31.690814 47.16383 31.726562 47.154297 C 31.7355 47.151922 31.746056 47.142673 31.761719 47.138672 z" />
    </Svg>
  );
}

export function StingrayIcon(props) {
  return (
    <Svg  {...props} viewBox="0 0 64 64" >
      <path d="M 9.3203125 1.7597656 C 7.7503125 1.7597656 6 3.1298438 6 5.0898438 C 6 7.0598437 7.2299219 9.1092188 8.9199219 11.949219 C 10.489922 14.579219 12.450547 17.859453 14.060547 22.189453 C 15.790547 26.809453 15.440625 30.140312 15.140625 33.070312 C 14.880625 35.480313 14.660156 37.669922 15.660156 39.919922 C 15.270156 40.459922 14.939922 40.960703 14.669922 41.470703 C 14.069922 42.480703 13.320078 44.049062 13.080078 45.789062 C 12.860078 47.269063 13.099297 48.900703 13.779297 50.470703 C 14.429297 52.030703 15.380781 53.179922 16.050781 53.919922 C 16.960781 54.919922 17.940781 55.769297 18.800781 56.529297 C 19.450781 57.109297 20.079844 57.649453 20.589844 58.189453 C 21.789844 59.479453 21.739766 59.819219 21.009766 60.699219 C 20.389766 61.449219 20.389766 62.539297 21.009766 63.279297 C 21.359766 63.689297 21.840859 63.950234 22.380859 63.990234 C 22.440859 64.000234 22.490781 64 22.550781 64 C 23.020781 64 23.479844 63.829297 23.839844 63.529297 C 24.629844 62.859297 25.96 61.419297 26 59.279297 C 26 57.529297 25.250703 56.240781 24.470703 55.050781 C 23.820703 54.140781 23.199844 53.380391 22.589844 52.650391 C 21.959844 51.890391 21.359141 51.170156 20.869141 50.410156 C 20.419141 49.720156 20.119531 49.230469 20.019531 48.730469 C 19.889531 48.140469 19.870234 47.590234 19.990234 47.240234 C 20.170234 46.690234 20.580391 46.010078 21.150391 45.330078 C 23.330391 46.260078 25.470547 46.029063 27.810547 45.789062 C 30.730547 45.489063 34.040391 45.139141 38.650391 46.869141 C 42.960391 48.489141 46.219844 50.449297 48.839844 52.029297 C 51.669844 53.729297 53.709688 54.960938 55.679688 54.960938 C 57.639688 54.960938 59 53.210625 59 51.640625 C 59 49.520625 57.809922 47.030625 56.419922 44.140625 C 54.449922 40.030625 52 34.909141 52 28.869141 C 52 24.559141 54.009219 23.120703 55.949219 21.720703 C 57.449219 20.640703 59 19.529766 59 17.259766 C 59 15.959766 57.79 13.400391 55 13.400391 C 52.84 13.400391 51.820234 14.780391 50.990234 15.900391 C 50.190234 16.970391 49.56 17.830078 48 17.830078 C 46.81 17.830078 45.289062 16.529766 44.789062 16.009766 C 44.289062 15.529766 43 14.000781 43 12.800781 C 43 11.230781 43.849922 10.599063 44.919922 9.7890625 C 46.029922 8.9690625 47.410156 7.9395313 47.410156 5.7695312 C 47.410156 2.9695313 44.860547 1.7597656 43.560547 1.7597656 C 41.300547 1.7597656 40.189375 3.3200781 39.109375 4.8300781 C 37.719375 6.7700781 36.28 8.7890625 32 8.7890625 C 25.99 8.7890625 20.879063 6.3296094 16.789062 4.3496094 C 13.909063 2.9596094 11.430312 1.7597656 9.3203125 1.7597656 z M 9.3203125 3.7597656 C 10.970313 3.7597656 13.259922 4.8703906 15.919922 6.1503906 C 20.199922 8.2203906 25.53 10.789063 32 10.789062 C 37.31 10.789062 39.290234 8.0102344 40.740234 5.9902344 C 41.780234 4.5302344 42.380547 3.7597656 43.560547 3.7597656 C 43.800547 3.7597656 45.410156 4.1395313 45.410156 5.7695312 C 45.410156 6.8795313 44.830469 7.3694531 43.730469 8.1894531 C 42.510469 9.0994531 41 10.230781 41 12.800781 C 41 15.060781 43.149141 17.209922 43.369141 17.419922 C 43.609141 17.669922 45.75 19.830078 48 19.830078 C 50.57 19.830078 51.699609 18.309844 52.599609 17.089844 C 53.419609 15.979844 53.9 15.400391 55 15.400391 C 56.63 15.400391 57 17.009766 57 17.259766 C 57 18.449766 56.239297 19.049844 54.779297 20.089844 C 52.759297 21.549844 50 23.529141 50 28.869141 C 50 35.359141 52.559141 40.709766 54.619141 45.009766 C 55.899141 47.669766 57 49.980625 57 51.640625 C 57 52.170625 56.449688 52.960938 55.679688 52.960938 C 54.269688 52.960938 52.330859 51.800312 49.880859 50.320312 C 47.180859 48.700313 43.829609 46.68 39.349609 45 C 36.309609 43.85 33.750781 43.539063 31.550781 43.539062 C 30.090781 43.539062 28.789609 43.680781 27.599609 43.800781 C 25.329609 44.040781 23.580078 44.219453 21.830078 43.439453 C 21.560078 43.319453 21.28 43.18 21 43 L 20.990234 43 C 20.440234 42.65 19.880781 42.199141 19.300781 41.619141 C 18.630781 40.949141 18.139062 40.319453 17.789062 39.689453 C 17.719062 39.579453 17.669141 39.479141 17.619141 39.369141 C 17.619141 39.369141 17.609375 39.369375 17.609375 39.359375 C 16.689375 37.509375 16.880859 35.689297 17.130859 33.279297 C 17.440859 30.279297 17.819453 26.550234 15.939453 21.490234 C 14.259453 16.990234 12.250625 13.629922 10.640625 10.919922 C 9.160625 8.4599219 8 6.5098437 8 5.0898438 C 8 4.3198438 8.7903125 3.7597656 9.3203125 3.7597656 z M 13.082031 7.6054688 C 12.697984 7.5384375 12.293359 7.699625 12.068359 8.046875 C 11.768359 8.510875 11.902234 9.1296875 12.365234 9.4296875 C 12.401234 9.4536875 13.259953 10.006281 14.626953 10.738281 C 14.777953 10.819281 14.938656 10.857422 15.097656 10.857422 C 15.454656 10.857422 15.799469 10.666078 15.980469 10.330078 C 16.240469 9.8420781 16.059266 9.2375625 15.572266 8.9765625 C 14.283266 8.2845625 13.459172 7.755 13.451172 7.75 C 13.334922 7.67525 13.210047 7.6278125 13.082031 7.6054688 z M 18.583984 10.521484 C 18.194078 10.523172 17.825016 10.754219 17.666016 11.136719 C 17.454016 11.647719 17.695078 12.233313 18.205078 12.445312 C 20.425078 13.370312 22.477594 13.964844 24.308594 14.214844 C 24.354594 14.220844 24.400312 14.224609 24.445312 14.224609 C 24.937312 14.224609 25.367547 13.859422 25.435547 13.357422 C 25.510547 12.810422 25.127078 12.307422 24.580078 12.232422 C 22.921078 12.006422 21.035609 11.456609 18.974609 10.599609 C 18.847109 10.546109 18.713953 10.520922 18.583984 10.521484 z M 30.5 14.810547 A 1.5 1.506 0 1 0 30.5 17.822266 A 1.5 1.506 0 1 0 30.5 14.810547 z M 43.5 26.857422 A 1.5 1.506 0 1 0 43.5 29.869141 A 1.5 1.506 0 1 0 43.5 26.857422 z M 31.494141 37.521484 C 30.942141 37.522484 30.495094 37.970438 30.496094 38.523438 L 30.501953 40.523438 C 30.502953 41.075437 30.950953 41.521484 31.501953 41.521484 L 31.503906 41.521484 C 32.055906 41.520484 32.502953 41.072531 32.501953 40.519531 L 32.496094 38.519531 C 32.495094 37.967531 32.047094 37.521484 31.496094 37.521484 L 31.494141 37.521484 z M 25.978516 37.890625 C 25.427516 37.922625 25.006109 38.393313 25.037109 38.945312 L 25.150391 40.941406 C 25.181391 41.473406 25.622438 41.884766 26.148438 41.884766 C 26.167438 41.884766 26.187078 41.883812 26.205078 41.882812 C 26.756078 41.850813 27.177484 41.380125 27.146484 40.828125 L 27.033203 38.830078 C 27.001203 38.279078 26.533516 37.869625 25.978516 37.890625 z M 36.902344 38.123047 C 36.519188 38.195234 36.200281 38.492688 36.113281 38.898438 L 35.693359 40.853516 C 35.577359 41.394516 35.920938 41.926969 36.460938 42.042969 C 36.531938 42.057969 36.601875 42.064453 36.671875 42.064453 C 37.132875 42.064453 37.547437 41.743437 37.648438 41.273438 L 38.068359 39.318359 C 38.184359 38.777359 37.840781 38.246859 37.300781 38.130859 C 37.165281 38.100609 37.030062 38.098984 36.902344 38.123047 z M 42.400391 39.806641 C 42.010813 39.812312 41.642328 40.048391 41.486328 40.431641 L 40.734375 42.283203 C 40.526375 42.795203 40.771203 43.379891 41.283203 43.587891 C 41.406203 43.637891 41.535156 43.660156 41.660156 43.660156 C 42.055156 43.660156 42.429891 43.425109 42.587891 43.037109 L 43.339844 41.185547 C 43.547844 40.673547 43.301063 40.088859 42.789062 39.880859 C 42.661313 39.828859 42.53025 39.80475 42.400391 39.806641 z M 16.800781 41.800781 C 17.110781 42.200781 17.470859 42.609297 17.880859 43.029297 C 18.390859 43.539297 18.890859 43.970078 19.380859 44.330078 C 18.760859 45.120078 18.309844 45.919141 18.089844 46.619141 C 17.799844 47.479141 17.910547 48.480156 18.060547 49.160156 C 18.240547 49.990156 18.659453 50.680234 19.189453 51.490234 C 19.739453 52.360234 20.380781 53.119687 21.050781 53.929688 C 21.630781 54.629687 22.240313 55.349922 22.820312 56.169922 C 23.440312 57.129922 24 58.079766 24 59.259766 C 23.98 60.599766 23.080781 61.550469 22.550781 61.980469 C 24.420781 59.720469 23.270781 58.140547 22.050781 56.810547 C 21.460781 56.210547 20.809141 55.629297 20.119141 55.029297 C 19.249141 54.269297 18.369297 53.490313 17.529297 52.570312 C 16.619297 51.570313 16.039141 50.679453 15.619141 49.689453 C 15.089141 48.449453 14.890547 47.200313 15.060547 46.070312 C 15.210547 44.960313 15.680391 43.690937 16.400391 42.460938 C 16.520391 42.240938 16.650781 42.020781 16.800781 41.800781 z M 47.496094 42.136719 C 47.107359 42.104609 46.719344 42.305875 46.527344 42.671875 L 45.599609 44.441406 C 45.342609 44.931406 45.532484 45.536969 46.021484 45.792969 C 46.169484 45.870969 46.328375 45.90625 46.484375 45.90625 C 46.845375 45.90625 47.192094 45.710141 47.371094 45.369141 L 48.298828 43.599609 C 48.555828 43.109609 48.367906 42.504047 47.878906 42.248047 C 47.756156 42.183297 47.625672 42.147422 47.496094 42.136719 z" />
    </Svg>
  );
}

export function OrcaIcon(props) {
  return (
    <Svg  {...props} viewBox="0 0 100 100">
      <path d="M 63.212891 13.949219 C 62.480592 13.948713 61.728578 13.966891 60.955078 14.001953 C 53.588078 14.336953 47.097656 16.004547 42.097656 18.810547 C 32.973656 11.796547 23.325719 15.744172 20.261719 18.701172 C 18.770719 20.140172 19.113219 21.099969 19.449219 21.542969 C 19.986219 22.248969 20.870531 22.558969 21.894531 22.917969 C 24.110531 23.695969 27.430813 24.876062 29.882812 30.914062 C 20.905812 45.618063 20.333406 66.019391 21.441406 70.775391 C 18.508406 71.945391 10.039062 75.940781 10.039062 83.050781 L 10.039062 83.25 L 10.115234 83.433594 C 10.178234 83.587594 10.778172 84.944563 12.201172 85.226562 C 12.368172 85.259563 12.537031 85.275391 12.707031 85.275391 C 13.648031 85.275391 14.633578 84.766813 15.642578 83.757812 C 16.168578 83.231813 18.319875 83.076172 20.046875 82.951172 C 22.411875 82.780172 25.176047 82.575516 26.623047 81.353516 C 28.070047 82.575516 30.834219 82.780172 33.199219 82.951172 C 34.727219 83.062172 36.587375 83.195844 37.359375 83.589844 C 37.615375 84.959844 38.819719 86 40.261719 86 C 41.886719 86 43.207031 84.678734 43.207031 83.052734 C 43.207031 75.804734 34.413438 71.795844 31.648438 70.714844 C 34.728437 52.729844 44.076422 45.578297 51.732422 42.779297 C 51.063422 46.184297 49.696922 49.265781 49.169922 50.050781 C 48.519922 51.018781 48.890078 51.691547 49.080078 51.935547 C 49.434078 52.392547 50.086891 52.554687 50.837891 52.554688 C 52.170891 52.554688 53.8185 52.039469 54.6875 51.730469 C 60.6045 49.625469 64.500656 46.084437 66.472656 41.023438 L 70.021484 41 C 82.423484 40.999 89.891031 41.0075 89.957031 33.0625 C 89.982031 29.9875 88.17975 25.122547 84.09375 21.185547 C 80.6025 17.821797 74.197366 13.95681 63.212891 13.949219 z M 63.173828 15.947266 C 73.519675 15.946112 79.481094 19.515234 82.707031 22.623047 C 86.896031 26.660047 87.974984 31.205922 87.958984 33.044922 C 87.952984 33.785922 87.864359 34.429047 87.693359 34.998047 L 84.029297 34.998047 C 83.753297 34.998047 83.529297 35.222047 83.529297 35.498047 C 83.529297 35.774047 83.753297 35.998047 84.029297 35.998047 L 87.238281 35.998047 C 85.533281 38.786047 80.565187 39 70.367188 39 C 70.254188 39 67.140625 39.017578 67.140625 39.017578 C 67.399625 38.060578 67.594328 37.051047 67.736328 35.998047 L 80.5 35.998047 C 80.776 35.998047 81 35.774047 81 35.498047 C 81 35.222047 80.776 35 80.5 35 L 67.849609 35 C 67.942609 34.035 68 33.042 68 32 C 68 31.448 67.553 31 67 31 C 66.447 31 66 31.448 66 32 C 66 41.267 62.192578 46.938656 54.017578 49.847656 C 53.006578 50.206656 51.913453 50.451156 51.189453 50.535156 C 52.680453 47.649156 56.759344 37.343109 51.652344 32.287109 C 51.260344 31.897109 50.628281 31.902922 50.238281 32.294922 C 49.849281 32.687922 49.853094 33.319984 50.246094 33.708984 C 51.913094 35.359984 52.276922 37.94975 52.044922 40.59375 C 51.983922 40.60175 51.922328 40.595234 51.861328 40.615234 C 43.458328 43.422234 32.775594 50.982687 29.558594 71.054688 L 27.089844 75.994141 L 26.626953 76.921875 L 24.068359 71.806641 C 24.271359 69.457641 24.791141 66.762828 25.619141 63.923828 C 25.697141 63.658828 25.545297 63.381688 25.279297 63.304688 C 25.015297 63.225687 24.736156 63.379531 24.660156 63.644531 C 24.016156 65.850531 23.558344 67.972641 23.277344 69.931641 C 22.674344 65.990641 22.717313 46.328109 31.695312 31.787109 C 33.216313 29.531109 35.021406 27.329203 36.941406 25.408203 C 37.136406 25.213203 37.136406 24.896172 36.941406 24.701172 C 36.746406 24.506172 36.429375 24.506172 36.234375 24.701172 C 34.605375 26.331172 33.060453 28.161734 31.689453 30.052734 C 28.899453 23.277734 24.949547 21.87125 22.560547 21.03125 C 22.083547 20.86425 21.596875 20.694391 21.296875 20.525391 C 21.802875 19.858391 23.597094 18.440312 26.496094 17.570312 C 29.448094 16.686312 35.237234 15.926078 41.115234 20.580078 C 40.355234 21.107078 39.596797 21.6845 38.841797 22.3125 C 38.629797 22.4895 38.600344 22.805578 38.777344 23.017578 C 38.876344 23.136578 39.019109 23.197266 39.162109 23.197266 C 39.275109 23.197266 39.389422 23.158078 39.482422 23.080078 C 40.472422 22.256078 41.468938 21.526719 42.460938 20.886719 C 42.468938 20.882719 42.476375 20.874141 42.484375 20.869141 C 42.486375 20.868141 42.488234 20.866234 42.490234 20.865234 C 42.497234 20.861234 42.504719 20.861422 42.511719 20.857422 C 47.302719 18.010422 53.712875 16.329094 61.046875 15.996094 C 61.776063 15.963094 62.484105 15.947343 63.173828 15.947266 z M 75.5 24 C 72.935 24 71 25.075 71 26.5 C 71 27.925 72.935 29 75.5 29 C 78.065 29 80 27.925 80 26.5 C 80 25.075 78.065 24 75.5 24 z M 75.5 25 C 77.503 25 79 25.792 79 26.5 C 79 27.208 77.503 28 75.5 28 C 73.497 28 72 27.208 72 26.5 C 72 25.792 73.497 25 75.5 25 z M 47.96875 35.207031 C 45.94775 35.445031 43.932422 35.890297 41.982422 36.529297 C 41.719422 36.615297 41.576109 36.897156 41.662109 37.160156 C 41.731109 37.370156 41.928672 37.505859 42.138672 37.505859 C 42.190672 37.505859 42.243922 37.497469 42.294922 37.480469 C 44.182922 36.862469 46.129938 36.432172 48.085938 36.201172 C 48.359938 36.169172 48.556437 35.920484 48.523438 35.646484 C 48.490437 35.372484 48.23775 35.170031 47.96875 35.207031 z M 38.654297 37.878906 C 38.589484 37.881547 38.524891 37.896281 38.462891 37.925781 C 32.816891 40.582781 28.66825 44.752297 29.40625 47.029297 C 29.71725 47.987297 30.503219 48.746859 31.699219 49.255859 C 30.358219 50.625859 29.120484 52.762828 28.271484 54.423828 C 28.145484 54.669828 28.244234 54.971656 28.490234 55.097656 C 28.563234 55.134656 28.64075 55.152344 28.71875 55.152344 C 28.90075 55.152344 29.073109 55.052859 29.162109 54.880859 C 30.487109 52.287859 31.838844 50.359125 32.964844 49.453125 C 33.109844 49.336125 33.176625 49.149797 33.140625 48.966797 C 33.104625 48.783797 32.970016 48.636984 32.791016 48.583984 C 31.869016 48.312984 30.697422 47.770703 30.357422 46.720703 C 29.923422 45.382703 33.105672 41.554031 38.888672 38.832031 C 39.138672 38.714031 39.244953 38.416016 39.126953 38.166016 C 39.039953 37.977766 38.848734 37.870984 38.654297 37.878906 z M 62.970703 38.728516 C 62.775937 38.730625 62.592422 38.845859 62.513672 39.037109 C 62.260672 39.649109 61.968484 40.248359 61.646484 40.818359 C 61.510484 41.059359 61.595938 41.363 61.835938 41.5 C 61.913938 41.543 61.998031 41.564453 62.082031 41.564453 C 62.256031 41.564453 62.425578 41.473547 62.517578 41.310547 C 62.859578 40.704547 63.1695 40.067969 63.4375 39.417969 C 63.5425 39.162969 63.420062 38.870625 63.164062 38.765625 C 63.100062 38.739625 63.035625 38.727812 62.970703 38.728516 z M 60.4375 42.865234 C 60.309625 42.875109 60.186656 42.933563 60.097656 43.039062 C 59.056656 44.262062 57.807719 45.284125 56.386719 46.078125 C 56.145719 46.213125 56.060313 46.517766 56.195312 46.759766 C 56.287312 46.923766 56.457813 47.015625 56.632812 47.015625 C 56.715812 47.015625 56.799953 46.995125 56.876953 46.953125 C 58.400953 46.100125 59.741375 45.003453 60.859375 43.689453 C 61.038375 43.479453 61.012734 43.163375 60.802734 42.984375 C 60.698234 42.895375 60.565375 42.855359 60.4375 42.865234 z M 27.716797 56.267578 C 27.522172 56.263594 27.3355 56.376203 27.25 56.564453 C 26.742 57.704453 26.254734 58.911297 25.802734 60.154297 C 25.707734 60.414297 25.841563 60.701875 26.101562 60.796875 C 26.158562 60.817875 26.216437 60.826172 26.273438 60.826172 C 26.477438 60.826172 26.668188 60.699094 26.742188 60.496094 C 27.186187 59.275094 27.664062 58.089656 28.164062 56.972656 C 28.275063 56.719656 28.162156 56.4255 27.910156 56.3125 C 27.847156 56.284 27.781672 56.268906 27.716797 56.267578 z M 31.013672 72.619141 C 33.553672 73.641141 41.207031 77.205734 41.207031 83.052734 C 41.207031 83.574734 40.783719 84 40.261719 84 C 39.739719 84 39.3125 83.575734 39.3125 83.052734 L 39.3125 82.638672 L 39.019531 82.345703 C 37.966531 81.292703 35.825703 81.136031 33.345703 80.957031 C 30.919703 80.781031 27.929484 80.565609 27.646484 79.349609 L 27.857422 78.927734 L 27.859375 78.925781 L 31.013672 72.619141 z M 22.201172 72.632812 L 25.369141 78.880859 L 25.603516 79.349609 C 25.320516 80.565609 22.330297 80.781031 19.904297 80.957031 C 17.425297 81.136031 15.283469 81.292703 14.230469 82.345703 C 13.575469 83.002703 12.980609 83.342578 12.599609 83.267578 C 12.355609 83.222578 12.155922 82.9845 12.044922 82.8125 C 12.248922 77.1315 19.663172 73.657813 22.201172 72.632812 z" />
    </Svg>
  );
}

export function WhaleIcon(props) {
  return (
    <Svg {...props} viewBox="0 0 512 512" >
      <g transform="translate(-40, -90) scale(1.2)">
        <path d="M 353.93945 105.00586 A 5.652 5.652 0 0 0 348.55859 108.40039 C 344.86659 116.88739 333.8292 146.57836 346.7832 172.31836 C 354.4832 187.62536 369.13489 198.51816 390.33789 204.78516 C 371.95389 229.19216 350.92561 242.99148 325.47461 247.39648 C 327.42361 241.98448 327.99386 234.62544 324.25586 225.27344 A 6.276 6.276 0 0 0 313.41602 223.82227 C 301.25102 239.98727 283.25727 245.32147 279.19727 246.35547 C 254.72927 242.01047 229.16942 232.78411 204.48242 222.91211 C 175.18242 211.19311 141.00983 208.18661 102.92383 213.97461 C 71.472828 218.75461 44.006906 228.55459 26.503906 235.93359 A 25.137 25.137 0 0 0 12.490234 250.71289 A 25.779 25.779 0 0 0 13.724609 270.61133 A 185.727 185.727 0 0 0 63.064453 333.26953 A 183.133 183.133 0 0 0 116.38867 363.48047 C 111.28867 369.75647 106.14975 381.29786 109.71875 401.13086 C 110.59475 407.09886 118.95741 409.10753 122.44141 404.14453 C 128.60541 395.91453 145.12309 376.69328 165.87109 374.98828 C 170.18909 375.48961 174.56967 375.88073 179.01367 376.16406 C 187.32167 376.69006 195.55174 376.95251 203.70508 376.95117 C 235.60508 376.95117 265.98808 372.92923 292.83008 365.11523 C 308.68208 376.59023 337.26341 385.7842 355.06641 385.7832 A 28.944 28.944 0 0 0 365.25781 384.2832 A 9.617 9.617 0 0 0 369.81055 370.01367 A 169.31 169.31 0 0 0 345.7207 341.41406 C 368.7737 326.82306 387.29169 308.17481 400.80469 285.88281 A 173.84 173.84 0 0 0 423.66406 222.11719 A 109.111 109.111 0 0 0 438.23438 223.14648 C 454.91737 223.14648 468.59597 218.69031 479.04297 209.82031 C 499.18497 192.72031 501.10509 164.24487 500.99609 152.79688 A 5.675 5.675 0 0 0 494.24414 147.28711 A 5.625 5.625 0 0 0 489.98242 151.06055 C 484.35542 167.03855 464.74878 166.17061 453.55078 164.22461 C 439.83378 161.84461 430.17525 164.33214 423.40625 168.49414 C 420.43525 158.45414 411.95911 143.04392 387.78711 137.41992 C 376.70111 134.84092 358.26986 127.97953 359.38086 111.01953 A 5.652 5.652 0 0 0 353.93945 105.00586 z M 352.90234 126.43945 C 357.20234 134.38845 366.40253 142.7102 385.51953 147.1582 C 410.40853 152.9492 414.28853 170.62808 414.89453 176.08008 A 36.477 36.477 0 0 0 409.79492 184.81445 A 14.242 14.242 0 0 0 399.48438 191.43359 C 398.48438 193.03359 397.47012 194.58814 396.45312 196.11914 C 376.19912 190.79914 362.49984 181.29931 355.71484 167.82031 C 353.39984 163.22031 347.41434 148.35845 352.90234 126.43945 z M 489.89648 167.77148 C 488.10548 179.03848 483.58131 192.85122 472.57031 202.19922 C 461.47031 211.62122 445.46989 214.97322 424.96289 212.19922 C 425.40089 208.05322 425.7193 203.85361 425.91797 199.59961 A 14.338 14.338 0 0 0 419.56641 187.09961 C 422.35141 180.96761 430.3618 170.34998 451.8418 174.08398 C 471.1228 177.43098 482.82548 173.38448 489.89648 167.77148 z M 411.71094 194.61523 C 412.49423 194.6206 413.25406 194.86717 413.91406 195.32617 A 4.2 4.2 0 0 1 415.30664 200.20508 L 415.30664 200.20703 C 388.20664 274.63103 334.65031 314.00617 322.07031 322.45117 A 167.614 167.614 0 0 0 270.69922 299.4707 A 5 5 0 1 0 268.19922 309.15039 C 322.89922 323.27439 352.89936 362.68023 361.19336 375.11523 C 350.51836 378.55323 311.34584 368.6927 295.33984 354.3457 C 276.86484 337.7807 260.48606 338.63186 246.03906 339.38086 A 93.715 93.715 0 0 1 230.4668 339.33984 C 221.5468 338.31584 215.9938 335.52859 213.9668 331.05859 C 210.4988 323.42559 216.99397 311.2202 219.79297 307.1582 A 5.0010489 5.0010489 0 0 0 211.57422 301.45703 A 55.5 55.5 0 0 0 204.16211 317.39062 A 53.5 53.5 0 0 1 184.86133 307.88281 C 160.21933 289.07681 129.98669 277.83781 97.429688 275.38281 C 53.347687 272.05381 30.371203 257.08922 23.158203 251.44922 A 15.2 15.2 0 0 1 30.388672 245.14453 C 47.367672 237.98553 73.994781 228.48242 104.42578 223.85742 C 140.72578 218.33942 173.14053 221.14436 200.76953 232.19336 C 238.96953 247.46736 279.32194 261.25053 315.71094 258.64453 C 353.41994 255.94453 383.59589 235.69837 407.96289 196.73438 C 409.03664 195.26875 410.40545 194.6063 411.71094 194.61523 z M 410.90625 235.0293 A 160.391 160.391 0 0 1 392.25391 280.69922 C 379.09191 302.41422 360.83733 320.47522 337.98633 334.44922 C 335.69499 332.50389 333.28639 330.56791 330.76172 328.64258 A 240.243 240.243 0 0 0 363.25195 300.75977 A 274.465 274.465 0 0 0 410.90625 235.0293 z M 316.75195 235.36523 C 317.71395 241.87123 315.50117 246.19462 313.32617 248.76562 A 125.823 125.823 0 0 1 299.53906 248.76562 A 72.065 72.065 0 0 0 316.75195 235.36523 z M 21.378906 262.55273 C 32.613906 270.15273 56.411734 282.31552 96.677734 285.35352 C 127.29973 287.66552 155.69788 298.20303 178.79688 315.83203 A 63.079 63.079 0 0 0 203.00781 327.42383 A 21.666 21.666 0 0 0 204.84766 335.16602 C 208.42566 343.07102 216.66112 347.81744 229.32812 349.27344 A 102.7 102.7 0 0 0 246.56055 349.36523 C 258.62955 348.73823 270.11278 348.14763 283.17578 357.39062 C 252.36578 365.36362 216.02748 368.4915 179.64648 366.1875 L 179.64258 366.1875 C 136.14258 363.4315 99.049719 349.75134 69.386719 325.52734 A 175.68 175.68 0 0 1 22.490234 265.77539 A 15.252 15.252 0 0 1 21.378906 262.55273 z M 165.01367 266.56445 A 11 11 0 1 0 176.01367 277.56445 A 11.012 11.012 0 0 0 165.01367 266.56445 z M 126.90039 367.00195 C 132.53972 368.71395 138.31766 370.19841 144.23633 371.45508 C 133.21133 377.37608 124.39922 386.13927 118.69922 392.82227 C 117.40522 376.38327 123.88539 369.35295 126.90039 367.00195 z" />
      </g>
    </Svg>
  );
}

/**
 * Returns the correct icon component for a given staker level name.
 */
export function stakerLevelIconFor(levelName) {
  const name = String(levelName || "").trim().toLowerCase();
  switch (name) {
    case "clam": return ClamIcon;
    case "shrimp": return ShrimpIcon;
    case "seahorse": return SeahorseIcon;
    case "fish": return FishIcon;
    case "dolphin": return DolphinIcon;
    case "shark": return SharkIcon;
    case "stingray": return StingrayIcon;
    case "orca": return OrcaIcon;
    case "whale": return WhaleIcon;
    default: return null;
  }
}
</file>

<file path="src/components/ui/icons/ProfileIcons.jsx">
// src/components/ui/icons/ProfileIcons.jsx
const Svg = (props) => (
  <svg
    viewBox="0 0 24 24"
    fill="none"
    stroke="currentColor"
    stroke-width="2"
    stroke-linecap="round"
    stroke-linejoin="round"
    {...props}
  >
    {props.children}
  </svg>
);

export function PostsIcon(props) {
  return (
    <Svg {...props}>
      <path d="M4 6h16M4 12h16M4 18h16" />
    </Svg>
  );
}

export function SubscribersIcon(props) {
  return (
    <Svg {...props}>
      <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" />
      <circle cx="9" cy="7" r="4" />
      <path d="M23 21v-2a4 4 0 0 0-3-3.87" />
      <path d="M16 3.13a4 4 0 0 1 0 7.75" />
    </Svg>
  );
}

export function SubscriptionsIcon(props) {
  return (
    <Svg {...props}>
      <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" />
      <circle cx="9" cy="7" r="4" />
      <line x1="19" y1="8" x2="19" y2="14" />
      <line x1="22" y1="11" x2="16" y2="11" />
    </Svg>
  );
}

export function WalletIcon(props) {
  return (
    <Svg {...props}>
      <path d="M18 8V7.2C18 6.0799 18 5.51984 17.782 5.09202C17.5903 4.71569 17.2843 4.40973 16.908 4.21799C16.4802 4 15.9201 4 14.8 4H6.2C5.07989 4 4.51984 4 4.09202 4.21799C3.71569 4.40973 3.40973 4.71569 3.21799 5.09202C3 5.51984 3 6.0799 3 7.2V8M21 12H19C17.8954 12 17 12.8954 17 14C17 15.1046 17.8954 16 19 16H21M3 8V16.8C3 17.9201 3 18.4802 3.21799 18.908C3.40973 19.2843 3.71569 19.5903 4.09202 19.782C4.51984 20 5.07989 20 6.2 20H17.8C18.9201 20 19.4802 20 19.908 19.782C20.2843 19.5903 20.5903 19.2843 20.782 18.908C21 18.4802 21 17.9201 21 16.8V11.2C21 10.0799 21 9.51984 20.782 9.09202C20.5903 8.71569 20.2843 8.40973 19.908 8.21799C19.4802 8 18.9201 8 17.8 8H3Z"></path>
    </Svg>
  );
}
</file>

<file path="src/components/ui/ContextMenu.jsx">
// src/components/ui/ContextMenu.jsx
import { createSignal, onMount, onCleanup, Show, For } from "solid-js";

function MoreIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-5 h-5"} fill="currentColor">
      <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" />
    </svg>
  );
}

export default function ContextMenu(props) {
  const [isOpen, setIsOpen] = createSignal(false);
  const [menuClass, setMenuClass] = createSignal("bottom-full right-0 mb-2"); // Default: above
  let containerRef;

  const handleClickOutside = (event) => {
    if (containerRef && !containerRef.contains(event.target)) {
      setIsOpen(false);
    }
  };

  onMount(() => document.addEventListener("mousedown", handleClickOutside));
  onCleanup(() => document.removeEventListener("mousedown", handleClickOutside));

  const handleItemClick = (e, item) => {
    e.preventDefault();
    e.stopPropagation();
    item.onClick?.();
    setIsOpen(false);
  };

  const positionClass = props.positionClass || "absolute -bottom-2 -right-2 z-20";

  const toggleMenu = () => {
    const shouldOpen = !isOpen();

    if (shouldOpen && containerRef) {
      const buttonRect = containerRef.getBoundingClientRect();
      const estimatedMenuHeight = 150; // A safe estimate for the menu's height in pixels

      // If there's not enough space above the button, show the menu below it.
      if (buttonRect.top < estimatedMenuHeight) {
        setMenuClass("top-full right-0 mt-2"); // Position below
      } else {
        setMenuClass("bottom-full right-0 mb-2"); // Position above (default)
      }
    }
    setIsOpen(shouldOpen);
  };

  return (
    <div class={positionClass} ref={containerRef}>
      <button
        class="p-1 rounded-full bg-[hsl(var(--background))] border border-[hsl(var(--border))] text-[hsl(var(--muted-foreground))] hover:bg-[hsl(var(--accent))] hover:text-[hsl(var(--foreground))]"
        onClick={(e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleMenu();
        }}
        aria-haspopup="true"
        aria-expanded={isOpen()}
      >
        <MoreIcon />
      </button>

      <Show when={isOpen()}>
        <div
          class={`absolute w-48 rounded-md shadow-lg bg-[hsl(var(--popover))] text-[hsl(var(--popover-foreground))] ring-1 ring-black ring-opacity-5 ${menuClass()}`}
        >
          <ul class="py-1" role="menu">
            <For each={props.items}>
              {(item) => (
                <li>
                  <a
                    href="#"
                    class="block w-full text-left px-4 py-2 text-sm hover:bg-[hsl(var(--accent))]"
                    onClick={(e) => handleItemClick(e, item)}
                  >
                    {item.label}
                  </a>
                </li>
              )}
            </For>
          </ul>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/ui/PostTime.jsx">
// src/components/ui/PostTime.jsx
import { createMemo } from "solid-js";
import { useApp } from "../../context/AppContext";

const MINUTE = 60;
const HOUR = MINUTE * 60;
const DAY = HOUR * 24;
const WEEK = DAY * 7;

// Technical comments for the i18n script. Do not remove.
// t("time.minute.singular")
// t("time.minute.plural")
// t("time.hour.singular")
// t("time.hour.plural")
// t("time.day.singular")
// t("time.day.plural")

export default function PostTime(props) {
  const { t, lang } = useApp();

  const parsedDate = createMemo(() => {
    const ts = props.timestamp;
    if (!ts) return null;
    const d = new Date(ts);
    return isNaN(d.getTime()) ? null : d;
  });

  const fullDateTime = createMemo(() => {
    const d = parsedDate();
    if (!d) return "";
    return new Intl.DateTimeFormat(lang(), {
      dateStyle: 'long',
      // timeStyle: 'short',
    }).format(d);
  });

  const shortDate = createMemo(() => {
    const d = parsedDate();
    if (!d) return "";
    return new Intl.DateTimeFormat(lang(), {
      year: '2-digit',
      month: '2-digit',
      day: '2-digit',
    }).format(d);
  });

  const displayText = createMemo(() => {
    const d = parsedDate();
    if (!d) return "";

    if (props.format === 'short') {
      return shortDate();
    }

    // Default to 'long' format (relative time)
    const now = new Date();
    const diffSeconds = Math.round((now.getTime() - d.getTime()) / 1000);

    if (diffSeconds < MINUTE) {
      return t("time.now");
    }
    if (diffSeconds < HOUR) {
      const n = Math.floor(diffSeconds / MINUTE);
      const key = n === 1 ? "time.minute.singular" : "time.minute.plural";
      return t(key, { n });
    }
    if (diffSeconds < DAY) {
      const n = Math.floor(diffSeconds / HOUR);
      const key = n === 1 ? "time.hour.singular" : "time.hour.plural";
      return t(key, { n });
    }
    if (diffSeconds < WEEK) {
      const n = Math.floor(diffSeconds / DAY);
      const key = n === 1 ? "time.day.singular" : "time.day.plural";
      return t(key, { n });
    }

    return fullDateTime();
  });

  return (
    <div
      class="text-xs text-[hsl(var(--muted-foreground))]"
      title={fullDateTime()}
    >
      {displayText()}
    </div>
  );
}
</file>

<file path="src/components/ui/StakerLevelIcon.jsx">
// src/components/ui/StakerLevelIcon.jsx
import { createMemo, Show, splitProps } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { stakerLevelIconFor } from "./icons/FishIcons.jsx";
import { formatUnits } from "viem";

const STAKER_LEVELS = [
    { min: 0, key: "guest" }, 
    { min: 5000, key: "clam" }, 
    { min: 10000, key: "shrimp" }, 
    { min: 20000, key: "seahorse" }, 
    { min: 50000, key: "fish" }, 
    { min: 100000, key: "dolphin" }, 
    { min: 200000, key: "shark" }, 
    { min: 500000, key: "stingray" }, 
    { min: 1000000, key: "orca" }, 
    { min: 10000000, key: "whale" }, 
];

function getStakerLevel(levels, stakedAmount) {
    if (!Array.isArray(levels) || levels.length === 0) return null;
    try {
        const staked = formatUnits(BigInt(stakedAmount || 0), 18);
        const stakedNum = parseFloat(staked);
        let bestLevel = null;
        for (const level of levels) {
            if (stakedNum >= level.min) {
                bestLevel = level;
            }
        }
        return bestLevel;
    } catch (e) { return null; }
}

function formatStakeAmount(num) {
    if (num >= 1_000_000) return `${num / 1_000_000}M`;
    if (num >= 1_000) return `${num / 1_000}K`;
    return String(num);
}

export default function StakerLevelIcon(props) {
    const [local, rest] = splitProps(props, ["staked", "class"]);
    const app = useApp();

    const level = createMemo(() => getStakerLevel(STAKER_LEVELS, local.staked));

    const tooltipText = createMemo(() => {
        const l = level();
        if (!l) return "";
        const name = app.t(`stakerLevels.${l.key}`);
        if (l.min > 0) {
            return `${name} > ${formatStakeAmount(l.min)}`;
        }
        return name;
    });

    const IconComponent = createMemo(() => {
        const key = level()?.key;
        return key ? stakerLevelIconFor(key) : null;
    });

    return (
        <Show when={IconComponent()}>
            {(getIcon) => {
                const Icon = getIcon();
                return (
                    <span title={tooltipText()}>
                        <Icon
                            {...rest}
                            class={local.class || "w-4 h-4 text-[hsl(var(--muted-foreground))]"}
                        />
                    </span>
                );
            }}
        </Show>
    );
}
</file>

<file path="src/components/ui/Tabs.jsx">
// src/components/ui/Tabs.jsx
import { For, createSignal, onMount, onCleanup } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

export default function Tabs(props) {
  const app = useApp();
  const { t } = app;

  const items = () => props.items || [];
  const value = () => props.value;
  const [compact, setCompact] = createSignal(false);

  onMount(() => {
    // Parse the prop more robustly.
    const compactWidth = parseInt(props.compactWidth, 10);

    // Check if we received a valid number and enable the feature.
    if (!isNaN(compactWidth) && compactWidth > 0) {
      console.log(`[Tabs] Responsive mode enabled with width: ${compactWidth}`);

      const checkWidth = () => {
        setCompact(window.innerWidth <= compactWidth);
      };

      checkWidth(); // Run on initial mount
      window.addEventListener("resize", checkWidth, { passive: true });
      onCleanup(() => window.removeEventListener("resize", checkWidth));
    } else {
      console.log("[Tabs] Responsive mode disabled (compactWidth prop not provided or invalid).");
    }
  });

  return (
    <ul
      class={`tabs ${props.class || ""}`}
      role="tablist"
      aria-label={t("tabs.aria")}
      data-compact={compact() ? "true" : "false"}
    >
      <For each={items()}>
        {(it) => {
          const active = () => it.id === value();
          const disabled = !!it.disabled;
          const tabId = `tab-${it.id}`;

          const onClick = (e) => {
            e.preventDefault();
            if (disabled || active()) return;
            props.onChange?.(it.id);
          };

          const onKeyDown = (e) => {
            if (disabled) return;
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              if (!active()) props.onChange?.(it.id);
            }
          };

          return (
            <li classList={{ active: active() }} role="presentation" aria-selected={active()}>
              <a
                id={tabId}
                href="#"
                role="tab"
                aria-selected={active() ? "true" : "false"}
                aria-disabled={disabled ? "true" : "false"}
                aria-label={it.label}
                title={it.label}
                tabIndex={disabled ? -1 : 0}
                onClick={onClick}
                onKeyDown={onKeyDown}
              >
                {it.icon ? <span class="tab__icon" aria-hidden="true">{it.icon}</span> : null}
                <span class="tab__label">{it.label}</span>
              </a>
            </li>
          );
        }}
      </For>
    </ul>
  );
}
</file>

<file path="src/components/ui/ViewModeToggle.jsx">
// src/components/ui/ViewModeToggle.jsx
import { createSignal } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";

// ── Global view mode (list|grid), persisted ───────────────────────────────────
const VIEW_KEY = "content_list_view_mode"; // match your simple style like `lang`, `theme`

function readInitial() {
  let initial = "grid"; // default = grid
  try {
    const v = localStorage.getItem(VIEW_KEY);
    if (v === "list" || v === "grid") initial = v;
    else localStorage.setItem(VIEW_KEY, initial); // write default once so key appears
  } catch {}
  return initial;
}

const [viewMode, setViewModeSignal] = createSignal(readInitial());

function setViewMode(next) {
  const v = next === "list" ? "list" : "grid";
  setViewModeSignal(v);
  try { localStorage.setItem(VIEW_KEY, v); } catch {}
}

// cross‑tab sync
if (typeof window !== "undefined") {
  window.addEventListener("storage", (e) => {
    if (e.key === VIEW_KEY && (e.newValue === "list" || e.newValue === "grid")) {
      setViewModeSignal(e.newValue);
    }
  });
}

// ── Provided SVGs (paths untouched), just color/size inherit ──────────────────
function ListIcon(props) {
  return (
    <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"
         width={props.size || "1.25em"} height={props.size || "1.25em"}
         fill="none" stroke="currentColor" stroke-width="2"
         stroke-linecap="round" stroke-linejoin="round" class={props.class}>
      <path d="M8 6L21 6.00078M8 12L21 12.0008M8 18L21 18.0007M3 6.5H4V5.5H3V6.5ZM3 12.5H4V11.5H3V12.5ZM3 18.5H4V17.5H3V18.5Z" />
    </svg>
  );
}
function GridIcon(props) {
  return (
    <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"
         width={props.size || "1.25em"} height={props.size || "1.25em"}
         fill="currentColor" class={props.class}>
      <path fill-rule="evenodd" clip-rule="evenodd"
            d="M7 1H1V7H7V1ZM7 9H1V15H7V9ZM9 1H15V7H9V1ZM15 9H9V15H15V9Z" />
    </svg>
  );
}

/**
 * Compact toggle for list/grid view mode.
 * If value/onChange are not provided, uses the global viewMode above.
 */
export default function ViewModeToggle(props) {
  const { t } = useApp();
  const controlled = typeof props.value !== "undefined" && typeof props.onChange === "function";

  const current = () => (controlled ? (props.value === "list" ? "list" : "grid") : viewMode());
  const change = (next) => (controlled ? props.onChange(next) : setViewMode(next));

  const size = props.size === "sm" ? { box: "h-8 w-8", icon: "w-4 h-4" } : { box: "h-9 w-9", icon: "w-5 h-5" };
  const btnCls = (active) =>
    `inline-flex items-center justify-center ${size.box} rounded-md border transition-colors ` +
    (active
      ? "bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] border-[hsl(var(--primary))]"
      : "bg-[hsl(var(--muted))] text-[hsl(var(--foreground))] border-[hsl(var(--border))] hover:bg-[hsl(var(--accent))]");

  return (
    <div class={`inline-flex items-center gap-2 ${props.class || ""}`} role="group" aria-label={t("newTab.view.group")}>
      <button
        type="button"
        class={btnCls(current() === "list")}
        onClick={() => change("list")}
        aria-pressed={current() === "list" ? "true" : "false"}
        aria-label={t("newTab.view.list")}
        title={t("newTab.view.list")}
      >
        <ListIcon class={size.icon} />
      </button>
      <button
        type="button"
        class={btnCls(current() === "grid")}
        onClick={() => change("grid")}
        aria-pressed={current() === "grid" ? "true" : "false"}
        aria-label={t("newTab.view.grid")}
        title={t("newTab.view.grid")}
      >
        <GridIcon class={size.icon} />
      </button>
    </div>
  );
}

export { viewMode, setViewMode };
</file>

<file path="src/components/widgets/ContentListBlock.jsx">
// src/components/widgets/ContentListBlock.jsx
import { createMemo, createResource, For, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { loadAssetResource } from "../../utils/assetLoader";
import PostCard from "../feed/PostCard.jsx";
import Spinner from "../ui/Spinner.jsx";
import { toChecksumAddress } from "../../blockchain/utils.js";

function getLocalizedTitle(titleData, currentLang) {
    if (!titleData || typeof titleData !== 'object') return "";
    if (titleData[currentLang]) return titleData[currentLang];
    if (titleData['*']) return titleData['*'];
    if (titleData.en) return titleData.en;
    const firstKey = Object.keys(titleData)[0];
    return firstKey ? titleData[firstKey] : "";
}

async function fetchListContent(params) {
  const { app, listName, count, lang } = params;
  if (!app.wsMethod || !listName) return [];
  
  const getList = app.wsMethod("get-list");
  
  const requestParams = {
    domain: app.selectedDomainName(),
    list_name: listName,
    limit: count || 5,
    offset: 0,
    lang: lang,
  };

  const user = app.authorizedUser();
  if (user?.address) {
    requestParams.my_addr = toChecksumAddress(user.address);
  }

  try {
    const res = await getList(requestParams);
    const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];
    return arr.map((it) => ({
      id: it?.savva_cid || it?.savvaCID || it?.id,
      _raw: it,
    }));
  } catch (err) {
    console.error(`Failed to fetch content list '${listName}':`, err);
    return { error: err.message }; 
  }
}

export default function ContentListBlock(props) {
  const app = useApp();
  const modulePath = createMemo(() => app.domainAssetsConfig?.()?.modules?.content_lists);

  const [contentListModule] = createResource(modulePath, async (path) => {
    if (!path) return null;
    try {
      return await loadAssetResource(app, path, { type: 'yaml' });
    } catch (e) {
      console.error(`Failed to load content list module from ${path}`, e);
      return null;
    }
  });
  
  const listDefinition = createMemo(() => {
    const listName = props.block?.list_name;
    if (!listName) return null;
    return contentListModule()?.list?.[listName] || null;
  });

  const title = createMemo(() => {
    const def = listDefinition();
    return getLocalizedTitle(def?.title, app.lang());
  });

  const [listData] = createResource(() => ({
    app: app,
    listName: props.block?.list_name,
    count: props.block?.count,
    lang: app.lang()
  }), fetchListContent);

  return (
    <div class="p-3 rounded-lg" style={{ background: "var(--gradient)" }}>
      <h4 class="font-semibold text-sm mb-2 text-[hsl(var(--card))]">{title() || props.block?.list_name}</h4>
      <div class="space-y-3">
        <Show when={listData.loading}>
          <div class="flex justify-center items-center h-24">
            <Spinner />
          </div>
        </Show>
        <Show when={listData.error}>
          <p class="text-xs text-[hsl(var(--destructive))]">
            {app.t("common.error")}: {listData.error}
          </p>
        </Show>
        <Show when={!listData.loading && !listData.error && listData()?.length > 0}>
          <For each={listData()}>
            {(item) => {
              const menuItems = item._raw?.pinned
                ? [{ label: "Unpin Post", onClick: () => console.log("Unpin clicked for:", item.id) }]
                : [{ label: "Pin Post", onClick: () => console.log("Pin clicked for:", item.id) }];
              
              return (
                <PostCard
                  item={item}
                  mode="list"
                  compact={true}
                  contextMenuItems={menuItems}
                />
              );
            }}
          </For>
        </Show>
      </div>
    </div>
  );
}
</file>

<file path="src/components/widgets/HtmlBlock.jsx">
// src/components/widgets/HtmlBlock.jsx
import { createMemo, createResource } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { loadAssetResource } from "../../utils/assetLoader";

/**
 * Selects the best path from a block's locale object.
 * Logic: current lang -> '*' -> 'en' -> first available.
 */
function getLocalizedPath(block, currentLang) {
  if (!block || typeof block !== 'object') return null;
  
  if (block[currentLang]) return block[currentLang];
  if (block['*']) return block['*'];
  if (block.en) return block.en;
  
  // Fallback to the first key that isn't 'type'
  const fallbackKey = Object.keys(block).find(k => k !== 'type');
  return fallbackKey ? block[fallbackKey] : null;
}

export default function HtmlBlock(props) {
  const app = useApp();
  const path = createMemo(() => getLocalizedPath(props.block, app.lang()));
  
  const [htmlContent] = createResource(path, async (p) => {
    if (!p) return "";
    try {
      return await loadAssetResource(app, p, { type: 'text' });
    } catch (e) {
      console.error(`Failed to load HTML block from ${p}`, e);
      return `<p class="text-red-500">Error loading content.</p>`;
    }
  });

  return (
    <div class="p-3 text-sm space-y-2 rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))]" innerHTML={htmlContent() || ""} />
  );
}
</file>

<file path="src/components/Toaster.jsx">
// src/components/Toaster.jsx
import { For, Show } from "solid-js";
import { toasts, dismissToast, toggleToast } from "../ui/toast";

const typeStyles = {
  info:    "bg-blue-600",
  success: "bg-emerald-600",
  warning: "bg-amber-600",
  error:   "bg-red-600",
};

function pretty(obj) {
  try { return JSON.stringify(obj, null, 2); } catch { return String(obj); }
}

async function copy(text) {
  try { await navigator.clipboard.writeText(text); } catch {}
}

export default function Toaster() {
  return (
    // Full-width bottom bar container; toasts align right when compact.
    // We disable pointer events on the container so it doesn't block the page,
    // and re-enable them on each toast.
    <div class="fixed inset-x-0 bottom-0 z-[1000] p-3 pointer-events-none">
      <div class="flex flex-col gap-2 items-end">
        <For each={toasts()}>
          {(t) => {
            const headerColor = typeStyles[t.type] || typeStyles.info;
            return (
              // When expanded: stretch to full width; when compact: hug right (max ~28rem)
              <div
                class={`pointer-events-auto w-full ${
                  t.expanded ? "" : "sm:w-[28rem] max-w-[92vw]"
                }`}
              >
                <div class="text-white rounded shadow overflow-hidden">
                  {/* Header bar */}
                  <div class={`flex items-center justify-between px-3 py-2 ${headerColor}`}>
                    <span class="text-sm font-medium">{t.message}</span>
                    <div class="flex items-center gap-1">
                      <Show when={t.details}>
                        <button
                          class="px-2 py-1 rounded bg-black/20 hover:bg-black/30 text-xs"
                          onClick={() => toggleToast(t.id)}
                          aria-expanded={t.expanded}
                          title={t.expanded ? "Hide details" : "Show details"}
                        >
                          {t.expanded ? "Hide" : "Details"}
                        </button>
                      </Show>
                      <button
                        class="px-2 py-1 rounded bg-black/20 hover:bg-black/30"
                        onClick={() => dismissToast(t.id)}
                        aria-label="Close notification"
                      >
                        ×
                      </button>
                    </div>
                  </div>

                  {/* Details panel — takes full width, tall & scrollable */}
                  <Show when={t.expanded && t.details}>
                    <div class="bg-gray-900 text-gray-100 px-4 py-3 max-h-[60vh] overflow-auto">
                      <pre class="whitespace-pre-wrap break-words text-[12px] leading-tight">
{pretty(t.details)}
                      </pre>
                      <div class="mt-2 flex justify-end">
                        <button
                          class="px-2 py-1 rounded bg-gray-700 hover:bg-gray-600 text-xs"
                          onClick={() => copy(pretty(t.details))}
                          title="Copy details to clipboard"
                        >
                          Copy
                        </button>
                      </div>
                    </div>
                  </Show>
                </div>
              </div>
            );
          }}
        </For>
      </div>
    </div>
  );
}
</file>

<file path="src/hooks/useConnect.js">
// src/hooks/useConnect.js
import { createSignal, onMount } from "solid-js";
import { parse } from "yaml";
import { configureEndpoints, httpBase } from "../net/endpoints";

export function useConnect() {
  const [config, setConfig] = createSignal(null);
  const [info, setInfo] = createSignal(null);
  const [error, setError] = createSignal(null);
  const [loading, setLoading] = createSignal(true);

  onMount(async () => {
    try {
      const res = await fetch("/default_connect.yaml", { cache: "no-store" });
      if (!res.ok) throw new Error(`YAML load failed: ${res.status}`);
      const text = await res.text();
      const data = parse(text);
      if (!data.backendLink) throw new Error("Missing backendLink in config");

      // Configure endpoints once
      configureEndpoints({
        backendLink: data.backendLink,
        domain: data.domain || "",
      });

      const cfg = {
        domain: data.domain || "",
        backendLink: httpBase(), // normalized canonical HTTP base
        default_ipfs_link: data.default_ipfs_link || ""
      };
      setConfig(cfg);

      const infoRes = await fetch(httpBase() + "info", { headers: { Accept: "application/json" } });
      if (!infoRes.ok) throw new Error(`/info failed: ${infoRes.status}`);
      setInfo(await infoRes.json());
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  });

  return { config, info, error, loading };
}
</file>

<file path="src/hooks/useLocalIpfs.js">
// src/hooks/useLocalIpfs.js
import { createSignal, onCleanup, createEffect } from "solid-js";
import { fetchWithTimeout } from "../utils/net.js";

const IPFS_LOCAL_KEY = "ipfs_local_enabled";
const IPFS_LOCAL_API_KEY = "ipfs_local_api";
const IPFS_LOCAL_GATEWAY_KEY = "ipfs_local_gateway";

function trimSlash(s) { if (!s) return ""; return s.endsWith("/") ? s.slice(0, -1) : s; }

export function useLocalIpfs(dependencies) {
  const { pushToast, pushErrorToast, t } = dependencies;

  const [localIpfsEnabled, setLocalIpfsEnabled] = createSignal(localStorage.getItem(IPFS_LOCAL_KEY) === "1");
  const [localIpfsApiUrl, setLocalIpfsApiUrl] = createSignal(localStorage.getItem(IPFS_LOCAL_API_KEY) || "http://127.0.0.1:5001");
  const [localIpfsGateway, setLocalIpfsGateway] = createSignal(localStorage.getItem(IPFS_LOCAL_GATEWAY_KEY) || "");
  const [localIpfsStatus, setLocalIpfsStatus] = createSignal("unknown");
  let ipfsMonitorTid = null;

  async function pingLocalIpfs() {
    try {
      const base = trimSlash(localIpfsApiUrl());
      if (!base) throw new Error("No API URL");
      const res = await fetchWithTimeout(`${base}/api/v0/id`, { method: "POST", timeoutMs: 5000 });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      setLocalIpfsStatus("ok");
      return true;
    } catch (e) {
      setLocalIpfsStatus("down");
      pushErrorToast(e, { op: "pingLocalIpfs", apiUrl: localIpfsApiUrl() });
      return false;
    }
  }

  async function probeLocalIpfs(apiUrl) {
    const url = trimSlash(apiUrl || "");
    if (!url) throw new Error("Empty IPFS API URL");
    const res = await fetchWithTimeout(`${url}/api/v0/version`, { method: "POST", timeoutMs: 4000 });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const gw = url.replace(/:\d+$/, ":8080").replace(/\/api$/, "");
    return gw.endsWith("/") ? gw : gw + "/";
  }

  function startLocalIpfsMonitor() {
    stopLocalIpfsMonitor();
    ipfsMonitorTid = setInterval(() => { pingLocalIpfs(); }, 10_000);
    pingLocalIpfs();
  }

  function stopLocalIpfsMonitor() {
    if (ipfsMonitorTid) { clearInterval(ipfsMonitorTid); ipfsMonitorTid = null; }
  }

  // MODIFICATION: Wrap the monitor's lifecycle in a createEffect.
  createEffect(() => {
    if (localIpfsEnabled() && localIpfsApiUrl()) {
      startLocalIpfsMonitor();
    } else {
      stopLocalIpfsMonitor();
    }
    // This cleanup runs when the effect re-runs or the component unmounts.
    onCleanup(() => stopLocalIpfsMonitor());
  });

  async function enableLocalIpfs(apiUrl) {
    try {
      const gw = await probeLocalIpfs(apiUrl);
      setLocalIpfsApiUrl(apiUrl);
      setLocalIpfsGateway(gw);
      localStorage.setItem(IPFS_LOCAL_API_KEY, apiUrl);
      localStorage.setItem(IPFS_LOCAL_GATEWAY_KEY, gw);
      localStorage.setItem(IPFS_LOCAL_KEY, "1");
      setLocalIpfsEnabled(true); // The effect will start the monitor
    } catch (e) {
      pushErrorToast(e, { op: "enableLocalIpfs", apiUrl });
      throw e;
    }
  }

  async function disableLocalIpfs() {
    setLocalIpfsGateway("");
    localStorage.setItem(IPFS_LOCAL_KEY, "0");
    localStorage.removeItem(IPFS_LOCAL_GATEWAY_KEY);
    setLocalIpfsEnabled(false); // The effect will stop the monitor
    pushToast({ type: "info", message: t("settings.ipfs.localDisabled") });
  }

  return {
    localIpfsEnabled,
    localIpfsApiUrl,
    localIpfsGateway,
    localIpfsStatus,
    enableLocalIpfs,
    disableLocalIpfs,
    setLocalIpfsApiUrl,
  };
}
</file>

<file path="src/ipfs/utils.js">
// src/ipfs/utils.js

/**
 * Checks if a string looks like a v0 or v1 IPFS CID.
 * This is a basic prefix/length check, not a full validation.
 * @param {string} s The string to check.
 * @returns {boolean}
 */
function isIpfsCid(s) {
  if (typeof s !== 'string') return false;
  // v0 CIDs start with "Qm" and are 46 characters long.
  if (s.startsWith('Qm') && s.length === 46) {
    return true;
  }
  // v1 CIDs in base32 commonly start with "bafy".
  if (s.startsWith('bafy')) {
    return true;
  }
  return false;
}

/**
 * Determines the base CID for a post's content, supporting both new and legacy formats.
 * @param {object} post - The raw post object from the API.
 * @returns {string|null} The base CID for the content folder.
 */
export function getPostContentBaseCid(post) {
  if (!post) return null;
  // New format: data_cid is nested in savva_content.
  if (post.savva_content?.data_cid) {
    return post.savva_content.data_cid;
  }
  // Legacy format: the top-level ipfs field is the base CID.
  return post.ipfs?.split('/')[0] || null;
}

/**
 * Resolves a path that may be relative to a post's content folder into a full IPFS path.
 * If the path already starts with any valid IPFS CID, it's returned as is.
 * Otherwise, it's treated as a relative path and the post's base CID is prepended.
 * @param {object} post - The raw post object from the API.
 * @param {string} path - The relative path or full CID path.
 * @returns {string|null} The full, resolvable IPFS path.
 */
export function resolvePostCidPath(post, path) {
  if (!path) return null;

  const cleanPath = path.startsWith('/') ? path.substring(1) : path;
  const firstSegment = cleanPath.split('/')[0];

  // If the path already starts with any valid CID, treat it as absolute.
  if (isIpfsCid(firstSegment)) {
    return cleanPath;
  }

  // Otherwise, resolve it against the post's own base CID.
  const baseCid = getPostContentBaseCid(post);
  if (!baseCid) return null; // Cannot resolve a relative path without a base CID

  return `${baseCid}/${cleanPath}`;
}

/**
 * Determines the full IPFS path to a post's descriptor file (info.yaml),
 * supporting both new and legacy formats.
 * @param {object} post - The raw post object from the API.
 * @returns {string|null} The full, resolvable IPFS path to the descriptor.
 */
export function getPostDescriptorPath(post) {
  if (!post || !post.ipfs) return null;
  
  // If data_cid is in savva_content, it's the new format where `ipfs` is the direct path.
  if (post.savva_content?.data_cid) {
    return post.ipfs;
  }
  
  // Otherwise, it's the legacy format where `ipfs` is the folder CID.
  const baseCid = post.ipfs.split('/')[0];
  return `${baseCid}/info.yaml`;
}
</file>

<file path="src/net/endpoints.js">
// File: src/net/endpoints.js
// Single source of truth. Configure once, zero-arg getters. Emits a CustomEvent on changes.

function ensureSlash(s) { return s.endsWith("/") ? s : s + "/"; }

let _backendHttpBase = "";
let _wsUrl = "";
let _domain = "";

function buildHttpBase(backendLink) {
  if (!backendLink) return "";
  const u = new URL(backendLink);
  u.pathname = ensureSlash(u.pathname || "/");
  return u.toString();
}

function buildWsUrl(backendBase, domain) {
  if (!backendBase) return "";
  const u = new URL(backendBase);
  const hasApi = (u.pathname || "/").toLowerCase().includes("/api/");
  const wsPath = hasApi ? "ws" : "api/ws";
  u.protocol = u.protocol === "https:" ? "wss:" : "ws:";
  u.pathname = ensureSlash(u.pathname || "/") + wsPath;

  // Only domain as query (per your request) — no lang.
  const q = new URLSearchParams(u.search);
  if (domain) q.set("domain", String(domain));
  u.search = q.toString() ? `?${q.toString()}` : "";
  return u.toString();
}

function notify() {
  if (typeof window !== "undefined") {
    window.dispatchEvent(
      new CustomEvent("savva:endpoints-updated", {
        detail: { httpBase: _backendHttpBase, wsUrl: _wsUrl, domain: _domain },
      })
    );
  }
}

/** Configure once per backend/domain switch */
export function configureEndpoints({ backendLink, domain }) {
  _domain = domain || "";
  _backendHttpBase = buildHttpBase(backendLink || "");
  _wsUrl = buildWsUrl(_backendHttpBase, _domain);
  notify();
}

export function httpBase() { return _backendHttpBase; }
export function wsUrl()    { return _wsUrl; }
export function currentDomain() { return _domain; }
</file>

<file path="src/net/index.js">
// src/ws/index.js
</file>

<file path="src/net/wsRuntime.js">
// src/net/wsRuntime.js
import WsClient from "./WsClient";
import { wsUrl } from "./endpoints";
import { createWsBus } from "./wsBus";
import { createWsApi } from "./wsApi";
import { dbg } from "../utils/debug";

let _client = null;
let _bus = null;
let _api = null;
let _started = false;

export function ensureWsStarted(reason = "init") {
  if (!_client) {
    _client = new WsClient();
    _bus = createWsBus({ replay: 32 });
    _api = createWsApi(_client);
    _client.on("message", (obj) => {
      const t = obj && (obj.type || obj.event);
      if (t) _bus.emit(String(t), obj);
    });
  }
  _client.setUrl();
  const url = _client.url();
  if (!url) {
    dbg.warn("ws", "No WS URL configured");
    return { client: _client, bus: _bus, api: _api };
  }
  if (_client.status() !== "open" && !_started) {
    _client.connect();
    _started = true;
    dbg.log("ws", "singleton connect", { url, reason });
  }
  return { client: _client, bus: _bus, api: _api };
}

function onEndpointsUpdate() {
  if (!_client) return;
  const prev = _client.url();
  _client.setUrl();
  const next = _client.url();
  if (next && next !== prev) {
    dbg.log("ws", "singleton endpoints changed → reconnect", { prev, next });
    _client.reconnect("endpoints-updated");
  } else if (next && _client.status() !== "open") {
    _client.connect();
  }
}

if (typeof window !== "undefined") {
  window.addEventListener("savva:endpoints-updated", onEndpointsUpdate);
  window.__ws = {
    get client() {
      return _client;
    },
    get bus() {
      return _bus;
    },
    get api() {
      return _api;
    },
    start: ensureWsStarted,
  };
}

export function getWsClient() {
  return ensureWsStarted().client;
}
export function getWsApi() {
  return ensureWsStarted().api;
}
export function onAlert(type, fn) {
  return ensureWsStarted().bus.on(type, fn);
}
export function offAlert(type, fn) {
  return ensureWsStarted().bus.off(type, fn);
}

export function whenWsOpen({ timeoutMs = 12000 } = {}) {
  const ws = getWsClient();
  if (ws.status() === "open") return Promise.resolve();

  return new Promise((resolve, reject) => {
    let timer;
    const onOpen = () => {
      ws.off("open", onOpen);
      if (timer) clearTimeout(timer);
      resolve();
    };
    ws.on("open", onOpen);

    if (timeoutMs > 0) {
      timer = setTimeout(() => {
        ws.off("open", onOpen);
        reject(new Error("WS open timeout"));
      }, timeoutMs);
    }
  });
}
</file>

<file path="src/styles/layout.css">
/* src/styles/layout.css */
:root {
  --sv-container-max: 1600px;           /* main max width for content container */
  --sv-container-gutter: clamp(16px, 2vw, 32px); /* responsive padding */
  --sv-aside-w: clamp(300px, 24vw, 380px);       /* sidebar width on desktop */
  --sv-content-max-ch: 68ch;            /* comfortable text line length */
}

/* Centered container */
.sv-container {
  max-width: var(--sv-container-max);
  margin-inline: auto;
  /* padding-inline: var(--sv-container-gutter); */
}

/* Content grid: main column + sidebar */
.sv-content-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: clamp(16px, 2vw, 24px);
}
@media (min-width: 1024px) {
  .sv-content-grid {
    grid-template-columns: minmax(0, 1fr) var(--sv-aside-w);
    align-items: start;
  }
}

.sv-main { min-width: 0; }
.sv-aside { min-width: 0; }

/* Text limiter for typography-heavy content */
.sv-typography {
  max-width: var(--sv-content-max-ch);
}

/* Full-bleed section for backgrounds/hero areas */
.full-bleed {
  width: 100vw;
  margin-left: 50%;
  transform: translateX(-50%);
}

@media (min-width: 1800px) {
  :root { --sv-container-max: 1600px; }
}

.sv-container--no-gutter {
  padding-inline: 0; /* keep max-width centering, remove side padding */
}
</file>

<file path="src/ui/contextMenuBuilder.js">
// src/ui/contextMenuBuilder.js
import { pushToast } from "../ui/toast.js";
import { getPostDescriptorPath, getPostContentBaseCid } from "../ipfs/utils.js";

// A helper to avoid rewriting the clipboard logic everywhere
function copyToClipboard(text, label, t) {
  if (!text) return;
  navigator.clipboard.writeText(text).then(() => {
    pushToast({ type: "success", message: t("clipboard.copied", { label }) });
  }).catch(err => {
    console.error(`Failed to copy ${label}:`, err);
  });
}

/**
 * Returns a standard set of admin menu items for a given post.
 * @param {object} post - The raw post object.
 * @param {function} t - The translation function from i18n.
 * @returns {Array<object>} An array of menu item objects.
 */
export function getPostAdminItems(post, t) {
  if (!post) return [];

  const items = [];
  const savvaCid = post.savva_cid;
  const descriptorPath = getPostDescriptorPath(post);
  const dataCid = getPostContentBaseCid(post);

  if (savvaCid) {
    items.push({
      label: t("postcard.copySavvaCid"),
      onClick: () => copyToClipboard(savvaCid, "SAVVA CID", t)
    });
  }
  if (descriptorPath) {
    items.push({
      label: t("postcard.copyDescriptorCid"), 
      onClick: () => copyToClipboard(descriptorPath, "Descriptor Path", t)
    });
  }
  if (dataCid) {
    items.push({
      label: t("postcard.copyDataCid"),
      onClick: () => copyToClipboard(dataCid, "Data CID", t)
    });
  }

  return items;
}

/**
 * Returns pinning/unpinning menu items for a post.
 * @param {object} post - The raw post object.
 * @param {function} t - The translation function from i18n.
 * @returns {Array<object>} An array containing a single pin/unpin menu item, or an empty array.
 */
export function getPinningItems(post, t) {
  if (!post) return [];
  
  // Note: The onClick handlers are placeholders for now.
  if (post.pinned) {
    return [{ 
      label: t("postcard.unpin"), 
      onClick: () => console.log("Unpin clicked for:", post.savva_cid) 
    }];
  } else {
    return [{ 
      label: t("postcard.pin"), 
      onClick: () => console.log("Pin clicked for:", post.savva_cid) 
    }];
  }
}
</file>

<file path="index.html">
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SAVVA · SolidJS</title>

  <!-- Preload theme to avoid flash -->
  <script>
    (function () {
      try {
        const saved = localStorage.getItem("theme");
        const systemDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const theme = saved || (systemDark ? "dark" : "light");
        document.documentElement.classList.toggle("dark", theme === "dark");
      } catch { }
    })();
  </script>

  <script>
    (function () {
      // If there is a real path (e.g., /settings) but no hash, rewrite to hash form
      if (!location.hash) {
        let path = location.pathname;
        let newHash = "";

        // NEW: Check for legacy /content/ URL
        if (path.startsWith("/content/")) {
          const savvaId = path.substring("/content/".length);
          newHash = "#/post/" + savvaId;
        } else if (path !== "/") {
          newHash = "#" + path + location.search;
        }

        if (newHash) {
          history.replaceState(null, "", "/" + newHash);
        }
      }
    })();
  </script>


  <!-- Load app after theme class is set -->
  <script type="module" src="/src/index.jsx"></script>
</head>

<body>
  <div id="root"></div>
</body>

</html>
</file>

<file path="public/dev_docs/en/getting-started.md">
# Getting Started

Welcome to the **Getting Started** guide for the SAVVA Platform.

This page walks you through the basic steps to set up the project locally and start contributing.

## Prerequisites

Before you begin, make sure you have the following tools installed:

- **Node.js** (v18 or later recommended)  
- **npm** or **yarn** package manager  
- **Git** for cloning the repository  
- A modern **browser** (Chrome, Firefox, Edge) for development and testing  

## Clone the Repository

The source code is hosted on GitHub. To get the latest version:

```bash
git clone https://github.com/AlexNa-Holdings/savva-ui-solidjs
cd savva-ui-solidjs
````

## Install Dependencies

Inside the project folder, install all required dependencies:

```bash
npm install
# or
yarn install
```

## Start the Development Server

Run the dev server with hot reloading:

```bash
npm run dev
# or
yarn dev
```

The app will be available at [http://localhost:5173](http://localhost:5173).

## Build for Production

To create an optimized build:

```bash
npm run build
```

The output will be in the `dist/` folder.

## Next Steps

* Explore the **Developer Docs** for architecture and modules.
* Try switching domains and assets in the **Right Pane**.
* Contribute by opening issues or pull requests on GitHub.

That’s it! 🎉 You’re ready to start working with the **SAVVA Platform**.

```html
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SAVVA · SolidJS</title>

  <!-- Preload theme to avoid flash -->
  <script>
    (function () {
      try {
        const saved = localStorage.getItem("theme");
        const systemDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const theme = saved || (systemDark ? "dark" : "light");
        document.documentElement.classList.toggle("dark", theme === "dark");
      } catch { }
    })();
  </script>

  <script>
    (function () {
      // If there is a real path (e.g., /settings) but no hash, rewrite to hash form: /#/settings
      if (!location.hash && location.pathname !== "/") {
        var newHash = "#" + location.pathname + location.search + location.hash;
        history.replaceState(null, "", "/" + newHash);
      }
    })();
  </script>


  <!-- Load app after theme class is set -->
  <script type="module" src="/src/index.jsx"></script>
</head>

<body>
  <div id="root"></div>
</body>

</html>
```
</file>

<file path="public/domain_default/modules/tabs.yaml">
tabs:
  - type: leaders
    right_panel:
      available: true
      blocks:
        - type: html
          en: /html/info_block_en.html
          ru: /html/info_block_ru.html
          ua: /html/info_block_ua.html
          fr: /html/info_block_fr.html
        - type: content_List
          list_name: main
          count: 7
  - type: actual
    right_panel:
      available: false
      blocks:
        - type: content_List
          list_name: main
          count: 7
  - type: comments
    right_panel:
      available: false
      blocks:
        - type: content_List
          list_name: main
          count: 7
  - type: new
    right_panel:
      available: false
      blocks:
        - type: content_List
          list_name: main
          count: 7
  - type: for-you
    private: true
    right_panel:
      available: false
      blocks:
        - type: content_List
          list_name: main
          count: 7
</file>

<file path="src/blockchain/auth.js">
// src/blockchain/auth.js
import { hexToString } from "viem";
import { getSavvaContract } from "./contracts.js";
import { toHexBytes32, toChecksumAddress } from "./utils.js";
import { walletAccount } from "./wallet.js";
import { httpBase } from "../net/endpoints.js";

export async function authorize(app) {
  const account = walletAccount();
  if (!account) throw new Error("Wallet is not connected.");
  const checksummedAccount = toChecksumAddress(account);

  const info = app.info();
  if (!info) throw new Error("Backend /info not loaded yet.");

  const userProfileContract = await getSavvaContract(app, 'UserProfile');
  const domainHex = toHexBytes32("");
  const keyHex = toHexBytes32("auth_modifier");
  const modifierHex = await userProfileContract.read.getString([account, domainHex, keyHex]);
  const modifierString = hexToString(modifierHex, { size: 32 });
  
  const textToSign = info.auth_text_to_sign;
  if (!textToSign) throw new Error("auth_text_to_sign not found in /info response.");

  const messageToSign = textToSign + modifierString;
  
  // Use the raw (unguarded) client for signing the login message
  const walletClient = app.getRawWalletClient();
  const signature = await walletClient.signMessage({ account, message: messageToSign });
  
  const currentDomain = app.config().domain;
  
  const authUrl = new URL(`${httpBase()}auth`);
  authUrl.searchParams.set('user_addr', checksummedAccount);
  authUrl.searchParams.set('domain', currentDomain);
  authUrl.searchParams.set('signature', signature);
  
  const authRes = await fetch(authUrl.toString(), { credentials: 'include' });
  if (!authRes.ok) throw new Error(`Authorization failed with status: ${authRes.status}`);

  const isAdminUrl = new URL(`${httpBase()}is-admin`);
  isAdminUrl.searchParams.set('address', checksummedAccount);
  isAdminUrl.searchParams.set('domain', currentDomain);
  
  const adminRes = await fetch(isAdminUrl.toString(), { credentials: 'include' });
  if (!adminRes.ok) throw new Error(`/is-admin check failed with status: ${adminRes.status}`);
  const isAdminData = await adminRes.json();
  
  const isAdmin = !!isAdminData?.admin;

  const coreUserData = {
    address: account,
    domain: currentDomain,
    isAdmin: isAdmin,
  };
  
  await app.login(coreUserData);
  
  return coreUserData;
}
</file>

<file path="src/components/editor/FileGridItem.jsx">
// src/components/editor/FileGridItem.jsx
import { Show, createMemo } from "solid-js";
import { formatBytes } from "../../utils/format.js";

function VideoIcon() {
  return (
    <svg viewBox="0 0 24 24" class="w-8 h-8 text-[hsl(var(--muted-foreground))]">
      <path fill="currentColor" d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
    </svg>
  );
}

function AudioIcon() {
  return (
    <svg viewBox="0 0 24 24" class="w-8 h-8 text-[hsl(var(--muted-foreground))]">
      <path fill="currentColor" d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
    </svg>
  );
}

export default function FileGridItem(props) {
  const fileType = createMemo(() => {
    const name = props.file?.name?.toLowerCase() || "";
    if (/\.(jpe?g|png|gif|webp)$/.test(name)) return "image";
    if (/\.(mp4|webm|ogg)$/.test(name)) return "video";
    if (/\.(mp3|wav|m4a)$/.test(name)) return "audio";
    return "other";
  });

  const handleClick = (e) => {
    e.preventDefault();
    props.onMenuOpen?.({
      file: props.file,
      fileType: fileType(),
      element: e.currentTarget,
    });
  };

  return (
    <div
      class="relative group aspect-square rounded-md border border-[hsl(var(--border))] bg-[hsl(var(--muted))] overflow-hidden cursor-pointer"
      onClick={handleClick}
      onContextMenu={handleClick}
      title={props.file.name}
    >
      <Show when={fileType() === 'image'}>
        <img src={props.file.url} alt={props.file.name} class="w-full h-full object-cover" />
      </Show>
      <Show when={fileType() === 'video'}>
        <div class="w-full h-full flex items-center justify-center">
          <VideoIcon />
        </div>
      </Show>
      <Show when={fileType() === 'audio'}>
        <div class="w-full h-full flex items-center justify-center">
          <AudioIcon />
        </div>
      </Show>

      <span class="absolute top-0 right-0 z-10 text-white text-[10px] font-mono bg-black/40 px-1 rounded-sm">
        {formatBytes(props.file.size, 0)}
      </span>
      
      <div class="absolute bottom-0 left-0 right-0 p-1.5 bg-black/50 text-white text-[10px] text-center">
        <span class="truncate">{props.file.name}</span>
      </div>
    </div>
  );
}
</file>

<file path="src/components/feed/PostListView.jsx">
// src/components/feed/PostListView.jsx
import { For, createMemo } from "solid-js";
import PostCard from "./PostCard.jsx";

export default function PostListView(props) {
  const mode = () => (props.mode === "grid" ? "grid" : "list");

  const gridClass = createMemo(() => {
    const base = "grid gap-3 grid-cols-1 sm:grid-cols-2";
    // If the right rail is NOT visible, we have more space. Use up to 4 columns.
    // If the right rail IS visible, we have less space. Use up to 3 columns.
    return props.isRailVisible
      ? `${base} lg:grid-cols-2 xl:grid-cols-3`
      : `${base} lg:grid-cols-3 xl:grid-cols-4`;
  });

  return (
    <div class={mode() === "grid" ? gridClass() : "flex flex-col gap-3"}>
      <For each={props.items}>
        {(item) => <PostCard item={item} mode={mode()} />}
      </For>
    </div>
  );
}
</file>

<file path="src/components/tabs/ActualTab.jsx">
// src/components/tabs/ActualTab.jsx
import { createMemo, createResource, createSignal, Show, For, createEffect } from "solid-js";
import ContentFeed from "../feed/ContentFeed.jsx";
import { useApp } from "../../context/AppContext.jsx";
import { loadAssetResource } from "../../utils/assetLoader";
import ViewModeToggle, { viewMode } from "../ui/ViewModeToggle.jsx";
import { toChecksumAddress } from "../../blockchain/utils.js";

function useDomainCategories(app) {
  const cfg = () => app.domainAssetsConfig?.();
  const relPath = createMemo(() => cfg()?.modules?.categories || null);
  const lang = () => (app.lang?.() || "en").toLowerCase();
  const params = createMemo(() => ({ rel: relPath(), lang: lang() }));
  const [cats] = createResource(params, async ({ rel, lang }) => {
    if (!rel) return [];
    try {
      const data = await loadAssetResource(app, rel, { type: "yaml" });
      const listByLang = data?.locales?.[lang] || data?.locales?.en || [];
      return (Array.isArray(listByLang) ? listByLang : []).map(String);
    } catch (err) {
      console.error(`Failed to load categories from ${rel}:`, err);
      return [];
    }
  });
  return cats;
}

export default function ActualTab(props) {
  const app = useApp();
  const lang = createMemo(() => (app.lang?.() || "en").toLowerCase());
  const [category, setCategory] = createSignal("ALL");
  const categoriesRes = useDomainCategories(app);
  const categoriesWithAll = createMemo(() => ["ALL", ...(categoriesRes() || [])]);

  createEffect(() => {
    const newList = categoriesRes();
    const currentSelection = category();
    if (newList && currentSelection !== "ALL" && !newList.includes(currentSelection)) {
      setCategory("ALL");
    }
  });

  const domainName = () => {
    const d = app.selectedDomain?.();
    return typeof d === "string" ? d : d?.name || "";
  };
  const contentList = app.wsMethod ? app.wsMethod("content-list") : null;

  const feedResetKey = createMemo(() => `${domainName()}|${category()}`);

  async function fetchPage(page, pageSize) {
    const limit = pageSize;
    const offset = (page - 1) * pageSize;
    try {
      if (!contentList) return [];
      const params = {
        domain: domainName(),
        content_type: "post",
        limit,
        offset,
        lang: lang(),
        // MODIFICATION: Added new sort order for this tab.
        order_by: 'fund_amount'
      };
      
      const cat = category();
      if (cat && cat !== "ALL") {
        params.category = `${lang()}:${cat}`;
      }
      
      const user = app.authorizedUser();
      if (user?.address) {
        params.my_addr = toChecksumAddress(user.address);
      }

      const res = await contentList(params);
      const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];
      return arr.map((it) => ({
        id: it?.savva_cid || it?.savvaCID || it?.id,
        _raw: it,
      }));
    } catch (err) {
      console.error("fetchPage error:", err);
      return [];
    }
  }

  return (
    <section class="w-full">
      <div class="mb-3 flex items-center gap-3">
        <ViewModeToggle size="md" />
        <div class="ml-auto flex items-center gap-2 min-w-[220px]">
          <span class="text-xs opacity-70">{app.t("newTab.category")}</span>
          <select
            class="flex-1 px-3 h-9 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
            value={category()}
            onInput={(e) => setCategory(e.currentTarget.value)}
            aria-label={app.t("newTab.category")}
          >
            <For each={categoriesWithAll()}>
              {(c) => <option value={c}>{c === "ALL" ? app.t("categories.all") : c}</option>}
            </For>
          </select>
          <Show when={categoriesRes.loading}>
            <div class="text-xs opacity-70">{app.t("common.loading")}</div>
          </Show>
        </div>
      </div>
      <ContentFeed
        mode={viewMode()}
        fetchPage={fetchPage}
        pageSize={12}
        resetOn={feedResetKey()}
        isRailVisible={props.isRailVisible}
        isActivated={props.isActivated}
      />
    </section>
  );
}
</file>

<file path="src/components/tabs/ForYouTab.jsx">
// src/components/tabs/ForYouTab.jsx
import { createMemo, createResource, createSignal, Show, For, createEffect } from "solid-js";
import ContentFeed from "../feed/ContentFeed.jsx";
import { useApp } from "../../context/AppContext.jsx";
import { loadAssetResource } from "../../utils/assetLoader";
import ViewModeToggle, { viewMode } from "../ui/ViewModeToggle.jsx";
import { toChecksumAddress } from "../../blockchain/utils.js";

function useDomainCategories(app) {
  const cfg = () => app.domainAssetsConfig?.();
  const relPath = createMemo(() => cfg()?.modules?.categories || null);
  const lang = () => (app.lang?.() || "en").toLowerCase();
  const params = createMemo(() => ({ rel: relPath(), lang: lang() }));
  const [cats] = createResource(params, async ({ rel, lang }) => {
    if (!rel) return [];
    try {
      const data = await loadAssetResource(app, rel, { type: "yaml" });
      const listByLang = data?.locales?.[lang] || data?.locales?.en || [];
      return (Array.isArray(listByLang) ? listByLang : []).map(String);
    } catch (err) {
      console.error(`Failed to load categories from ${rel}:`, err);
      return [];
    }
  });
  return cats;
}

export default function ForYouTab(props) {
  const app = useApp();
  const lang = createMemo(() => (app.lang?.() || "en").toLowerCase());
  const [category, setCategory] = createSignal("ALL");
  const categoriesRes = useDomainCategories(app);
  const categoriesWithAll = createMemo(() => ["ALL", ...(categoriesRes() || [])]);

  createEffect(() => {
    const newList = categoriesRes();
    const currentSelection = category();
    if (newList && currentSelection !== "ALL" && !newList.includes(currentSelection)) {
      setCategory("ALL");
    }
  });

  const domainName = () => {
    const d = app.selectedDomain?.();
    return typeof d === "string" ? d : d?.name || "";
  };
  const contentList = app.wsMethod ? app.wsMethod("content-list") : null;

  const feedResetKey = createMemo(() => `${domainName()}|${category()}`);

  async function fetchPage(page, pageSize) {
    const limit = pageSize;
    const offset = (page - 1) * pageSize;
    try {
      if (!contentList) return [];
      const params = { domain: domainName(), content_type: "post", limit, offset, lang: lang() };
      const cat = category();
      if (cat && cat !== "ALL") {
        params.category = `${lang()}:${cat}`;
      }
      
      const user = app.authorizedUser();
      if (user?.address) {
        // MODIFICATION: Pass the authorized address as `user_addr` for this feed.
        params.user_addr = toChecksumAddress(user.address);
      }

      const res = await contentList(params);
      const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];
      return arr.map((it) => ({
        id: it?.savva_cid || it?.savvaCID || it?.id,
        _raw: it,
      }));
    } catch (err) {
      console.error("fetchPage error:", err);
      return [];
    }
  }

  return (
    <section class="w-full">
      <div class="mb-3 flex items-center gap-3">
        <ViewModeToggle size="md" />
        <div class="ml-auto flex items-center gap-2 min-w-[220px]">
          <span class="text-xs opacity-70">{app.t("newTab.category")}</span>
          <select
            class="flex-1 px-3 h-9 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
            value={category()}
            onInput={(e) => setCategory(e.currentTarget.value)}
            aria-label={app.t("newTab.category")}
          >
            <For each={categoriesWithAll()}>
              {(c) => <option value={c}>{c === "ALL" ? app.t("categories.all") : c}</option>}
            </For>
          </select>
          <Show when={categoriesRes.loading}>
            <div class="text-xs opacity-70">{app.t("common.loading")}</div>
          </Show>
        </div>
      </div>
      <ContentFeed
        mode={viewMode()}
        fetchPage={fetchPage}
        pageSize={12}
        resetOn={feedResetKey()}
        isRailVisible={props.isRailVisible}
        isActivated={props.isActivated}
      />
    </section>
  );
}
</file>

<file path="src/components/tabs/index.js">
// src/components/tabs/index.js
import ActualTab from "./ActualTab.jsx";
import CommentsTab from "./CommentsTab.jsx";
import ForYouTab from "./ForYouTab.jsx";
import LeadersTab from "./LeadersTab.jsx";
import NewTab from "./NewTab.jsx";

/**
 * Registry of tab type -> component.
 * Add more mappings as you implement new tab types.
 */
const REGISTRY = {
  actual: ActualTab,
  comments: CommentsTab,
  "for-you": ForYouTab,
  leaders: LeadersTab,
  new: NewTab,
};

export function getTabComponent(type) {
  const key = String(type || "").toLowerCase();
  return REGISTRY[key] || null;
}
</file>

<file path="src/components/ui/icons/ReactionIcon.jsx">
// src/components/ui/icons/ReactionIcon.jsx
import { Show } from "solid-js";

const REACTION_MAP = {
  like: "👍",
  super: "❤️",
  ha_ha: "😂",
  sad: "😢",
  angry: "😡",
  wow: "😮",
  trophy: "🏆",
  hot: "🔥",
  clap: "👏",
  dislike: "👎",
};

export const REACTION_TYPES = Object.keys(REACTION_MAP);

export default function ReactionIcon(props) {
  const emoji = () => REACTION_MAP[props.type];
  return (
    <Show when={emoji()}>
      <span
        class={props.class || "text-sm"}
        aria-label={props.type}
      >
        {emoji()}
      </span>
    </Show>
  );
}
</file>

<file path="src/components/ui/icons/UnknownUserIcon.jsx">
// src/components/ui/icons/UnknownUserIcon.jsx
export default function UnknownUserIcon(props) {
  return (
    <svg
      viewBox="0 0 250 250"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid slice"
      {...props}
    >
      <mask id="mask_unknown_user" mask-type="alpha" maskUnits="userSpaceOnUse" x="0" y="0" width="250" height="250">
        <circle cx="125" cy="125" r="125" fill="white" />
      </mask>
      <g mask="url(#mask_unknown_user)">
        <path d="M190.314 204.7L145.31 180C145.31 180 144.347 196.897 124.5 196.897C104.653 196.897 102.661 180 102.661 180L58.5863 204.7C55.2674 206.552 52.8111 209.594 51.6495 213.198L40 250H121.812H124.202H209L197.351 213.264C196.189 209.627 193.667 206.552 190.314 204.7Z" fill="#646464" />
        <path d="M64.7864 78.2826C54.3768 93.2166 59.5648 118.206 59.5648 118.206L67.0002 108.881C67.9585 142.001 82.4989 156.338 92.6111 162.311C94.8582 165.597 97.4359 168.451 100.146 170.907C101.269 171.936 102.36 172.732 103.054 173.23C107.515 176.416 112.472 178.573 117.892 179.469C118.288 179.535 118.685 179.602 119.114 179.635C119.643 179.701 120.205 179.768 120.734 179.834C121.791 179.934 122.849 180 123.939 180C125.063 180 126.153 179.934 127.244 179.834C127.905 179.768 128.533 179.668 129.194 179.569C129.557 179.502 129.887 179.469 130.251 179.403C136.199 178.374 141.652 175.852 146.411 172.002C147.038 171.471 147.997 170.741 149.352 169.38C152.293 166.46 154.97 163.042 157.283 159.126C159.96 157.201 163.066 154.678 166.668 151.393C193.237 126.968 175.227 87.5416 175.227 87.5416L186 95.3737C184.513 64.7423 171.129 56.9103 171.129 56.9103L181.902 61.3904C170.006 26.312 134.316 35.9362 134.316 35.9362L144.725 27.4072C97.502 13.2364 81.9041 47.8502 81.9041 47.8502C54.013 54.8526 55.0044 83.7915 55.0044 83.7915L64.7864 78.2826ZM78.9629 99.4225C78.996 99.4225 79.0291 99.4225 79.0622 99.3894C79.2274 106.193 79.8222 110.938 79.8222 110.938H82.8957C82.6643 107.055 83.2924 101.812 84.2838 96.4026C95.3543 95.5729 113.86 91.159 124.798 72.3089L117.363 93.4157C117.363 93.4157 140.033 88.0063 141.354 63.5476C141.354 63.5476 149.715 82.5968 146.939 88.7364C146.939 88.7364 156.06 83.3269 158.109 71.5788C158.109 71.5788 166.371 98.4933 165.611 110.972H168.684C168.684 110.972 169.279 106.226 169.444 99.4225C169.444 99.4225 169.444 99.4225 169.477 99.4225C175.425 101.414 175.558 110.872 172.22 128.295C170.369 138.052 167.329 139.512 165.214 139.114C163.793 138.848 162.736 137.753 162.736 137.753L162.801 136.127V136.028C162.107 139.247 161.249 142.333 160.257 145.22C160.257 145.253 160.224 145.32 160.224 145.353C159.761 146.747 159.232 148.074 158.704 149.402C158.671 149.468 158.671 149.535 158.638 149.568C156.093 155.741 152.855 160.951 149.121 165.132C148.394 165.929 147.666 166.725 146.873 167.455C146.741 167.588 146.642 167.688 146.51 167.82C145.717 168.584 144.858 169.281 144.031 169.944C143.932 170.044 143.8 170.11 143.701 170.21C142.842 170.874 141.982 171.471 141.09 172.035C140.958 172.102 140.826 172.201 140.727 172.268C139.868 172.799 138.975 173.296 138.083 173.728C137.918 173.794 137.752 173.894 137.587 173.993C136.728 174.391 135.836 174.757 134.944 175.088C134.712 175.155 134.514 175.254 134.316 175.321C133.456 175.619 132.597 175.852 131.738 176.051C131.474 176.117 131.21 176.217 130.945 176.283C130.086 176.482 129.194 176.615 128.334 176.715C128.07 176.748 127.773 176.814 127.508 176.847C126.352 176.98 125.195 177.046 124.005 177.046C122.882 177.046 121.791 176.98 120.667 176.881C120.601 176.881 120.502 176.847 120.436 176.847C112.869 176.018 105.962 172.5 100.212 166.659C99.8153 166.261 99.4189 165.796 99.0554 165.398C97.5683 163.772 96.1472 161.946 94.8584 160.022C94.8254 159.988 94.7922 159.922 94.7592 159.889C94.1313 158.96 93.5367 157.964 92.9419 156.968C92.9088 156.902 92.8426 156.802 92.8096 156.703C92.2478 155.707 91.686 154.679 91.1572 153.65C91.0912 153.517 91.0579 153.417 90.9919 153.285C90.4962 152.256 90.0006 151.161 89.5049 150.066C89.4388 149.933 89.4056 149.8 89.3395 149.667C88.8769 148.572 88.4472 147.444 88.0176 146.282C87.9846 146.15 87.9187 146.017 87.8857 145.884C87.0265 143.395 86.2331 140.773 85.5722 138.019C85.4731 138.118 85.3409 138.218 85.1757 138.351C85.1426 138.351 85.143 138.384 85.1099 138.384C84.5481 138.749 83.7217 139.18 82.7634 139.18C80.6814 139.18 78.0048 137.189 76.3195 128.295C72.9157 110.872 73.0146 101.414 78.9629 99.4225Z" fill="#646464" />
      </g>
    </svg>
  );
}
</file>

<file path="src/components/ui/icons/VerifiedBadge.jsx">
// src/components/ui/icons/VerifiedBadge.jsx
// Compact, AA‑legible verification badge. Sizing & color are controlled by parent.
export default function VerifiedBadge(props) {
    return (
        <svg {...props} viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" data-name="Layer 1" fill="currentColor">
            <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
            <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
            <g id="SVGRepo_iconCarrier">
                <path fill-rule="evenodd" clip-rule="evenodd"
                    d="M9.5924 3.20027C9.34888 3.4078 9.22711 3.51158 9.09706 3.59874C8.79896 3.79854 8.46417 
                    3.93721 8.1121 4.00672C7.95851 4.03705 7.79903 4.04977 7.48008 4.07522C6.6787 4.13918 6.278 
                    4.17115 5.94371 4.28923C5.17051 4.56233 4.56233 5.17051 4.28923 5.94371C4.17115 6.278 4.13918
                    6.6787 4.07522 7.48008C4.04977 7.79903 4.03705 7.95851 4.00672 8.1121C3.93721 8.46417 
                    3.79854 8.79896 3.59874 9.09706C3.51158 9.22711 3.40781 9.34887 3.20027 9.5924C2.67883 
                    10.2043 2.4181 10.5102 2.26522 10.8301C1.91159 11.57 1.91159 12.43 2.26522 13.1699C2.41811 
                    13.4898 2.67883 13.7957 3.20027 14.4076C3.40778 14.6511 3.51158 14.7729 3.59874 
                    14.9029C3.79854 15.201 3.93721 15.5358 4.00672 15.8879C4.03705 16.0415 4.04977 
                    16.201 4.07522 16.5199C4.13918 17.3213 4.17115 17.722 4.28923 18.0563C4.56233 18.8295 
                    5.17051 19.4377 5.94371 19.7108C6.278 19.8288 6.6787 19.8608 7.48008 19.9248C7.79903 
                    19.9502 7.95851 19.963 8.1121 19.9933C8.46417 20.0628 8.79896 20.2015 9.09706 20.4013C9.22711 
                    20.4884 9.34887 20.5922 9.5924 20.7997C10.2043 21.3212 10.5102 21.5819 10.8301 21.7348C11.57 
                    22.0884 12.43 22.0884 13.1699 21.7348C13.4898 21.5819 13.7957 21.3212 14.4076 20.7997C14.6511 
                    20.5922 14.7729 20.4884 14.9029 20.4013C15.201 20.2015 15.5358 20.0628 15.8879 
                    19.9933C16.0415 19.963 16.201 19.9502 16.5199 19.9248C17.3213 19.8608 17.722 19.8288 18.0563 
                    19.7108C18.8295 19.4377 19.4377 18.8295 19.7108 18.0563C19.8288 17.722 19.8608 17.3213 
                    19.9248 16.5199C19.9502 16.201 19.963 16.0415 19.9933 15.8879C20.0628 15.5358 20.2015 
                    15.201 20.4013 14.9029C20.4884 14.7729 20.5922 14.6511 20.7997 14.4076C21.3212 13.7957 
                    21.5819 13.4898 21.7348 13.1699C22.0884 12.43 22.0884 11.57 21.7348 10.8301C21.5819 
                    10.5102 21.3212 10.2043 20.7997 9.5924C20.5922 9.34887 20.4884 9.22711 20.4013 
                    9.09706C20.2015 8.79896 20.0628 8.46417 19.9933 8.1121C19.963 7.95851 19.9502 7.79903 
                    19.9248 7.48008C19.8608 6.6787 19.8288 6.278 19.7108 5.94371C19.4377 5.17051 18.8295 
                    4.56233 18.0563 4.28923C17.722 4.17115 17.3213 4.13918 16.5199 4.07522C16.201 4.04977 
                    16.0415 4.03705 15.8879 4.00672C15.5358 3.93721 15.201 3.79854 14.9029 3.59874C14.7729 
                    3.51158 14.6511 3.40781 14.4076 3.20027C13.7957 2.67883 13.4898 2.41811 13.1699 
                    2.26522C12.43 1.91159 11.57 1.91159 10.8301 2.26522C10.5102 2.4181 10.2043 2.67883 9.5924 
                    3.20027ZM16.3735 9.86314C16.6913 9.5453 16.6913 9.03 16.3735 8.71216C16.0557 8.39433 
                    15.5403 8.39433 15.2225 8.71216L10.3723 13.5624L8.77746 11.9676C8.45963 11.6498 7.94432 
                    11.6498 7.62649 11.9676C7.30866 12.2854 7.30866 12.8007 7.62649 13.1186L9.79678 
                    15.2889C10.1146 15.6067 10.6299 15.6067 10.9478 15.2889L16.3735 9.86314Z" >
                </path>
            </g>
        </svg>
    );
}
</file>

<file path="src/components/ui/LangSelector.jsx">
// src/components/ui/LangSelector.jsx
import { For, Show, createMemo, createEffect } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { LANG_INFO } from "../../i18n/useI18n";
import { dbg } from "../../utils/debug";

export default function LangSelector(props) {
  const app = useApp();
  const codes = createMemo(() => props.codes || []);
  const value = () => (props.value || app.lang?.() || "").toLowerCase();
  
  const onChange = (code) => {
    dbg.log("LangSelector", `User clicked '${code}'. Calling onChange.`);
    return (props.onChange ? props.onChange(code) : app.setLang?.(code));
  };
  
  createEffect(() => {
    dbg.log("LangSelector", `Active value updated to '${value()}'`);
  });
  
  const isStretch = () => props.variant === 'stretch';

  return (
    <Show when={codes().length > 1}>
      <div 
        classList={{
          'themed-segment': !isStretch(),
          'grid w-full grid-cols-4 gap-1 p-1 rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--muted))]': isStretch(),
        }}
        class={props.class || ""} 
        role="group"
        aria-label={app.t("rightPane.language")}
      >
        <For each={codes()}>
          {(code) => {
            const c = String(code).toLowerCase();
            const info = LANG_INFO[c] || { code: c.toUpperCase(), name: c.toUpperCase() };
            const active = () => value() === c;
            return (
              <button
                type="button"
                class={`themed-pill ${active() ? "is-active" : ""}`}
                aria-pressed={active()}
                onClick={() => onChange(c)}
                title={info.name}
              >
                {info.code}
              </button>
            );
          }}
        </For>
      </div>
    </Show>
  );
}
</file>

<file path="src/components/ui/PostReactions.jsx">
// src/components/ui/PostReactions.jsx
import { For, createMemo, Show, createSignal, createEffect, on } from "solid-js";
import ReactionIcon from "./icons/ReactionIcon.jsx";

const REACTION_TYPES = [
  "like", "super", "ha_ha", "sad", "angry", 
  "wow", "trophy", "hot", "clap", "dislike"
];

export default function PostReactions(props) {
  const [isAnimating, setIsAnimating] = createSignal(false);
  const sourceReactions = createMemo(() => props.item?._raw?.reactions || props.item?.reactions || []);
  
  // This signal holds what is currently visible on screen.
  const [displayReactions, setDisplayReactions] = createSignal(sourceReactions());

  const reactionsWithCount = createMemo(() => {
    const counts = displayReactions(); // Render based on the display signal
    return REACTION_TYPES.map((type, i) => ({
      type,
      count: counts[i] || 0,
    })).filter(r => r.count > 0);
  });

  const totalReactions = createMemo(() => {
    // Render based on the display signal
    return (displayReactions() || []).reduce((sum, count) => sum + (count || 0), 0);
  });

  // The effect now receives the new and previous values from `on`.
  createEffect(on(sourceReactions, (newReactions, prevReactions) => {
    // Don't animate on the initial render
    if (prevReactions === undefined) {
      setDisplayReactions(newReactions);
      return;
    }

    // 1. Start the animation, showing the OLD value first.
    setDisplayReactions(prevReactions);
    setIsAnimating(true);

    // 2. Halfway through the 400ms animation, swap to the NEW value.
    setTimeout(() => {
      setDisplayReactions(newReactions);
    }, 200);

    // 3. After the animation is complete, remove the animation class.
    setTimeout(() => {
      setIsAnimating(false);
    }, 400);

  }, { defer: true }));

  return (
    <Show when={totalReactions() > 0 || isAnimating()}>
      <div 
        class="flex items-center text-xs"
        classList={{ "default-animation": isAnimating() }}
      >
        <div class="flex items-center">
          <For each={reactionsWithCount()}>
            {(reaction) => <ReactionIcon type={reaction.type} />}
          </For>
        </div>
        <Show when={totalReactions() > 1}>
          <div class=" ml-0">{totalReactions()}</div>
        </Show>
      </div>
    </Show>
  );
}
</file>

<file path="src/context/useAppConnection.js">
// src/context/useAppConnection.js
import { createSignal, onMount } from "solid-js";
import { parse } from "yaml";
import { configureEndpoints } from "../net/endpoints";
import { pushErrorToast } from "../ui/toast.js";

function ensureSlash(s) { return s.endsWith("/") ? s : s + "/"; }
const OVERRIDE_KEY = "connect_override";

function pickPersistable(cfg) { if (!cfg) return null; return { domain: cfg.domain || "", backendLink: ensureSlash(cfg.backendLink || "") }; }
function loadOverride() { try { const raw = localStorage.getItem(OVERRIDE_KEY); if (!raw) return null; return pickPersistable(JSON.parse(raw)); } catch { return null; } }
function saveOverride(obj) { try { if (!obj) localStorage.removeItem(OVERRIDE_KEY); else localStorage.setItem(OVERRIDE_KEY, JSON.stringify(pickPersistable(obj))); } catch { } }

export function useAppConnection() {
  const [config, setConfig] = createSignal(null);
  const [info, setInfo] = createSignal(null);
  const [error, setError] = createSignal(null);
  const [loading, setLoading] = createSignal(true);
  
  async function fetchInfo(cfg) {
    const res = await fetch(cfg.backendLink + "info", { headers: { Accept: "application/json" } });
    if (!res.ok) throw new Error(`/info failed: ${res.status}`);
    return await res.json();
  }

  async function applyConfig(nextCfg) {
    setConfig(nextCfg);
    const data = await fetchInfo(nextCfg);
    setInfo(data);
    configureEndpoints({ backendLink: nextCfg.backendLink, domain: nextCfg.domain || "" });
  }

  async function init() {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch("/default_connect.yaml", { cache: "no-store" });
      if (!res.ok) throw new Error(`YAML load failed: ${res.status}`);
      const data = parse(await res.text()) || {};
      if (!data.backendLink) throw new Error("Missing backendLink in config");

      const baseCfg = { domain: data.domain || "", backendLink: ensureSlash(data.backendLink), gear: !!data.gear };
      const merged = { ...baseCfg, ...loadOverride() };
      await applyConfig(merged);
    } catch (e) {
      setError(e);
    } finally {
      setLoading(false);
    }
  }

  onMount(init);

  async function updateConnect(partial) {
    try {
      setLoading(true); setError(null);
      const cur = config() || {};
      const next = { ...cur, ...partial, backendLink: ensureSlash(partial?.backendLink ?? cur.backendLink) };
      if (next.backendLink !== cur.backendLink) {
        await applyConfig(next);
      } else {
        setConfig(next);
        configureEndpoints({ backendLink: next.backendLink, domain: next.domain || "" });
      }
      saveOverride(next);
    } catch (e) {
      setError(e);
      pushErrorToast(e, { op: "updateConnect" });
    } finally { setLoading(false); }
  }

  function setDomain(nextDomain) {
    const cur = config() || {};
    const next = { ...cur, domain: nextDomain || "" };
    setConfig(next);
    saveOverride(next);
    configureEndpoints({ backendLink: next.backendLink, domain: next.domain || "" });
  }

  async function clearConnectOverride() {
    saveOverride(null);
    await init();
  }

  return { config, info, error, loading, init, updateConnect, clearConnectOverride, setDomain };
}
</file>

<file path="src/context/useDomainAssets.js">
// src/context/useDomainAssets.js
import { createSignal, createMemo, createResource, createEffect, on } from "solid-js";
import { parse } from "yaml";
import { fetchWithTimeout } from "../utils/net.js";
import { loadAssetResource } from "../utils/assetLoader.js";

const ASSETS_ENV_KEY = "domain_assets_env";
const DEFAULT_DOMAIN_ASSETS_PREFIX = "/domain_default/";

export function useDomainAssets(app) {
  const [assetsEnv, setAssetsEnvState] = createSignal(localStorage.getItem(ASSETS_ENV_KEY) || "prod");
  const [domainAssetsConfig, setDomainAssetsConfig] = createSignal(null);
  const [domainAssetsSource, setDomainAssetsSource] = createSignal(null);
  const [domainAssetsPrefix, setDomainAssetsPrefix] = createSignal(DEFAULT_DOMAIN_ASSETS_PREFIX);

  function setAssetsEnv(next) {
    const v = next === "test" ? "test" : "prod";
    localStorage.setItem(ASSETS_ENV_KEY, v);
    setAssetsEnvState(v);
  }

  const assetsBaseUrl = createMemo(() => {
    const info = app.info();
    if (!info) return "";
    const base = assetsEnv() === "test" ? info.temp_assets_url : info.assets_url;
    return base?.endsWith("/") ? base : (base || "") + "/";
  });

  const domainAssetsPrefixActive = createMemo(() => domainAssetsPrefix() || DEFAULT_DOMAIN_ASSETS_PREFIX);

  function assetUrl(relPath) {
    const rel = String(relPath || "").replace(/^\/+/, "");
    return (domainAssetsPrefixActive() || "") + rel;
  }

  async function refreshDomainAssets() {
    const base = assetsBaseUrl();
    const domain = app.selectedDomainName();
    const computed = base && domain ? `${base}${domain}/` : "";

    async function tryLoad(prefix) {
      if (!prefix) return null;
      try {
        const res = await fetchWithTimeout(`${prefix}config.yaml`, { timeoutMs: 8000, cache: "no-store" });
        return res.ok ? (parse(await res.text()) || {}) : null;
      } catch { return null; }
    }

    let cfg = await tryLoad(computed);
    if (cfg) {
      setDomainAssetsPrefix(computed);
      setDomainAssetsSource("domain");
    } else {
      cfg = await tryLoad(DEFAULT_DOMAIN_ASSETS_PREFIX);
      setDomainAssetsPrefix(DEFAULT_DOMAIN_ASSETS_PREFIX);
      setDomainAssetsSource(cfg ? "default" : null);
    }
    setDomainAssetsConfig(cfg || null);
  }

  const [domainDictionaries] = createResource(() => {
    const cfg = domainAssetsConfig();
    const locales = Array.isArray(cfg?.locales) ? cfg.locales : [];
    const items = locales.map(l => ({ code: (l?.code || "").toLowerCase(), path: l?.dictionary || l?.file })).filter(l => l.code && l.path);
    if (items.length === 0) return null;
    return { items, rev: `${domainAssetsPrefixActive()}|${cfg.assets_cid || cfg.cid || ""}` };
  }, async (key) => {
    if (!key) return {};
    const dicts = {};
    for (const { code, path } of key.items) {
      try {
        dicts[code] = await loadAssetResource({ assetUrl }, path, { type: "yaml" });
      } catch { /* ignore */ }
    }
    return dicts;
  });

  createEffect(() => app.i18n.setDomainDictionaries(domainDictionaries() || {}));
  
  createEffect(on([app.info, app.selectedDomainName, assetsEnv], () => {
    if (app.info()) {
      refreshDomainAssets();
    }
  }));

  return { assetsEnv, setAssetsEnv, assetsBaseUrl, domainAssetsConfig, domainAssetsSource, domainAssetsPrefix: domainAssetsPrefixActive, refreshDomainAssets, assetUrl };
}
</file>

<file path="src/docs/rehype-resolve-draft-urls.js">
// src/docs/rehype-resolve-draft-urls.js
import { visit } from "unist-util-visit";
import { resolveDraftFileUrl } from "../editor/storage.js";
import { dbg } from "../utils/debug.js";

const isRelative = (url) => typeof url === "string" && !/^(#|\/|[a-z]+:)/i.test(url);

/**
 * A rehype plugin factory. The plugin resolves relative media URLs 
 * from the specified draft storage directory.
 * @param {object} [options={}] - The options object.
 * @param {string} options.baseDir - The base draft directory (e.g., "new_post").
 */
export function rehypeResolveDraftUrls(options = {}) {
  const baseDir = options.baseDir;
  return async (tree) => {
    if (!tree || typeof tree !== "object" || !baseDir) {
      dbg.warn("PreviewResolver", "Invalid tree or missing baseDir; skipping URL resolution.");
      return tree;
    }

    const tasks = [];

    visit(tree, "element", (node) => {
      const prop = (node.tagName === 'a') ? 'href' : 'src';
      if (node.properties && prop in node.properties) {
        const url = node.properties[prop];
        if (isRelative(url)) {
          tasks.push(
            (async () => {
              const blobUrl = await resolveDraftFileUrl(baseDir, url);
              if (blobUrl) node.properties[prop] = blobUrl;
            })()
          );
        }
      }
    });

    if (tasks.length) {
      await Promise.allSettled(tasks);
    }

    return tree;
  };
}
</file>

<file path="src/editor/postImporter.js">
// src/editor/postImporter.js
import { dbg } from "../utils/debug.js";
import { ipfs } from "../ipfs/index.js";
import { parse, stringify } from "yaml";
import { DRAFT_DIRS, clearDraft, writeFile } from "./storage.js";
import { createTextPreview } from "./preview-utils.js";
import { getPostDescriptorPath, getPostContentBaseCid } from "../ipfs/utils.js";

async function fetchFile(app, post, descriptor, relativePath) {
  const contentBaseCid = getPostContentBaseCid(post);
  if (!contentBaseCid || !relativePath) return null;

  const fullPath = `${contentBaseCid}/${relativePath}`;
  dbg.log("Importer", `Fetching file at full path: ${fullPath}`);
  const postGateways = descriptor?.gateways || [];
  const { res } = await ipfs.fetchBest(app, fullPath, { postGateways });
  return res.blob();
}

// Helper to fetch a post object by its full Savva CID
async function fetchPostObject(app, savva_cid) {
  if (!app.wsMethod || !savva_cid) return null;
  const contentList = app.wsMethod("content-list");
  const requestParams = {
    domain: app.selectedDomainName(),
    savva_cid: savva_cid,
    limit: 1,
  };
  const res = await contentList(requestParams);
  const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];
  return arr[0] || null;
}

// Helper to find all referenced files in a post and copy them to a draft directory
async function importReferencedFiles(app, sourcePost, targetDirHandle) {
  if (!sourcePost) return;

  const descriptorPath = getPostDescriptorPath(sourcePost);
  if (!descriptorPath) return;

  const { res: descriptorRes } = await ipfs.fetchBest(app, descriptorPath);
  const descriptor = parse(await descriptorRes.text());
  if (!descriptor) return;

  const contentBaseCid = getPostContentBaseCid(sourcePost);
  if (!contentBaseCid) return;

  const relativePaths = new Set();
  if (descriptor.thumbnail) {
    relativePaths.add(descriptor.thumbnail);
  }

  const markdownStrings = [];
  if (descriptor.locales) {
    for (const langCode in descriptor.locales) {
      const locale = descriptor.locales[langCode];
      if (locale.data_path) {
        try {
          const content = await ipfs.fetchBest(app, `${contentBaseCid}/${locale.data_path}`).then(r => r.res.text());
          markdownStrings.push(content);
        } catch (e) { dbg.warn("Importer", `Could not fetch markdown for file scan: ${locale.data_path}`, e); }
      }
      if (Array.isArray(locale.chapters)) {
        for (const chapter of locale.chapters) {
          if (chapter.data_path) {
            try {
              const content = await ipfs.fetchBest(app, `${contentBaseCid}/${chapter.data_path}`).then(r => r.res.text());
              markdownStrings.push(content);
            } catch (e) { dbg.warn("Importer", `Could not fetch chapter for file scan: ${chapter.data_path}`, e); }
          }
        }
      }
    }
  }

  const combinedMarkdown = markdownStrings.join('\n');
  const pathRegex = /(?:src=["']|url\(|href=["']|\()(?<path>uploads\/[^"')]+)/g;
  let match;
  while ((match = pathRegex.exec(combinedMarkdown)) !== null) {
    if (match.groups.path) {
      relativePaths.add(match.groups.path);
    }
  }

  dbg.log("Importer", "Found relative file paths to import:", Array.from(relativePaths));
  if (relativePaths.size === 0) return;
  
  const uploadsDirHandle = await targetDirHandle.getDirectoryHandle(DRAFT_DIRS.UPLOADS, { create: true });
  for (const relPath of relativePaths) {
    try {
      const blob = await fetchFile(app, sourcePost, descriptor, relPath);
      if (blob) {
        const fileName = relPath.split('/').pop();
        await writeFile(uploadsDirHandle, fileName, blob);
        dbg.log("Importer", `Imported file: ${fileName}`);
      }
    } catch (e) {
      dbg.warn("Importer", `Failed to import referenced file: ${relPath}`, e);
    }
  }
}

/**
 * Prepares a published post for editing by fetching its contents and
 * writing them to the local 'post' draft directory.
 * @param {object} post - The raw post object from the backend.
 * @param {object} app - The main app context.
 * @returns {Promise<void>}
 */
export async function preparePostForEditing(post, app) {
  const baseDir = DRAFT_DIRS.EDIT;
  dbg.log("Importer", `Preparing post for editing: ${post.savva_cid}`);

  await clearDraft(baseDir);
  const dirHandle = await navigator.storage
    .getDirectory()
    .then((root) => root.getDirectoryHandle(baseDir, { create: true }));
  
  const isComment = !!post.parent_savva_cid;
  let fileSourceObject = post;

  if (isComment) {
    const rootCid = post.root_savva_cid || post.parent_savva_cid;
    if (rootCid) {
      dbg.log("Importer", `Comment detected. Fetching root post for files: ${rootCid}`);
      const rootPost = await fetchPostObject(app, rootCid);
      if (rootPost) {
        fileSourceObject = rootPost;
      } else {
        dbg.warn("Importer", "Could not fetch root post, file import will be skipped.");
      }
    }
  }

  await importReferencedFiles(app, fileSourceObject, dirHandle);

  const descriptorPath = getPostDescriptorPath(post);
  const { res: descriptorRes } = await ipfs.fetchBest(app, descriptorPath);
  const descriptorText = await descriptorRes.text();
  const descriptor = parse(descriptorText);
  if (!descriptor) throw new Error("Could not parse post descriptor.");
  dbg.log("Importer", "Parsed descriptor:", descriptor);

  const supportedLangs = (app.domainAssetsConfig()?.locales || []).map(
    (l) => l.code
  );
  const finalParams = {
    guid: post.guid,
    originalSavvaCid: post.savva_cid,
    nsfw: descriptor.nsfw || false,
    fundraiser: descriptor.fundraiser || 0,
    publishAsNewPost: false,
    locales: {},
    thumbnail: descriptor.thumbnail || null,
  };

  if (descriptor.parent_savva_cid) {
    finalParams.parent_savva_cid = descriptor.parent_savva_cid;
  }
  if (descriptor.root_savva_cid) {
    finalParams.root_savva_cid = descriptor.root_savva_cid;
  }

  const finalDescriptor = {
    savva_spec_version: descriptor.savva_spec_version || "2.0",
    data_cid: getPostContentBaseCid(post),
    locales: {},
  };

  for (const lang of supportedLangs) {
    if (!descriptor.locales?.[lang]) continue;
    dbg.log("Importer", `Processing lang: ${lang}`);

    const localeDesc = descriptor.locales[lang];
    finalParams.locales[lang] = {
      tags: localeDesc.tags || [],
      categories: localeDesc.categories || [],
      chapters: [],
    };
    finalDescriptor.locales[lang] = {
      title: localeDesc.title,
      text_preview: createTextPreview(localeDesc.body || ""),
      data_path: `${lang}/data.md`,
      chapters: [],
    };

    const bodyBlob = await fetchFile(
      app,
      post,
      descriptor,
      localeDesc.data_path
    );
    if (bodyBlob) {
      await writeFile(dirHandle, `${lang}/data.md`, bodyBlob);
      dbg.log(
        "Importer",
        `Wrote file: ${lang}/data.md, size: ${bodyBlob.size}`
      );
    }

    if (Array.isArray(localeDesc.chapters)) {
      for (let i = 0; i < localeDesc.chapters.length; i++) {
        const chapter = localeDesc.chapters[i];
        finalParams.locales[lang].chapters.push({ title: chapter.title });
        const chapterPath = `${lang}/chapters/${i + 1}.md`;
        finalDescriptor.locales[lang].chapters.push({ data_path: chapterPath });
        const chapterBlob = await fetchFile(
          app,
          post,
          descriptor,
          chapter.data_path
        );
        if (chapterBlob) {
          await writeFile(dirHandle, chapterPath, chapterBlob);
          dbg.log(
            "Importer",
            `Wrote file: ${chapterPath}, size: ${chapterBlob.size}`
          );
        }
      }
    }
  }

  if (finalParams.thumbnail) {
    const thumbBlob = await fetchFile(
      app,
      post,
      descriptor,
      finalParams.thumbnail
    );
    if (thumbBlob) {
      const thumbName = finalParams.thumbnail.split("/").pop();
      const newThumbPath = `${DRAFT_DIRS.UPLOADS}/${thumbName}`;
      await writeFile(dirHandle, newThumbPath, thumbBlob);
      finalParams.thumbnail = newThumbPath;
      dbg.log(
        "Importer",
        `Wrote thumbnail: ${newThumbPath}, size: ${thumbBlob.size}`
      );
    }
  }

  dbg.log("Importer:finalParams", "Params being saved to draft:", finalParams);
  await writeFile(dirHandle, "info.yaml", stringify(finalDescriptor));
  await writeFile(
    dirHandle,
    "params.json",
    JSON.stringify(finalParams, null, 2)
  );

  dbg.log("Importer", "Post successfully imported for editing.");
}
</file>

<file path="src/editor/preview-utils.js">
// src/editor/preview-utils.js

const PREVIEW_LENGTH = 512;

/**
 * Creates a plain-text preview for posts, stripping all Markdown.
 * @param {string} markdownText - The input Markdown string.
 * @returns {string} A plain-text preview.
 */
function createPostPreview(markdownText) {
  if (!markdownText) return "";

  let plainText = markdownText
    .replace(/^#+\s+/gm, '') // Headers
    .replace(/!\[.*?\]\(.*?\)/g, '') // Images, remove everything
    .replace(/\[.*?\]\(.*?\)/g, '') // Links, remove everything
    .replace(/(\*\*|__|\*|_|~~)(.*?)\1/g, '$2') // Bold, italic, strikethrough
    .replace(/`([^`]+)`/g, '$1') // Inline code
    .replace(/^\>\s+/gm, '') // Blockquotes
    .replace(/^(-{3,}|\*{3,}|_{3,})$/gm, '') // Horizontal rules
    .replace(/^\s*[-*+]\s+/gm, '') // List markers
    .replace(/^\s*\d+\.\s+/gm, '') // Numbered list markers
    .replace(/\s+/g, ' ') // Collapse multiple whitespace
    .trim();

  if (plainText.length > PREVIEW_LENGTH) {
    plainText = plainText.substring(0, PREVIEW_LENGTH).trim() + '...';
  }

  return plainText;
}

/**
 * Creates a preview for comments, preserving Markdown but truncating intelligently.
 * It avoids cutting inside a Markdown tag.
 * @param {string} markdownText - The input Markdown string.
 * @returns {string} A truncated Markdown preview.
 */
function createCommentPreview(markdownText) {
  if (!markdownText) return "";
  if (markdownText.length <= PREVIEW_LENGTH) {
    return markdownText;
  }

  // Tokenizes markdown into whole tags, code blocks, links, words, and whitespace.
  const tokenRegex = /(\[.*?\]\(.*?\)|!\[.*?\]\(.*?\)|`[^`]+`|\*\*.*?\*\*|__.*?__|~~.*?~~|\*.*?\*|_.*?_|\s+|[^\s]+)/g;
  const tokens = markdownText.match(tokenRegex) || [];
  
  let result = "";
  for (const token of tokens) {
    if ((result + token).length > PREVIEW_LENGTH) {
      break;
    }
    result += token;
  }

  // Trim trailing whitespace and add ellipsis if truncated
  result = result.trim();
  if (result.length < markdownText.length) {
    result += "...";
  }

  return result;
}

/**
 * Creates a text preview from Markdown content.
 * The behavior depends on the type ('post' or 'comment').
 * @param {string} markdownText - The input Markdown string.
 * @param {'post' | 'comment'} [type='post'] - The type of content.
 * @returns {string} A text preview.
 */
export function createTextPreview(markdownText, type = 'post') {
  if (type === 'comment') {
    return createCommentPreview(markdownText);
  }
  return createPostPreview(markdownText);
}
</file>

<file path="src/pages/ProfilePage.jsx">
// src/pages/ProfilePage.jsx
import { createMemo, createResource, createSignal, Show, Switch, Match, createEffect } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import { useHashRouter, navigate } from "../routing/hashRouter.js";
import ClosePageButton from "../components/ui/ClosePageButton.jsx";
import Spinner from "../components/ui/Spinner.jsx";
import IpfsImage from "../components/ui/IpfsImage.jsx";
import UnknownUserIcon from "../components/ui/icons/UnknownUserIcon.jsx";
import StakerLevelIcon from "../components/ui/StakerLevelIcon.jsx";
import VerifiedBadge from "../components/ui/icons/VerifiedBadge.jsx";
import Tabs from "../components/ui/Tabs.jsx";
import Address from "../components/ui/Address.jsx";
import { ipfs } from "../ipfs/index.js";
import { PostsIcon, SubscribersIcon, SubscriptionsIcon, WalletIcon } from "../components/ui/icons/ProfileIcons.jsx";
import PostsTab from "../components/profile/PostsTab.jsx";
import SubscribersTab from "../components/profile/SubscribersTab.jsx";
import SubscriptionsTab from "../components/profile/SubscriptionsTab.jsx";
import WalletTab from "../components/profile/WalletTab.jsx";
import TokenValue from "../components/ui/TokenValue.jsx";
import { walletAccount } from "../blockchain/wallet.js";

// Data fetcher for the user profile
async function fetchUserProfile({ app, identifier }) {
  if (!identifier || !app.wsCall) return null;

  try {
    const wsParams = { domain: app.selectedDomainName() };
    const currentUser = app.authorizedUser();
    if (currentUser) {
      wsParams.caller = currentUser.address;
    }

    if (identifier.startsWith('@')) {
      wsParams.user_name = identifier.substring(1);
    } else {
      wsParams.user_addr = identifier;
    }

    return await app.wsCall('get-user', wsParams);
  } catch (error) {
    console.error("Failed to fetch user profile:", error);
    return { error: error.message };
  }
}

// Data fetcher for the profile details from IPFS
async function fetchProfileDetails(cid, app) {
  if (!cid) return null;
  try {
    const { data } = await ipfs.getJSONBest(app, cid);
    return data;
  } catch (e) {
    console.error(`Failed to fetch profile details from IPFS CID: ${cid}`, e);
    return { error: e.message };
  }
}

export default function ProfilePage() {
  const app = useApp();
  const { t } = app;
  const { route } = useHashRouter();

  const identifier = createMemo(() => {
    const path = route();
    return path.startsWith('/') ? path.substring(1) : path;
  });

  const [userResource] = createResource(() => ({ app, identifier: identifier() }), fetchUserProfile);
  const [profileDetails] = createResource(() => userResource()?.profile_cid, (cid) => fetchProfileDetails(cid, app));
  
  const [activeTab, setActiveTab] = createSignal('posts');
  
  const TABS = createMemo(() => {
    const tabs = [
      { id: 'posts', label: t("profile.tabs.posts"), icon: <PostsIcon /> },
      { id: 'subscribers', label: t("profile.tabs.subscribers"), icon: <SubscribersIcon /> },
      { id: 'subscriptions', label: t("profile.tabs.subscriptions"), icon: <SubscriptionsIcon /> },
    ];

    if (walletAccount()) {
      tabs.push({ id: 'wallet', label: t("profile.tabs.wallet"), icon: <WalletIcon /> });
    }

    return tabs;
  });
  
  createEffect(() => {
    const availableTabs = TABS();
    const currentActive = activeTab();
    if (!availableTabs.some(tab => tab.id === currentActive)) {
        setActiveTab('posts');
    }
  });

  const aboutText = createMemo(() => {
    const details = profileDetails();
    if (!details || !details.about) return "";

    const aboutData = details.about;
    if (typeof aboutData === 'string') {
      return aboutData;
    }
    if (typeof aboutData === 'object') {
      const lang = app.lang();
      return aboutData[lang] || aboutData.en || Object.values(aboutData)[0] || "";
    }
    return "";
  });
  
  const isSubscribed = createMemo(() => {
      const u = userResource();
      return u && u.i_sponsor_for > 0;
  });

  return (
    <main class="sv-container p-4 max-w-4xl mx-auto">
      <ClosePageButton />
      
      <Switch>
        <Match when={userResource.loading}>
          <div class="flex justify-center items-center h-64"><Spinner class="w-8 h-8" /></div>
        </Match>
        <Match when={userResource.error || userResource()?.error}>
          <div class="p-4 rounded border text-center border-[hsl(var(--destructive))] bg-[hsl(var(--card))]">
            <h3 class="font-semibold text-[hsl(var(--destructive))]">{t("profile.error.title")}</h3>
            <p class="text-sm mt-1">{userResource.error?.message || userResource()?.error}</p>
          </div>
        </Match>
        <Match when={userResource()}>
          {(user) =>
            <div class="space-y-6">
              {/* Profile Header */}
              <div class="flex flex-col sm:flex-row items-center sm:items-start gap-6">
                <div class="flex flex-col items-center gap-4 shrink-0">
                  <div class="w-48 h-48 sm:w-56 sm:h-56 rounded-2xl overflow-hidden bg-[hsl(var(--muted))] border-2 border-[hsl(var(--border))]">
                    <IpfsImage 
                      src={user().avatar}
                      alt={`${user().name} avatar`}
                      class="w-full h-full object-cover"
                      fallback={<UnknownUserIcon class="w-full h-full text-[hsl(var(--muted-foreground))]" />}
                    />
                  </div>
                  <Show when={app.authorizedUser() && app.authorizedUser().address.toLowerCase() !== user().address.toLowerCase()}>
                    <Show 
                      when={!isSubscribed()}
                      fallback={
                        <button class="w-full px-4 py-2 rounded-md bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))]">
                          {t("profile.unsubscribe")}
                        </button>
                      }
                    >
                      <button class="w-full px-4 py-2 rounded-md bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] font-semibold">
                        {t("profile.subscribe")}
                      </button>
                    </Show>
                  </Show>
                </div>
                
                <div class="flex-1 w-full text-center sm:text-left space-y-3">
                  <div class="flex flex-col items-center sm:items-start">
                    <h2 class="text-2xl font-bold">{user().display_name || user().name}</h2>
                    <Show when={user().name}>
                      <div class="flex items-center gap-1 text-sm text-[hsl(var(--muted-foreground))]">
                        <span>{user().name.toUpperCase()}</span>
                        <VerifiedBadge class="w-4 h-4" />
                      </div>
                    </Show>
                    <div class="mt-1">
                      <Address address={user().address} format="full" />
                    </div>
                    <div class="flex items-center gap-2 mt-2 text-sm">
                      <span class="text-[hsl(var(--muted-foreground))]">{t("profile.stats.staking")}:</span>
                      <TokenValue amount={user().staked} />
                      <StakerLevelIcon staked={user().staked} class="w-5 h-5" />
                    </div>
                    <div class="flex items-center gap-2 mt-1 text-sm">
                      <span class="text-[hsl(var(--muted-foreground))]">{t("profile.stats.paysForSubscriptions")}:</span>
                      <TokenValue amount={user().total_sponsoring} />
                      <span class="text-[hsl(var(--muted-foreground))] text-sm ml-1">{t("profile.stats.perWeek")}</span>
                    </div>
                    <div class="flex items-center gap-2 mt-1 text-sm">
                      <span class="text-[hsl(var(--muted-foreground))]">{t("profile.stats.receivedFromSubscribers")}:</span>
                      <TokenValue amount={user().total_sponsored} />
                      <span class="text-[hsl(var(--muted-foreground))] text-sm ml-1">{t("profile.stats.perWeek")}</span>
                    </div>
                  </div>

                  <Show when={aboutText()}>
                    <p class="text-sm pt-2 text-[hsl(var(--foreground))]">{aboutText()}</p>
                  </Show>
                </div>
              </div>

              {/* Profile Tabs */}
              <div>
                <Tabs items={TABS()} value={activeTab()} onChange={setActiveTab} compactWidth={640} />
                <div class="py-4 border-x border-b border-[hsl(var(--border))] rounded-b-lg">
                  <Switch>
                    <Match when={activeTab() === 'posts'}>
                      <PostsTab user={user()} />
                    </Match>
                    <Match when={activeTab() === 'subscribers'}>
                      <SubscribersTab user={user()} />
                    </Match>
                    <Match when={activeTab() === 'subscriptions'}>
                      <SubscriptionsTab user={user()} />
                    </Match>
                    <Match when={activeTab() === 'wallet'}>
                      <WalletTab user={user()} />
                    </Match>
                  </Switch>
                </div>
              </div>
            </div>
          }
        </Match>
      </Switch>
    </main>
  );
}
</file>

<file path="public/dev_docs/fr/sidebar.yaml">
sections:
  - title: Commencer
    items:
      - label: Aperçu
        file: index.md
      - label: Configuration
        file: getting-started.md
  - title: Concepts de base
    items:
      - label: Aperçu
        file: core-concepts/index.md
      - label: Initialisation de l'application et connexion au backend
        file: core-concepts/app-init.md
      - label: Travailler avec des domaines
        file: core-concepts/domain.md
      - label: Authentification
        file: core-concepts/auth.md
      - label: Afficher les publications
        file: core-concepts/showing-posts.md
      - label: Publier des publications
        file: core-concepts/publishing-posts.md
      - label: Contrat de configuration
        file: core-concepts/config-contract.md
</file>

<file path="public/dev_docs/ru/sidebar.yaml">
sections:
  - title: Начало работы
    items:
      - label: Обзор
        file: index.md
      - label: Настройка
        file: getting-started.md
  - title: Основные концепции
    items:
      - label: Обзор
        file: core-concepts/index.md
      - label: Инициализация приложения и подключение к бэкенду
        file: core-concepts/app-init.md
      - label: Работа с доменами
        file: core-concepts/domain.md
      - label: Аутентификация
        file: core-concepts/auth.md
      - label: Показ постов
        file: core-concepts/showing-posts.md
      - label: Публикация постов
        file: core-concepts/publishing-posts.md
      - label: Контракт конфигурации
        file: core-concepts/config-contract.md
</file>

<file path="public/dev_docs/sr/sidebar.yaml">
sections:
  - title: Uvod
    items:
      - label: Pregled
        file: index.md
      - label: Podešavanje
        file: getting-started.md
  - title: Osnovni koncepti
    items:
      - label: Pregled
        file: core-concepts/index.md
      - label: Inicijalizacija aplikacije i povezivanje sa backend-om
        file: core-concepts/app-init.md
      - label: Rad sa domenima
        file: core-concepts/domain.md
      - label: Autentifikacija
        file: core-concepts/auth.md
      - label: Prikazivanje postova
        file: core-concepts/showing-posts.md
      - label: Objavljivanje postova
        file: core-concepts/publishing-posts.md
      - label: Ugovor o konfiguraciji
        file: core-concepts/config-contract.md
</file>

<file path="public/dev_docs/ua/sidebar.yaml">
sections:
  - title: Початок роботи
    items:
      - label: Огляд
        file: index.md
      - label: Налаштування
        file: getting-started.md
  - title: Основні концепції
    items:
      - label: Огляд
        file: core-concepts/index.md
      - label: Ініціалізація додатку та підключення до бекенду
        file: core-concepts/app-init.md
      - label: Робота з доменами
        file: core-concepts/domain.md
      - label: Аутентифікація
        file: core-concepts/auth.md
      - label: Показ постів
        file: core-concepts/showing-posts.md
      - label: Публікація постів
        file: core-concepts/publishing-posts.md
      - label: Контракт конфігурації
        file: core-concepts/config-contract.md
</file>

<file path="scripts/i18n.mjs">
// scripts/i18n.mjs
import fs from "node:fs";
import path from "node:path";
import { pathToFileURL } from "node:url";
import dotenv from "dotenv";
import OpenAI from "openai";

// ---------- Config ----------
const ROOT = process.cwd();
dotenv.config({ path: path.join(ROOT, ".env") });

const SRC_DIR = path.join(ROOT, "src");
const I18N_DIR = path.join(SRC_DIR, "i18n");
const OPENAI_KEY = process.env.OPENAI_API_KEY || "";
const OPENAI_MODEL = process.env.OPENAI_MODEL || "gpt-4o-mini";
const BATCH_SIZE = 60; // how many keys to ask the model about per request
const targetLang = process.argv[2] || null;
const onlyEnglish = targetLang === "en";

// ---------- Collect used keys (scan t("key") calls) ----------
const exts = [".js", ".jsx", ".ts", ".tsx"];
const usedKeys = new Set();

/**
 * Finds t('foo.bar'), t("foo.bar") and t(`foo.bar`) with static literals only.
 * (If you build keys dynamically, they won’t be picked up by any static scan.)
 */
const T_CALL = /\b(?:i18n\.)?t\(\s*([`'"])([^`'"]+)\1\s*\)/g;

function walk(dir) {
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const p = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      if (entry.name === "node_modules" || entry.name === "dist") continue;
      walk(p);
    } else if (exts.includes(path.extname(entry.name))) {
      const text = fs.readFileSync(p, "utf8");
      let m;
      while ((m = T_CALL.exec(text))) {
        usedKeys.add(m[2]);
      }
    }
  }
}

walk(SRC_DIR);

// ---------- Helpers to load & write lang files ----------
function isLangFile(name) {
  return name.endsWith(".js") && !/useI18n\.js$/i.test(name);
}
function toModuleURL(filePath) {
  return pathToFileURL(filePath).href;
}
async function loadLang(filePath) {
  const mod = await import(toModuleURL(filePath));
  const dict = mod?.default || {};
  const normalized = {};
  for (const [k, v] of Object.entries(dict)) {
    normalized[k] = typeof v === "string" ? v : String(v);
  }
  return normalized;
}
function writeLang(filePath, obj) {
  const sorted = Object.keys(obj)
    .sort()
    .reduce((acc, k) => {
      acc[k] = obj[k];
      return acc;
    }, {});
  const body =
    "// Auto-generated by scripts/i18n.mjs. Do not edit by hand.\n" +
    "export default " +
    JSON.stringify(sorted, null, 2) +
    ";\n";
  fs.writeFileSync(filePath, body, "utf8");
}

// ---------- OpenAI helpers ----------
let openai = null;
if (OPENAI_KEY) {
  openai = new OpenAI({ apiKey: OPENAI_KEY });
}

function chunk(arr, size) {
  const out = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

async function askJson(prompt, schemaHint = "an object mapping keys to strings") {
  if (!openai) return {};
  const res = await openai.chat.completions.create({
    model: OPENAI_MODEL,
    temperature: 0.2,
    response_format: { type: "json_object" },
    messages: [
      {
        role: "system",
        content:
          `You are a localization copywriter for a web app. ` +
          `Return ONLY valid JSON (${schemaHint}). Keep strings concise, natural, and product-quality. ` +
          `Preserve punctuation, capitalization, and any placeholders like {name}, {amount}, {n}, %s, %d exactly. ` +
          `Do not add extra keys.`,
      },
      { role: "user", content: prompt },
    ],
  });
  const text = res.choices?.[0]?.message?.content || "{}";
  try {
    return JSON.parse(text);
  } catch {
    return {};
  }
}

async function fillEnglish(keys) {
  const out = {};
  for (const group of chunk(keys, BATCH_SIZE)) {
    const prompt =
      `For each key, produce an English UI string (microcopy). ` +
      `Be terse where appropriate (button labels, placeholders) and clear for longer texts.\n\n` +
      JSON.stringify({ keys: group }, null, 2);
    const json = await askJson(prompt);
    Object.assign(out, json);
  }
  return out;
}

async function translateTo(langCode, englishPairs) {
  const out = {};
  const keys = Object.keys(englishPairs);
  for (const keyGroup of chunk(keys, BATCH_SIZE)) {
    const batchToTranslate = {};
    for (const k of keyGroup) {
      batchToTranslate[k] = englishPairs[k];
    }
    const prompt =
      `Translate the values in the following JSON object to ${langCode}. ` +
      `Return a JSON object with the same keys, but with translated string values. ` +
      `Keep placeholders (like {amount}, {n}, %s, %d) unchanged. ` +
      `Use natural ${langCode} for a consumer web app (not formal/legal).\n\n` +
      JSON.stringify(batchToTranslate, null, 2);
    const json = await askJson(prompt);
    Object.assign(out, json);
  }
  return out;
}

// ---------- Main ----------
(async function main() {
  // Sanity
  if (!fs.existsSync(I18N_DIR)) {
    console.error(`[i18n] Not found: ${path.relative(ROOT, I18N_DIR)}`);
    process.exit(1);
  }

  const langFiles = fs.readdirSync(I18N_DIR).filter(isLangFile);
  if (langFiles.length === 0) {
    console.error("[i18n] No language files found in src/i18n");
    process.exit(1);
  }

  const enPath = path.join(I18N_DIR, "en.js");
  if (!fs.existsSync(enPath)) {
    console.error("[i18n] Missing src/i18n/en.js (source of truth)");
    process.exit(1);
  }

  // Load all dicts
  const dicts = {};
  for (const f of langFiles) {
    dicts[f] = await loadLang(path.join(I18N_DIR, f));
  }

  const desiredKeys = new Set(usedKeys);

  // ---------- 1) Clean English (keep only used, mark missing & "???" as missing) ----------
  const enOrig = dicts["en.js"] || {};
  const enNew = {};
  const missingEn = [];

  for (const k of desiredKeys) {
    const v = enOrig[k];
    const isMissingValue =
      v == null || (typeof v === "string" && (v.trim() === "" || v.trim() === "???"));
    if (isMissingValue) {
      enNew[k] = "???";
      missingEn.push(k);
    } else {
      enNew[k] = v;
    }
  }

  writeLang(enPath, enNew);

  // ---------- 2) Fill English "???" via OpenAI ----------
  if (missingEn.length > 0) {
    if (!openai) {
      console.warn(
        "[i18n] OPENAI_API_KEY not set; skip filling English. Set it in .env to auto-fill."
      );
    } else {
      console.log(`[i18n] Filling ${missingEn.length} missing English strings...`);
      const filled = await fillEnglish(missingEn);
      let filledCount = 0;
      for (const k of missingEn) {
        const candidate = filled[k];
        if (typeof candidate === "string" && candidate.trim()) {
          enNew[k] = candidate.trim();
          filledCount++;
        }
      }
      if (filledCount > 0) {
        writeLang(enPath, enNew);
        console.log(`[i18n] Filled ${filledCount} English strings.`);
      }
    }
  } else {
    console.log("[i18n] No missing English strings to fill.");
  }

  // ---------- 2.5) Detect 'force retranslate' flags on English ('!…') ----------
  // Only applicable when NOT in en-only mode.
  const flaggedKeys = new Set();
  const cleanFlagText = {};
  if (!onlyEnglish) {
    for (const k of Object.keys(enNew)) {
      const v = enNew[k];
      if (typeof v === "string" && v.startsWith("!")) {
        flaggedKeys.add(k);
        cleanFlagText[k] = v.slice(1).trim(); // the source text to re-translate from English
      }
    }
  }

  // ---------- 3) For each non-English, prune + add "???" + translate from English ----------
  if (onlyEnglish) {
    console.log("[i18n] 'en' parameter detected. Skipping translation for other languages.");
    return;
  }

  // We'll track which flagged keys succeeded in ALL languages,
  // so we can safely strip '!' from English afterwards.
  const maybeStripBang = new Set(flaggedKeys); // remove any key that fails in a language

  for (const f of langFiles) {
    if (f === "en.js") continue;

    const langPath = path.join(I18N_DIR, f);
    const langCode = path.basename(f, ".js");
    const langDict = dicts[f] || {};

    // Prune/prepare
    const out = {};
    const toTranslate = {};

    for (const k of desiredKeys) {
      const v = langDict[k];
      const enVal = enNew[k];

      // Should we force re-translate this key (English starts with '!')?
      const forceRetranslate = flaggedKeys.has(k);

      // Missing?
      const isMissing =
        v == null ||
        (typeof v === "string" && (v.trim() === "" || v.trim() === "???"));

      if (forceRetranslate) {
        // Mark as missing to ensure we overwrite; queue clean English for translation
        out[k] = "???";
        if (cleanFlagText[k]) toTranslate[k] = cleanFlagText[k];
      } else if (isMissing) {
        out[k] = "???";
        if (typeof enVal === "string" && enVal.trim() && enVal !== "???") {
          toTranslate[k] = enVal;
        }
      } else {
        out[k] = v;
      }
    }

    writeLang(langPath, out);
    const toTranslateCount = Object.keys(toTranslate).length;

    if (toTranslateCount === 0) {
      console.log(`[i18n] ${langCode}: nothing to translate.`);
      // If there are flagged keys but nothing to translate for this lang,
      // we consider it a failure for those keys because they remained as-is.
      for (const k of flaggedKeys) {
        if (out[k] === "???") maybeStripBang.delete(k);
      }
      continue;
    }

    if (!openai) {
      console.warn(`[i18n] ${langCode}: OPENAI_API_KEY not set; skip translation.`);
      // Mark all flagged keys as failed for this language.
      for (const k of flaggedKeys) {
        if (out[k] === "???") maybeStripBang.delete(k);
      }
      continue;
    }

    console.log(`[i18n] ${langCode}: translating ${toTranslateCount} keys...`);
    const translated = await translateTo(langCode, toTranslate);
    let translatedCount = 0;

    for (const key of Object.keys(toTranslate)) {
      const t = translated[key];
      if (typeof t === "string" && t.trim()) {
        out[key] = t.trim();
        translatedCount++;
      } else {
        // translation for this key failed → don't strip '!' later
        if (flaggedKeys.has(key)) maybeStripBang.delete(key);
      }
    }

    // Any flagged key that still left as "???" is a failure for this language
    for (const k of flaggedKeys) {
      if (out[k] === "???") maybeStripBang.delete(k);
    }

    if (translatedCount > 0) {
      writeLang(langPath, out);
    }
    console.log(`[i18n] ${langCode}: translated ${translatedCount} keys.`);
  }

  // ---------- 4) If all non-English languages were updated for a flagged key, strip '!' in English ----------
  if (maybeStripBang.size > 0) {
    let changed = 0;
    for (const k of maybeStripBang) {
      const v = enNew[k];
      if (typeof v === "string" && v.startsWith("!")) {
        const cleaned = v.slice(1).trim();
        enNew[k] = cleaned || v; // don't produce empty
        changed++;
      }
    }
    if (changed > 0) {
      writeLang(enPath, enNew);
      console.log(`[i18n] Removed leading '!' from ${changed} English key(s) after successful re-translation.`);
    }
  }
})().catch((err) => {
  console.error(err);
  process.exit(1);
});
</file>

<file path="src/components/auth/AuthorizedUser.jsx">
// src/components/auth/AuthorizedUser.jsx
import { createSignal, Show, onMount, onCleanup } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import IpfsImage from "../ui/IpfsImage.jsx";
import UnknownUserIcon from "../ui/icons/UnknownUserIcon.jsx";
import { navigate } from "../../routing/hashRouter.js";

function ChevronDownIcon(props) {
  return (
    <svg viewBox="0 0 16 16" class={props.class || "w-4 h-4"} aria-hidden="true" fill="currentColor">
      <path d="M8 11.25a.75.75 0 01-.53-.22l-4-4a.75.75 0 111.06-1.06L8 9.94l3.47-3.47a.75.75 0 111.06 1.06l-4 4a.75.75 0 01-.53.22z"></path>
    </svg>
  );
}

export default function AuthorizedUser() {
  const app = useApp();
  const { t } = app;
  const [menuOpen, setMenuOpen] = createSignal(false);
  let menuRef;
  
  const user = () => app.authorizedUser();

  const handleLogoutClick = () => {
    app.logout();
    setMenuOpen(false);
  };

  const handleProfileClick = () => {
    const u = user();
    if (!u) return;
    const path = u.name ? `/@${u.name}` : `/${u.address}`;
    navigate(path);
    setMenuOpen(false);
  };
  
  const handleClickOutside = (event) => {
    if (menuRef && !menuRef.contains(event.target)) {
      setMenuOpen(false);
    }
  };

  onMount(() => document.addEventListener("mousedown", handleClickOutside));
  onCleanup(() => document.removeEventListener("mousedown", handleClickOutside));

  return (
    <div class="relative" ref={menuRef}>
      <Show when={user()}>
        <button
          class="flex items-center gap-1 p-0.5 rounded-full border-2 border-transparent hover:border-[hsl(var(--primary))]"
          onClick={() => setMenuOpen(!menuOpen())}
          aria-haspopup="true"
          aria-expanded={menuOpen()}
        >
          <div class="w-7 h-7 rounded-full overflow-hidden shrink-0 bg-[hsl(var(--muted))]">
            <IpfsImage
              src={user().avatar}
              alt="User Avatar"
              class="w-full h-full object-cover"
              fallback={<UnknownUserIcon class="w-full h-full object-cover" />}
            />
          </div>
          <ChevronDownIcon class="w-4 h-4 text-[hsl(var(--muted-foreground))]" />
        </button>
      </Show>

      <Show when={menuOpen()}>
        <div class="absolute top-full right-0 mt-2 w-48 rounded-md shadow-lg bg-[hsl(var(--popover))] text-[hsl(var(--popover-foreground))] ring-1 ring-black ring-opacity-5 z-50">
          <div class="py-1" role="menu" aria-orientation="vertical">
            <a
              href="#"
              class="block px-4 py-2 text-sm hover:bg-[hsl(var(--accent))]"
              role="menuitem"
              onClick={(e) => { e.preventDefault(); handleProfileClick(); }}
            >
              {t("header.myProfile")}
            </a>
            <a
              href="#"
              class="block px-4 py-2 text-sm hover:bg-[hsl(var(--accent))]"
              role="menuitem"
              onClick={(e) => { e.preventDefault(); handleLogoutClick(); }}
            >
              {t("header.logout")}
            </a>
          </div>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/docs/DocsContent.jsx">
// src/components/docs/DocsContent.jsx
import { createMemo, createResource, Show } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import MarkdownView from "./MarkdownView.jsx";
import DocsPager from "./DocsPager.jsx";

async function fetchMd({ lang, relPath }) {
  const clean = String(relPath || "index.md").replace(/^\/*/, "");
  const res = await fetch(`/dev_docs/${lang}/${clean}`, { cache: "no-store" });
  if (!res.ok) return { ok: false, text: `# 404\n\n/dev_docs/${lang}/${clean}` };
  return { ok: true, text: await res.text() };
}

export default function DocsContent(props) {
  const app = useApp();
  const lang = createMemo(() => (app.lang?.() || "en").toLowerCase());
  const params = createMemo(() => ({ lang: lang(), relPath: props.relPath }));
  const [doc] = createResource(params, fetchMd);

  return (
    <div class="p-4">
      <Show when={!doc.loading} fallback={
        <div class="text-sm text-[hsl(var(--muted-foreground))]">{app.t("common.loading")}</div>
      }>
        <MarkdownView markdown={doc()?.text || ""} />
        <DocsPager activeRelPath={props.relPath} onPick={props.onPick} />
      </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/wizard_steps/StepUploadIPFS.jsx">
// src/components/editor/wizard_steps/StepUploadIPFS.jsx
import { createSignal, onMount, Show } from "solid-js";
import { useApp } from "../../../context/AppContext.jsx";
import Spinner from "../../ui/Spinner.jsx";
import { getAllUploadedFileNames, getUploadedFileAsFileObject, DRAFT_DIRS } from "../../../editor/storage.js";
import { httpBase } from "../../../net/endpoints.js";
import { dbg } from "../../../utils/debug.js";
import { isPinningEnabled, getPinningServices } from "../../../ipfs/pinning/storage.js";
import { pinDirectory } from "../../../ipfs/pinning/manager.js";
import { fetchWithTimeout } from "../../../utils/net.js";

export default function StepUploadIPFS(props) {
  const app = useApp();
  const { t } = app;
  const [error, setError] = createSignal(null);
  const [isUploading, setIsUploading] = createSignal(true);
  const [uploadProgress, setUploadProgress] = createSignal(0);
  const [uploadMessage, setUploadMessage] = createSignal(t("editor.publish.uploadingToIpfs"));

  const getFilesFromDraft = async () => {
    const { postData, editorMode } = props;
    const files = [];
    
    const baseDir = (() => {
      if (editorMode === "new_post") return DRAFT_DIRS.NEW_POST;
      if (editorMode === "new_comment") return DRAFT_DIRS.NEW_COMMENT;
      if (["edit_post", "edit_comment"].includes(editorMode)) return DRAFT_DIRS.EDIT;
      return "unknown";
    })();

    const content = postData();
    for (const lang in content) {
      const data = content[lang];
      const path = `${lang}/data.md`;
      files.push({ file: new File([data.body || ""], path, { type: 'text/markdown' }), path });

      if (Array.isArray(data.chapters)) {
        for (let i = 0; i < data.chapters.length; i++) {
          const chapterPath = `${lang}/chapters/${i + 1}.md`;
          files.push({ file: new File([data.chapters[i].body || ""], chapterPath, { type: 'text/markdown' }), path: chapterPath });
        }
      }
    }

    const assetNames = await getAllUploadedFileNames(baseDir);
    for (const name of assetNames) {
      const file = await getUploadedFileAsFileObject(baseDir, name);
      if (file) {
        files.push({ file, path: `uploads/${name}` });
      }
    }
    return files;
  };

  const uploadToPinningServices = async () => {
    setUploadMessage(t("editor.publish.uploadingToPinServices"));
    const services = getPinningServices();
    if (services.length === 0) {
      throw new Error(t("editor.publish.ipfs.errorNoServices"));
    }

    const filesToUpload = await getFilesFromDraft();
    const progressMap = new Map(services.map(s => [s.id, 0]));

    const updateTotalProgress = () => {
      const sum = Array.from(progressMap.values()).reduce((a, b) => a + b, 0);
      setUploadProgress(Math.round(sum / services.length));
    };

    const cids = await Promise.all(services.map(async (service) => {
      try {
        const cid = await pinDirectory(service, filesToUpload, {
          onProgress: (p) => {
            progressMap.set(service.id, p);
            updateTotalProgress();
          }
        });

        // Verification
        const firstLangWithContent = Object.keys(props.postData())[0];
        const verificationPath = `${firstLangWithContent}/data.md`;
        const gatewayUrl = service.gatewayUrl.trim().replace(/\/+$/, "");
        const verifyUrl = `${gatewayUrl}/ipfs/${cid}/${verificationPath}`;
        
        // Add a delay before verifying
        await new Promise(resolve => setTimeout(resolve, 3000));
        await fetchWithTimeout(verifyUrl, { timeoutMs: 30000 });

        return cid;
      } catch (e) {
        throw new Error(`Failed on service '${service.name}': ${e.message}`);
      }
    }));
    
    const firstCid = cids[0];
    if (!cids.every(cid => cid === firstCid)) {
      throw new Error("Inconsistent CIDs returned from pinning services.");
    }
    
    return firstCid;
  };

  const uploadToBackend = async () => {
    const { postData, editorMode } = props;
    const baseDir = editorMode === "new_post" ? DRAFT_DIRS.NEW_POST : DRAFT_DIRS.EDIT;
    
    const formData = new FormData();
    const content = postData();
    // (This part remains the same as your existing implementation)
    for (const lang in content) {
      // ... same logic to append markdown files
    }
    const assetFileNames = await getAllUploadedFileNames(baseDir);
    for (const fileName of assetFileNames) {
      const file = await getUploadedFileAsFileObject(baseDir, fileName);
      if (file) formData.append('file', file, `uploads/${fileName}`);
    }
    
    return await uploadWithProgress(`${httpBase()}store-dir`, formData);
  };
  
  const uploadWithProgress = (url, formData) => {
    // (This remains the same as your existing implementation)
  };
  
  onMount(() => {
    setTimeout(async () => {
      try {
        const usePinners = isPinningEnabled();
        const cid = usePinners ? await uploadToPinningServices() : await uploadToBackend();
        props.onComplete?.(cid);
      } catch (e) {
        dbg.error("StepUploadIPFS", "An error occurred in the upload process:", e);
        setError(e.message);
      } finally {
        setIsUploading(false);
      }
    }, 500);
  });

  return (
    <div class="flex flex-col items-center justify-center h-full">
      <Show when={isUploading()}>
        <Spinner />
        <p class="mt-2 text-sm">{uploadMessage()}</p>
        <div class="w-full max-w-sm bg-[hsl(var(--muted))] rounded-full h-2.5 mt-4">
          <div class="bg-blue-600 h-2.5 rounded-full" style={{ width: `${uploadProgress()}%` }}></div>
        </div>
        <p class="text-xs mt-1">{uploadProgress()}%</p>
      </Show>
      <Show when={error()}>
        <div class="text-center p-4">
          <h4 class="font-bold text-red-600">{t("editor.publish.ipfs.errorTitle")}</h4>
          <p class="mt-2 text-sm">{error()}</p>
          <button onClick={props.onCancel} class="mt-4 px-4 py-2 rounded border border-[hsl(var(--input))] hover:bg-[hsl(var(--accent))]">
            {t("editor.publish.validation.backToEditor")}
          </button>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/CommentEditor.jsx">
// src/components/editor/CommentEditor.jsx
import { createResource, Show } from "solid-js";
import { useApp } from "../../context/AppContext";
import { toChecksumAddress } from "../../blockchain/utils";
import PostCard from "../feed/PostCard";
import Spinner from "../ui/Spinner";
import { whenWsOpen } from "../../net/wsRuntime.js";

async function fetchPost(params) {
  const { app, savva_cid } = params;
  if (!app.wsMethod || !savva_cid) return null;

  await whenWsOpen();
  const getList = app.wsMethod("content-list");
  
  const requestParams = {
    domain: app.selectedDomainName(),
    savva_cid: savva_cid,
    limit: 1,
  };

  const user = app.authorizedUser();
  if (user?.address) {
    requestParams.my_addr = toChecksumAddress(user.address);
  }

  try {
    const res = await getList(requestParams);
    const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];
    return arr[0] ? { id: arr[0].savva_cid, _raw: arr[0] } : null;
  } catch (err) {
    console.error(`Failed to fetch post '${savva_cid}':`, err);
    return { error: err.message };
  }
}

export default function CommentEditor(props) {
  const app = useApp();
  const { t } = app;
  
  const [postData] = createResource(() => ({
    app: app,
    savva_cid: props.savva_cid
  }), fetchPost);

  return (
    <div class="mb-4">
      <Show when={postData.loading}>
        <div class="flex justify-center items-center h-24">
          <Spinner />
        </div>
      </Show>
      <Show when={postData.error}>
        <p class="text-xs text-[hsl(var(--destructive))]">
          {t("common.error")}: {postData.error}
        </p>
      </Show>
      <Show when={!postData.loading && !postData.error && postData()}>
        <PostCard
          item={postData()}
          mode="list"
          compact={false}
        />
      </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/EditorToolbar.jsx">
// src/components/editor/EditorToolbar.jsx
import { useApp } from "../../context/AppContext.jsx";
import { applyMarkdownFormat } from "../../editor/text-utils.js";
import { ToolbarButton, BoldIcon, ItalicIcon, LinkIcon, ImageIcon, MaximizeIcon, MinimizeIcon } from "./ToolbarIcons.jsx";
import { Show } from "solid-js";

export default function EditorToolbar(props) {
  const { t } = useApp();

  const handleFormat = (format) => {
    const textarea = props.getTextareaRef?.();
    applyMarkdownFormat(textarea, format, props.onValueChange);
  };

  return (
    <div class="flex items-center justify-between h-10 px-2 rounded-t-lg border-t border-x border-[hsl(var(--border))] bg-[hsl(var(--card))]">
      <div class="flex items-center">
        <ToolbarButton onClick={() => handleFormat('bold')} title={t("editor.toolbar.bold")}>
          <BoldIcon />
        </ToolbarButton>
        <ToolbarButton onClick={() => handleFormat('italic')} title={t("editor.toolbar.italic")}>
          <ItalicIcon />
        </ToolbarButton>
        <ToolbarButton onClick={() => handleFormat('link')} title={t("editor.toolbar.link")}>
          <LinkIcon />
        </ToolbarButton>
        <ToolbarButton onClick={() => handleFormat('image')} title={t("editor.toolbar.image")}>
          <ImageIcon />
        </ToolbarButton>
      </div>
      <div class="flex items-center gap-2">
        <button
          onClick={props.onTogglePreview}
          class="px-3 py-1 text-sm rounded-md hover:bg-[hsl(var(--accent))]"
        >
          {props.isPreview ? t("editor.toolbar.hidePreview") : t("editor.toolbar.showPreview")}
        </button>
        <ToolbarButton
          onClick={props.onToggleFullScreen}
          title={props.isFullScreen ? t("editor.toolbar.minimize") : t("editor.toolbar.maximize")}
        >
          <Show when={props.isFullScreen} fallback={<MaximizeIcon />}>
            <MinimizeIcon />
          </Show>
        </ToolbarButton>
      </div>
    </div>
  );
}
</file>

<file path="src/components/main/NewContentBanner.jsx">
// src/components/main/NewContentBanner.jsx
import { Show } from "solid-js";
import { useApp } from "../../context/AppContext";
import { navigate } from "../../routing/hashRouter";

export default function NewContentBanner() {
  const app = useApp();
  const { t } = app;

  const handleClick = () => {
    app.setNewContentAvailable(null);
    const newPath = "/new"; // Use the simple, non-prefixed path
    if (window.location.hash.slice(1) !== newPath) {
      navigate(newPath);
    }
    app.setNewTabRefreshKey(Date.now());
  };

  return (
    <div class="fixed top-24 left-1/2 -translate-x-1/2 z-30 w-full max-w-md px-4 pointer-events-none">
      <Show when={app.newContentAvailable()}>
        <div class="pointer-events-auto">
          <button
            onClick={handleClick}
            class="w-full px-4 py-2 rounded-lg shadow-lg text-sm font-semibold transition-transform duration-300 ease-out"
            style={{ 
              background: "var(--gradient)", 
              color: "hsl(var(--card))"
            }}
          >
            {t("main.newContentAvailable")}
          </button>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/main/NewPostButton.jsx">
// src/components/main/NewPostButton.jsx
import { navigate } from "../../routing/hashRouter";
import { useApp } from "../../context/AppContext";
import { EditIcon as NewPostIcon } from "../ui/icons/ActionIcons.jsx";

export default function NewPostButton() {
  const app = useApp();
  const { t } = app;

  const handleNewPost = () => {
    app.setSavedScrollY(window.scrollY);
    navigate("/editor/new");
  };

  return (
    <button
      class="p-1.5 rounded-full text-[hsl(var(--muted-foreground))] hover:bg-[hsl(var(--accent))] hover:text-[hsl(var(--foreground))]"
      onClick={handleNewPost}
      title={t("header.newPost")}
    >
      <NewPostIcon class="w-5 h-5" />
    </button>
  );
}
</file>

<file path="src/components/post/PostComments.jsx">
// src/components/editor/PostComments.jsx
import { createResource, For, Show, createSignal, createEffect } from "solid-js";
import { useApp } from "../../context/AppContext";
import { toChecksumAddress } from "../../blockchain/utils";
import Spinner from "../ui/Spinner";
import CommentCard from "./CommentCard";
import { navigate } from "../../routing/hashRouter.js";

async function fetchComments(params) {
  const { app, postId, offset = 0 } = params;
  if (!app.wsMethod || !postId) return { list: [], nextOffset: null };

  const getChildren = app.wsMethod("content-children");
  const requestParams = {
    domain: app.selectedDomainName(),
    savva_cid: postId,
    max_deep: 4,
    limit: 20,
    offset,
  };

  const user = app.authorizedUser();
  if (user?.address) {
    requestParams.my_addr = toChecksumAddress(user.address);
  }

  try {
    const res = await getChildren(requestParams);
    const list = Array.isArray(res?.list) ? res.list : [];
    const nextOffset = res?.next_offset > 0 ? res.next_offset : null;
    return { list, nextOffset };
  } catch (err) {
    console.error(`Failed to fetch comments for post '${postId}':`, err);
    return { list: [], nextOffset: null, error: err.message };
  }
}

export default function PostComments(props) {
  const app = useApp();
  const { t } = app;
  const postId = () => props.post?.savva_cid;

  const [comments, setComments] = createSignal([]);
  const [nextOffset, setNextOffset] = createSignal(0);
  const [isLoadingMore, setIsLoadingMore] = createSignal(false);

  const [initialData] = createResource(() => ({ app, postId: postId() }), fetchComments);

  createEffect(() => {
    const data = initialData();
    if (data && !initialData.loading) {
      setComments(data.list || []);
      setNextOffset(data.nextOffset);
    }
  });

  const loadMore = async () => {
    if (isLoadingMore() || nextOffset() === null) return;
    setIsLoadingMore(true);
    const data = await fetchComments({ app, postId: postId(), offset: nextOffset() });
    if (data.list) {
      setComments((prev) => [...prev, ...data.list]);
      setNextOffset(data.nextOffset);
    }
    setIsLoadingMore(false);
  };

  const handleAddComment = () => {
    navigate(`/editor/new-comment/${postId()}`);
  };

  return (
    <div class="mt-8 pt-6 border-t border-[hsl(var(--border))]">
      {/* Header with link only, no counter */}
      <div class="mb-4 flex items-center justify-between">
        <h3 class="text-xl font-semibold">{t("post.comments")}</h3>
        <button
          onClick={handleAddComment}
          class="text-sm underline text-[hsl(var(--foreground))] hover:opacity-80"
        >
          {t("post.addComment")}
        </button>
      </div>

      <Show when={initialData.loading}>
        <div class="flex justify-center p-8"><Spinner /></div>
      </Show>

      <Show when={initialData.error}>
        <p class="text-sm text-[hsl(var(--destructive))]">
          {t("common.error")}: {initialData.error}
        </p>
      </Show>

      <Show when={!initialData.loading && !initialData.error && comments().length > 0}>
        <div class="space-y-4">
          <For each={comments()}>
            {(comment) => <CommentCard comment={comment} />}
          </For>
        </div>
      </Show>

      <Show when={!initialData.loading && !initialData.error && comments().length === 0}>
        <p class="text-sm text-[hsl(var(--muted-foreground))]">{t("post.noComments")}</p>
      </Show>

      <Show when={nextOffset() !== null && !initialData.loading}>
        <div class="mt-6 text-center">
          <button
            onClick={loadMore}
            disabled={isLoadingMore()}
            class="px-4 py-2 rounded-md border border-[hsl(var(--border))] text-sm hover:bg-[hsl(var(--accent))] disabled:opacity-50"
          >
            {isLoadingMore() ? t("common.loading") : t("post.loadMoreComments")}
          </button>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/post/PostControls.jsx">
// src/components/post/PostControls.jsx
import { createSignal, Show, createMemo } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { navigate } from "../../routing/hashRouter.js";
import { preparePostForEditing } from "../../editor/postImporter.js";
import { pushErrorToast } from "../../ui/toast.js";
import PostInfo from "../feed/PostInfo.jsx";
import Spinner from "../ui/Spinner.jsx";
import ConfirmModal from "../ui/ConfirmModal.jsx";
import { EditIcon, TrashIcon } from "../ui/icons/ActionIcons.jsx";
import { useDeleteAction } from "../../hooks/useDeleteAction.js";

export default function PostControls(props) {
  const app = useApp();
  const { t } = app;
  const [isPreparing, setIsPreparing] = createSignal(false);
  
  const { showConfirm, openConfirm, closeConfirm, confirmDelete, modalProps } = useDeleteAction(() => props.post);

  const isAuthor = createMemo(() => {
    const userAddr = app.authorizedUser()?.address?.toLowerCase();
    const authorAddr = props.post?.author?.address?.toLowerCase();
    return !!userAddr && userAddr === authorAddr;
  });

  const handleEdit = async () => {
    setIsPreparing(true);
    try {
      await preparePostForEditing(props.post, app);
      navigate(`/editor/edit/${props.post.savva_cid}`);
    } catch (e) {
      pushErrorToast(e, { context: "Failed to prepare post for editing." });
    } finally {
      setIsPreparing(false);
    }
  };

  return (
    <>
      <div class="mt-8 pt-4 border-t border-[hsl(var(--border))] flex items-center justify-between">
        <div class="flex-1 min-w-0">
          <PostInfo 
            item={props.post} 
            hideTopBorder={true} 
            timeFormat="long" 
          />
        </div>

        <div class="pl-4">
          <Show when={isAuthor()}>
            <div class="flex items-center gap-2 flex-shrink-0">
              <button
                onClick={handleEdit}
                disabled={isPreparing()}
                class="p-2 rounded text-[hsl(var(--muted-foreground))] hover:bg-[hsl(var(--accent))] disabled:opacity-60"
                title="Edit Post"
              >
                <Show when={isPreparing()} fallback={<EditIcon class="w-5 h-5" />}>
                  <Spinner class="w-5 h-5" />
                </Show>
              </button>
              <button
                onClick={openConfirm}
                disabled={modalProps().isDeleting}
                class="p-2 rounded text-[hsl(var(--muted-foreground))] hover:bg-[hsl(var(--destructive))] hover:text-[hsl(var(--destructive-foreground))] disabled:opacity-60"
                title="Delete Post"
              >
                <TrashIcon class="w-5 h-5" />
              </button>
              <button class="px-4 py-2 text-sm rounded border border-[hsl(var(--input))] hover:bg-[hsl(var(--accent))]" disabled>
                Promote
              </button>
            </div>
          </Show>
        </div>
      </div>
      
      <ConfirmModal
        isOpen={showConfirm()}
        onClose={closeConfirm}
        onConfirm={confirmDelete}
        {...modalProps()}
      />
    </>
  );
}
</file>

<file path="src/components/tabs/RightRailLayout.jsx">
// src/components/tabs/RightRailLayout.jsx
import { Show } from "solid-js";
import RightRail from "../layout/RightRail.jsx";

const HEADER_H = 48;

export default function RightRailLayout(props) {
  return (
    <section
      class="w-full"
      style={{ "min-height": `calc(100vh - ${HEADER_H}px)` }}
    >
      <Show
        when={props.rightPanelConfig?.available}
        fallback={
          // When the right panel is unavailable, render content in a single column.
          <div>{props.children}</div>
        }
      >
        {/* When the right panel is available, render the two-column grid. */}
        <div class="grid gap-4 grid-cols-1 md:grid-cols-[minmax(0,1fr)_320px] items-start">
          <div>{props.children}</div>
          <aside class="hidden md:block sticky top-16">
            <div class="space-y-4">
              <RightRail config={props.rightPanelConfig} />
            </div>
          </aside>
        </div>
      </Show>
    </section>
  );
}
</file>

<file path="src/components/SwitchConnectDialog.jsx">
// File: src/components/SwitchConnectDialog.jsx
import { createSignal, createEffect, Show, createMemo, onCleanup } from "solid-js";
import { useApp } from "../context/AppContext";
import { httpBase, configureEndpoints, wsUrl } from "../net/endpoints";

const dn = (d) => (typeof d === "string" ? d : d?.name || "");
const eq = (a, b) => (String(a || "").trim().toLowerCase() === String(b || "").trim().toLowerCase());

function isAbortError(e) {
  const msg = String(e?.message || e || "").toLowerCase();
  if (e?.name === "AbortError") return true;
  if (e?.code === 20) return true;
  if (msg.includes("aborted") || msg.includes("abort") || msg.includes("the operation was aborted")) return true;
  return false;
}

async function fetchInfoJSON(backendLink, { signal } = {}) {
  const base = httpBase(backendLink);
  const res = await fetch(base + "info", { headers: { Accept: "application/json" }, signal });
  if (!res.ok) throw new Error(`/info failed: ${res.status}`);
  return await res.json();
}

export default function SwitchConnectDialog(props) {
  const app = useApp();
  const { t } = app;

  const [backendUrl, setBackendUrl] = createSignal(props.backendLink ?? app.config?.()?.backendLink ?? "");
  const [domain, setDomain] = createSignal(dn(props.domain) || (app.config?.()?.domain || ""));
  const [domains, setDomains] = createSignal([]); // [{ name }]
  const [fetching, setFetching] = createSignal(false);
  const [applying, setApplying] = createSignal(false);
  const [localError, setLocalError] = createSignal("");

  let aborter;

  const selectedDomainObj = createMemo(() => {
    const cur = (domain() || "").trim().toLowerCase();
    return (domains() || []).find((d) => eq(dn(d), cur)) || null;
  });

  createEffect(async () => {
    if (!props.open) return;

    setLocalError("");
    setBackendUrl(props.backendLink ?? app.config?.()?.backendLink ?? "");
    setDomain(dn(props.domain) || (app.config?.()?.domain || ""));
    setDomains([]);

    aborter?.abort();
    aborter = new AbortController();
    setFetching(true);

    try {
      const initialUrl = props.backendLink ?? app.config?.()?.backendLink ?? "";
      const u = new URL(initialUrl);
      if (!/^https?:$/.test(u.protocol)) throw new Error(t("rightPane.switch.validation.protocol"));

      const info = await fetchInfoJSON(initialUrl, { signal: aborter.signal });
      const normalized = (Array.isArray(info?.domains) ? info.domains : [])
        .filter(Boolean)
        .map((d) => (typeof d === "string" ? { name: d } : d))
        .filter((d) => typeof d?.name === "string" && d.name.trim().length > 0);

      normalized.sort((a, b) => (a.name > b.name ? 1 : -1));
      setDomains(normalized);

      if (normalized.length > 0) {
        const wanted = dn(props.domain) || (app.config?.()?.domain || "");
        const resolved =
          normalized.find((d) => eq(d.name, wanted)) ||
          normalized.find((d) => eq(d.name, domain())) ||
          normalized[0];

        const name = resolved.name;
        setDomain(name);
        queueMicrotask(() => setDomain(name));
      } else {
        setLocalError(t("rightPane.switch.noDomains"));
      }
    } catch (e) {
      if (!isAbortError(e)) setLocalError(e.message || String(e));
    } finally {
      setFetching(false);
    }
  });

  onCleanup(() => aborter?.abort());

  async function handleReload() {
    setLocalError("");

    // Normalize the user-entered backend URL (candidate) without touching global config.
    let candidate = (backendUrl() || "").trim();
    try {
      const u = new URL(candidate);
      if (!/^https?:$/.test(u.protocol)) {
        throw new Error(t("rightPane.switch.validation.protocol"));
      }
      // Ensure trailing slash for consistent "base + 'info'" concatenation.
      if (!u.pathname.endsWith("/")) u.pathname += "/";
      candidate = u.toString();
    } catch (e) {
      setLocalError(e.message || t("rightPane.switch.validation.protocol"));
      return;
    }

    setFetching(true);
    aborter?.abort();
    aborter = new AbortController();

    try {
      // Probe the candidate backend’s /info to list available domains.
      const res = await fetch(candidate + "info", {
        headers: { Accept: "application/json" },
        signal: aborter.signal,
        cache: "no-store",
      });
      if (!res.ok) throw new Error(`/info failed: ${res.status}`);
      const info = await res.json();

      const normalized = (Array.isArray(info?.domains) ? info.domains : [])
        .filter(Boolean)
        .map((d) => (typeof d === "string" ? { name: d } : d))
        .filter((d) => typeof d?.name === "string" && d.name.trim().length > 0);

      normalized.sort((a, b) => (a.name > b.name ? 1 : -1));
      setDomains(normalized);

      if (normalized.length > 0) {
        // Try to keep current/wanted domain if present; otherwise pick the first.
        const prefer = dn(props.domain) || (app.config?.()?.domain || "") || domain();
        const keep =
          normalized.find((d) => eq(d.name, prefer)) ||
          normalized.find((d) => eq(d.name, domain()));
        const name = keep?.name || normalized[0].name;
        setDomain(name);
        queueMicrotask(() => setDomain(name));
      } else {
        setLocalError(t("rightPane.switch.noDomains"));
      }
    } catch (e) {
      if (!isAbortError(e)) setLocalError(e.message || String(e));
    } finally {
      setFetching(false);
    }
  }

  async function onApply() {
    setLocalError("");
    setApplying(true);
    try {
      const newUrl = (backendUrl() || "").trim();
      const chosenDomain = (domain() || "").trim();
      if (!newUrl || !chosenDomain) throw new Error("URL and domain are required.");

      const oldBackendBase = httpBase();
      const newBackendBase = new URL(newUrl);
      if (!newBackendBase.pathname.endsWith("/")) newBackendBase.pathname += "/";
      const isSwitchingBackends = oldBackendBase !== newBackendBase.toString();

      // --- MODIFICATION START: Logout from the OLD backend first ---
      if (isSwitchingBackends) {
        await app.logout?.();
      }
      // --- MODIFICATION END ---

      // Now, proceed with switching to the new backend
      configureEndpoints({ backendLink: newUrl, domain: chosenDomain });

      await app.updateConnect?.({ backendLink: httpBase() });
      await app.setDomain?.(chosenDomain);
      await app.refreshDomainAssets?.();

      if (app.ws) {
        app.ws.setUrl(wsUrl());
        app.ws.reconnect("switch-backend");
      }
    } catch (e) {
      if (!isAbortError(e)) setLocalError(e.message || String(e));
      setApplying(false);
      return;
    }

    setApplying(false);
    try { aborter?.abort(); } catch { }
    props.onClose?.();
  }

  return (
    <Show when={props.open}>
      <div class="fixed inset-0 z-40 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/40" onClick={props.onClose} />

        <div class="relative themed-dialog rounded-lg shadow-lg w-[34rem] max-w-[95vw] p-4 bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))]">
          <h3 class="text-lg font-semibold mb-3">
            {t("rightPane.switch.title")}
          </h3>

          <label class="block mb-3">
            <span class="text-sm text-[hsl(var(--muted-foreground))]">{t("rightPane.switch.backend.label")}</span>
            <div class="mt-1 flex gap-2">
              <input
                class="flex-1 px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
                value={backendUrl()}
                onInput={(e) => setBackendUrl(e.currentTarget.value)}
                placeholder={t("rightPane.switch.backend.placeholder")}
                spellcheck={false}
              />
              <button
                class="px-3 py-2 rounded bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))] hover:opacity-90 disabled:opacity-60"
                onClick={handleReload}
                disabled={fetching()}
                title={t("rightPane.switch.reload.title")}
              >
                {fetching() ? t("common.loading") : t("rightPane.switch.reload")}
              </button>
            </div>
            <p class="text-xs text-[hsl(var(--muted-foreground))] mt-1">{t("rightPane.switch.backend.help")}</p>
          </label>

          <label class="block mb-1">
            <span class="text-sm text-[hsl(var(--muted-foreground))]">{t("rightPane.switch.domain.label")}</span>
          </label>
          <select
            class="w-full px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))] disabled:opacity-60"
            value={domain()}
            onChange={(e) => setDomain(e.currentTarget.value)}
            disabled={fetching() || domains().length === 0}
          >
            {domains().map((d) => (
              <option value={d.name} selected={eq(d.name, domain())}>
                {d.name}
              </option>
            ))}
          </select>

          <Show when={selectedDomainObj()}>
            <div class="mt-2 text-xs text-[hsl(var(--muted-foreground))] space-y-1">
              <Show when={selectedDomainObj().website}>
                <div>
                  {t("rightPane.switch.domain.website")}:{" "}
                  <a class="underline" href={selectedDomainObj().website} target="_blank" rel="noreferrer">
                    {selectedDomainObj().website}
                  </a>
                </div>
              </Show>
            </div>
          </Show>

          <Show when={localError() || props.error}>
            <p class="mt-2 text-sm text-[hsl(var(--destructive))]">
              {t("common.error")}: {localError() || props.error?.message}
            </p>
          </Show>

          <div class="mt-4 flex gap-2 justify-end">
            <button
              class="px-3 py-2 rounded bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))] hover:opacity-90"
              onClick={props.onClose}
            >
              {t("common.cancel")}
            </button>
            <button
              class="px-3 py-2 rounded bg-[hsl(var(--destructive))] text-[hsl(var(--destructive-foreground))] hover:opacity-90"
              onClick={props.onReset}
              title={t("rightPane.switch.reset.title")}
            >
              {t("rightPane.switch.reset")}
            </button>
            <button
              class="px-3 py-2 rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] hover:opacity-90 disabled:opacity-60"
              onClick={onApply}
              disabled={props.loading || fetching() || applying()}
            >
              {props.loading || fetching() || applying() ? t("common.applying") : t("common.apply")}
            </button>
          </div>
        </div>
      </div>
    </Show>
  );
}
</file>

<file path="src/i18n/static_keys.jsx">
//--------------------------------------------------------
// i18n techical comments.'
// DO NOT REMOVE
//--------------------------------------------------------

/*
t("timeFrame.week")
t("timeFrame.month")
t("timeFrame.year")
t("timeFrame.all")

t("stakerLevels.guest")
t("stakerLevels.clam")
t("stakerLevels.shrimp")
t("stakerLevels.seahorse")
t("stakerLevels.fish")
t("stakerLevels.dolphin")
t("stakerLevels.shark")
t("stakerLevels.stingray")
t("stakerLevels.orca")
t("stakerLevels.whale")

t("editor.publish.steps.validate")
t("editor.publish.steps.validate.help")
t("editor.publish.steps.check_rights")
t("editor.publish.steps.check_rights.help")
t("editor.publish.steps.ipfs")
t("editor.publish.steps.ipfs.help")
t("editor.publish.steps.ipfs_publish")
t("editor.publish.steps.ipfs_publish.help")
t("editor.publish.steps.publish")
t("editor.publish.steps.publish.help")

t("reactions.like")
t("reactions.love")
t("reactions.laugh")
t("reactions.wow")
t("reactions.sad")
t("reactions.angry")
t("reactions.fire")
t("reactions.clap")
t("reactions.star")
t("reactions.hot")
t("reactions.trophy")
t("reactions.ha_ha")
t("reactions.super")
t("reactions.dislike")

t("tabs.title.leaders") 
t("tabs.title.actual") 
t("tabs.title.comments")
t("tabs.title.new") 
t("tabs.title.for-you")


*/
</file>

<file path="src/ipfs/index.js">
// src/ipfs/index.js
import { fetchWithTimeout } from "../utils/net.js";

function ensureSlash(s) { return s.endsWith("/") ? s : s + "/"; }
function stripPrefix(s, p) { return s.startsWith(p) ? s.slice(p.length) : s; }

function normalizeInput(input) {
  let s = String(input || "").trim();
  if (!s) throw new Error("ipfs: empty input");
  s = stripPrefix(s, "ipfs://");
  s = stripPrefix(s, "/ipfs/");
  s = stripPrefix(s, "ipfs/");
  return s;
}

function buildUrl(baseGateway, cidPath) {
  const base = String(baseGateway || "").trim().replace(/\/+$/, "");
  const path = String(cidPath || "").trim().replace(/^\/+/g, "");
  if (!base || !path) return "";
  const hasIpfs = /\/ipfs$/i.test(base);
  const prefix = hasIpfs ? `${base}/` : `${base}/ipfs/`;
  return prefix + path;
}

async function tryGateways(cidPath, gateways, { timeoutMs = 8000, init = {} } = {}) {
  const errors = [];
  for (const gw of gateways) {
    const url = buildUrl(gw, cidPath);
    try {
      const res = await fetchWithTimeout(url, { timeoutMs, ...init });
      if (res && res.ok) {
        return { res, url, gateway: gw };
      }

      const httpError = new Error(`Gateway ${gw} -> HTTP ${res.status}`);
      httpError.url = url;
      httpError.status = res.status;
      errors.push(httpError);

    } catch (e) {
      const networkError = new Error(`Gateway ${gw} -> ${e?.name || "Error"}: ${e?.message || e}`);
      networkError.url = url;
      errors.push(networkError);
    }
  }
  const err = new Error("All IPFS gateways failed");
  err.causes = errors;
  if (errors.some(e => e.status === 404)) {
      err.is404 = true;
  }
  throw err;
}

async function fetchBest(app, ipfsPath, options = {}) {
  const { postGateways = [], timeoutMs = 8000, ...fetchOptions } = options;
  const cidPath = normalizeInput(ipfsPath);
  let gatewaysToTry = [];
  
  let effectiveTimeout = timeoutMs;

  if (app.localIpfsEnabled() && app.localIpfsGateway()) {
    gatewaysToTry = [app.localIpfsGateway()];
    effectiveTimeout = 30000;
  } else {
    const systemGateways = app.remoteIpfsGateways() || [];
    gatewaysToTry = [...new Set([...postGateways, ...systemGateways])];
  }

  if (gatewaysToTry.length === 0) {
    throw new Error("No IPFS gateways available to try.");
  }

  return tryGateways(cidPath, gatewaysToTry, { timeoutMs: effectiveTimeout, init: fetchOptions });
}

async function getJSONBest(app, ipfsPath, options = {}) {
  const { res, url, gateway } = await fetchBest(app, ipfsPath, {
    ...options,
    headers: { Accept: "application/json", ...(options.headers || {}) },
  });
  return { data: await res.json(), url, gateway };
}

export const ipfs = {
  fetchBest,
  getJSONBest,
  normalizeInput,
  buildUrl,
};
</file>

<file path="src/pages/Docs.jsx">
// src/pages/Docs.jsx
import { createMemo } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import { useHashRouter } from "../routing/hashRouter";
import DocsIndex from "../components/docs/DocsIndex.jsx";
import DocsContent from "../components/docs/DocsContent.jsx";
import ClosePageButton from "../components/ui/ClosePageButton.jsx";

const trim = (s) => String(s || "").replace(/^\/+|\/+$/g, "");
const fileFromRoute = (route) => {
  if (!String(route || "").startsWith("/docs")) return "index.md";
  const rest = String(route).slice("/docs".length);
  return trim(rest) || "index.md";
};

export default function Docs() {
  const app = useApp();
  const { route, navigate } = useHashRouter();
  const file = createMemo(() => fileFromRoute(route()));
  const onPick = (rel) => navigate(`/docs/${trim(rel || "index.md")}`);
  const title = createMemo(() => app.t("docs.title"));

  return (
    <div class="sv-container sv-container--no-gutter">
      <div class="grid grid-cols-1 md:grid-cols-[280px_minmax(0,1fr)] gap-6 px-[var(--sv-container-gutter)] py-6">
      <ClosePageButton mode="close" />
        {/* Left sidebar */}
        <aside class="min-w-0">
          <div>
            <div class="flex items-center justify-between">
              <h2 class="text-sm font-semibold mb-2">{title()}</h2>
            </div>
            <DocsIndex active={file()} onPick={onPick} />
          </div>
        </aside>

        {/* Right content */}
        <main class="min-w-0">
          <DocsContent relPath={file()} onPick={onPick} />
        </main>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/Settings.jsx">
// src/pages/Settings.jsx
import { useApp } from "../context/AppContext.jsx";
import LocalIpfsSection from "../components/settings/LocalIpfsSection.jsx";
import Assets from "../components/settings/Assets.jsx";
import DeveloperSection from "../components/settings/DeveloperSection.jsx";
import ClosePageButton from "../components/ui/ClosePageButton.jsx";
import PinningServicesSection from "../components/settings/PinningServicesSection.jsx";

export default function Settings() {
  const app = useApp();
  const { t } = app;

  return (
    <main class="p-4 max-w-3xl mx-auto space-y-6">

      <ClosePageButton />

      <div class="flex items-center justify-between">
        <h2 class="text-2xl font-semibold">{t("settings.title")}</h2>
      </div>

      <LocalIpfsSection />
      <PinningServicesSection />
      <Assets />
      <DeveloperSection />
    </main>
  );
}
</file>

<file path="src/styles/tabs.css">
/* src/styles/tabs.css */

.tabs {
  --tabs-active-bg: hsl(var(--background));
  --tabs-active-fg: hsl(var(--foreground));
  --tabs-inactive-bg: hsl(var(--secondary));
  --tabs-inactive-fg: hsl(var(--secondary-foreground));
  --tabs-background: hsl(var(--card));

  list-style: none;
  margin: 0;
  padding-top: 5px;

  background: var(--tabs-background);
  background: var(--gradient);

  display: flex;
  justify-content: center;
  overflow-x: auto;
}

.tabs li {
  position: relative;
  flex-shrink: 0;
}

.tabs a {
  display: block;
  text-decoration: none;
  padding: 7px clamp(5px, 5vw, 80px);
  white-space: nowrap;
  color: var(--tabs-inactive-fg);
  background: var(--tabs-inactive-bg);
  border-top-left-radius: 15px;
  border-top-right-radius: 15px;
}

.tabs .active { z-index: 3; }
.tabs .active a {
  color: var(--tabs-active-fg);
  background: var(--tabs-active-bg);
}

.tabs li:before,
.tabs li:after,
.tabs li a:before,
.tabs li a:after {
  position: absolute;
  bottom: 0;
}

.tabs li:last-child:after,
.tabs li:last-child a:after,
.tabs li:first-child:before,
.tabs li:first-child a:before,
.tabs .active:after,
.tabs .active:before,
.tabs .active a:after,
.tabs .active a:before {
  content: "";
}

.tabs .active:before,
.tabs .active:after {
  background: var(--tabs-active-bg);
  z-index: 1;
}

.tabs li:before,
.tabs li:after {
  background: var(--tabs-inactive-bg);
  width: 10px;
  height: 10px;
}
.tabs li:before { left: -10px; }
.tabs li:after  { right: -10px; }

.tabs li a:before,
.tabs li a:after {
  width: 20px;
  height: 20px;
  border-radius: 10px;
  background: var(--tabs-background);
  z-index: 2;
}

.tabs .active a:after,
.tabs .active a:before {
  background: var(--tabs-inactive-bg);
}

.tabs li:first-child.active a:before,
.tabs li:last-child.active a:after {
  background: var(--tabs-background);
}

.tabs li a:before { left: -20px; }
.tabs li a:after  { right: -20px; }

.tabs li:first-child:before,
.tabs li:first-child a:before,
.tabs li:last-child:after,
.tabs li:last-child a:after {
  content: none;
}

.tabs_panel {
  position: relative;
  background: hsl(var(--background));
  color: hsl(var(--foreground));
  padding: 1rem;
}

.tabs a .tab__icon {
  display: inline-flex;
  vertical-align: middle;
  margin-right: 0.5rem;
  line-height: 0;
}
.tabs a .tab__icon svg { width: 18px; height: 18px; }

/* --- compact mode --- */
.tabs[data-compact="true"] a .tab__icon {
  margin-right: 0;
}
.tabs[data-compact="true"] a {
  padding: 7px clamp(5px, 6vw, 80px);
}
.tabs[data-compact="true"] a .tab__label {
  /* Visually hide but keep in accessibility tree */
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
</file>

<file path="src/index.jsx">
// src/index.jsx
import { render } from "solid-js/web";
import "./index.css";
import App from "./components/App.jsx";
import { AppProvider } from "./context/AppContext.jsx";

const root = document.getElementById("root");

render(() => (
  <AppProvider>
    <App />
  </AppProvider>
), root);
</file>

<file path="public/dev_docs/en/sidebar.yaml">
# public/dev_docs/en/sidebar.yaml
sections:
  - title: Getting Started
    items:
      - label: Overview
        file: index.md
      - label: Setup
        file: getting-started.md

  - title: Core Concepts
    items:
      - label: Overview
        file: core-concepts/index.md
      - label: App initialization & backend connect
        file: core-concepts/app-init.md
      - label: Working with domains
        file: core-concepts/domain.md
      - label: Authentication
        file: core-concepts/auth.md
      - label: Showing Posts
        file: core-concepts/showing-posts.md
      - label: Publishing Posts
        file: core-concepts/publishing-posts.md
      - label: Config Contract
        file: core-concepts/config-contract.md
</file>

<file path="public/dev_docs/fr/.i18n-docs-state.json">
{
  "core-concepts/app-init.md": "e0a8526b3460031a2a9794a549b31b18581154e1aa833da535dbca06d58d1f20",
  "core-concepts/domain.md": "62cf574a6555e6db6a9dcf96f1b4456a49ab2d5ad1e40ac86c756c4dbc171644",
  "core-concepts/index.md": "1988a34dc654ca313da81f25d97c40b6d0fc97f4b3e190119af3de83560009a9",
  "getting-started.md": "3249a86adcee7286e9994ec908c92fd979a679dd980c6c47ac89bc08f4a1e86d",
  "index.md": "112d9fcd7baa0934935c9dc58310ba7486b6dc998bf5e1940ca0e75ff1af70d7",
  "sidebar.yaml": "26b2929be1d59dce23937a39e3b35045183f6d91b81d36688134ca084c3c3e8e",
  "core-concepts/auth.md": "4ab265a20d38ef433c503a1335a76748787ece0446dc8b490a3994e5cc12aec2",
  "core-concepts/showing-posts.md": "a2d42c4ec28035488fb08fb1e52c5d105cc6b98259778aed8de5115de4054e90",
  "core-concepts/config-contract.md": "d0390a3d46e6bd6cc6a50b6caa979b608876d04fb9cb174bd67cc2652275e960",
  "core-concepts/publishing-posts.md": "61774803e87614ea4bc5f6f132ca0fbf74f1b4b84ed41a1a29675f7940ce2e65"
}
</file>

<file path="public/dev_docs/ru/.i18n-docs-state.json">
{
  "core-concepts/app-init.md": "e0a8526b3460031a2a9794a549b31b18581154e1aa833da535dbca06d58d1f20",
  "core-concepts/domain.md": "62cf574a6555e6db6a9dcf96f1b4456a49ab2d5ad1e40ac86c756c4dbc171644",
  "core-concepts/index.md": "1988a34dc654ca313da81f25d97c40b6d0fc97f4b3e190119af3de83560009a9",
  "getting-started.md": "3249a86adcee7286e9994ec908c92fd979a679dd980c6c47ac89bc08f4a1e86d",
  "index.md": "112d9fcd7baa0934935c9dc58310ba7486b6dc998bf5e1940ca0e75ff1af70d7",
  "sidebar.yaml": "26b2929be1d59dce23937a39e3b35045183f6d91b81d36688134ca084c3c3e8e",
  "core-concepts/auth.md": "4ab265a20d38ef433c503a1335a76748787ece0446dc8b490a3994e5cc12aec2",
  "core-concepts/showing-posts.md": "a2d42c4ec28035488fb08fb1e52c5d105cc6b98259778aed8de5115de4054e90",
  "core-concepts/config-contract.md": "d0390a3d46e6bd6cc6a50b6caa979b608876d04fb9cb174bd67cc2652275e960",
  "core-concepts/publishing-posts.md": "61774803e87614ea4bc5f6f132ca0fbf74f1b4b84ed41a1a29675f7940ce2e65"
}
</file>

<file path="public/dev_docs/sr/.i18n-docs-state.json">
{
  "core-concepts/app-init.md": "e0a8526b3460031a2a9794a549b31b18581154e1aa833da535dbca06d58d1f20",
  "core-concepts/domain.md": "62cf574a6555e6db6a9dcf96f1b4456a49ab2d5ad1e40ac86c756c4dbc171644",
  "core-concepts/index.md": "1988a34dc654ca313da81f25d97c40b6d0fc97f4b3e190119af3de83560009a9",
  "getting-started.md": "3249a86adcee7286e9994ec908c92fd979a679dd980c6c47ac89bc08f4a1e86d",
  "index.md": "112d9fcd7baa0934935c9dc58310ba7486b6dc998bf5e1940ca0e75ff1af70d7",
  "sidebar.yaml": "26b2929be1d59dce23937a39e3b35045183f6d91b81d36688134ca084c3c3e8e",
  "core-concepts/auth.md": "4ab265a20d38ef433c503a1335a76748787ece0446dc8b490a3994e5cc12aec2",
  "core-concepts/showing-posts.md": "a2d42c4ec28035488fb08fb1e52c5d105cc6b98259778aed8de5115de4054e90",
  "core-concepts/config-contract.md": "d0390a3d46e6bd6cc6a50b6caa979b608876d04fb9cb174bd67cc2652275e960",
  "core-concepts/publishing-posts.md": "61774803e87614ea4bc5f6f132ca0fbf74f1b4b84ed41a1a29675f7940ce2e65"
}
</file>

<file path="public/dev_docs/ua/.i18n-docs-state.json">
{
  "core-concepts/app-init.md": "e0a8526b3460031a2a9794a549b31b18581154e1aa833da535dbca06d58d1f20",
  "core-concepts/domain.md": "62cf574a6555e6db6a9dcf96f1b4456a49ab2d5ad1e40ac86c756c4dbc171644",
  "core-concepts/index.md": "1988a34dc654ca313da81f25d97c40b6d0fc97f4b3e190119af3de83560009a9",
  "getting-started.md": "3249a86adcee7286e9994ec908c92fd979a679dd980c6c47ac89bc08f4a1e86d",
  "index.md": "112d9fcd7baa0934935c9dc58310ba7486b6dc998bf5e1940ca0e75ff1af70d7",
  "sidebar.yaml": "26b2929be1d59dce23937a39e3b35045183f6d91b81d36688134ca084c3c3e8e",
  "core-concepts/auth.md": "4ab265a20d38ef433c503a1335a76748787ece0446dc8b490a3994e5cc12aec2",
  "core-concepts/showing-posts.md": "a2d42c4ec28035488fb08fb1e52c5d105cc6b98259778aed8de5115de4054e90",
  "core-concepts/config-contract.md": "d0390a3d46e6bd6cc6a50b6caa979b608876d04fb9cb174bd67cc2652275e960",
  "core-concepts/publishing-posts.md": "61774803e87614ea4bc5f6f132ca0fbf74f1b4b84ed41a1a29675f7940ce2e65"
}
</file>

<file path="src/alerts/registry.js">
// src/alerts/registry.js
import * as h from "./handlers.js";

/**
 * A map of WebSocket alert types to their handler functions.
 * The AlertManager uses this to delegate incoming messages.
 */
export const alertRegistry = {
  token_price_changed: h.handleTokenPriceChanged,
  content_processed: h.handleContentProcessed,
  ping: h.handlePing,
  pong: h.handlePong,
  react: h.handleReact,
  comment_counter: h.handleCommentCounterUpdate,
};
</file>

<file path="src/components/editor/MarkdownInput.jsx">
// src/components/editor/MarkdownInput.jsx
import { Show } from "solid-js";
import MarkdownView from "../docs/MarkdownView.jsx";

export default function MarkdownInput(props) {
  return (
    <div class={`grid ${props.isFullScreen ? 'flex-grow' : 'h-[400px]'} ${props.showPreview ? 'grid-cols-1 md:grid-cols-2' : 'grid-cols-1'}`}>
      <textarea
        ref={props.editorRef}
        value={props.value}
        onInput={(e) => props.onInput(e.currentTarget.value)}
        onPaste={props.onPaste}
        class="relative w-full h-full p-3 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))] resize-none focus:outline-none focus:ring-2 focus:ring-[hsl(var(--ring))] focus:z-10"
        placeholder={props.placeholder}
      />
      <Show when={props.showPreview}>
        <div class="h-full overflow-y-auto p-3 rounded border border-[hsl(var(--border))] bg-[hsl(var(--muted))]">
          <MarkdownView markdown={props.value} rehypePlugins={props.rehypePlugins} />
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/main/MainView.jsx">
// src/components/main/MainView.jsx
import { useApp } from "../../context/AppContext";
import TabsBar from "./TabsBar";
import Container from "../layout/Container";
import ToTopButton from "../ui/ToTopButton";
import NewContentBanner from "./NewContentBanner.jsx";

export default function MainView() {
  const { t } = useApp();

  return (
    <Container>
      <ToTopButton />
      <NewContentBanner />
      <div class="w-full">
        <TabsBar />
      </div>
    </Container>
  );
}
</file>

<file path="src/context/useAppAuth.js">
// src/context/useAppAuth.js
import { createSignal, onMount } from "solid-js";
import { getWsClient, getWsApi } from "../net/wsRuntime.js";
import { toChecksumAddress } from "../blockchain/utils.js";
import { httpBase } from "../net/endpoints.js";
import { pushErrorToast } from "../ui/toast.js";

const AUTH_USER_KEY = "savva_auth_user";

export function useAppAuth() {
  const [authorizedUser, setAuthorizedUser] = createSignal(null);

  onMount(() => {
    try {
      const savedUser = localStorage.getItem(AUTH_USER_KEY);
      if (savedUser) setAuthorizedUser(JSON.parse(savedUser));
    } catch (e) {
      console.error("Failed to load authorized user:", e);
      localStorage.removeItem(AUTH_USER_KEY);
    }
  });

  async function login(coreUserData) {
    if (!coreUserData || !coreUserData.address) return;
    setAuthorizedUser(coreUserData);
    try {
      localStorage.setItem(AUTH_USER_KEY, JSON.stringify(coreUserData));

      // This explicitly closes the old connection and opens a new one,
      // which will attach the new authentication cookie.
      getWsClient()?.reconnect('user-logged-in');

      const checksummedAccount = toChecksumAddress(coreUserData.address);
      const userProfile = await getWsApi().call('get-user', {
        domain: coreUserData.domain,
        user_addr: checksummedAccount,
      });
      const fullUserData = { ...coreUserData, ...userProfile };
      setAuthorizedUser(fullUserData);
      localStorage.setItem(AUTH_USER_KEY, JSON.stringify(fullUserData));
    } catch (e) {
      console.error("Failed to fetch/save user profile after login:", e);
      pushErrorToast(e, { context: "Profile fetch failed" });
    }
  }

  async function logout() {
    try {
      await fetch(`${httpBase()}logout`, { credentials: 'include' });
    } catch (e) {
      console.error("Logout API call failed, proceeding with client-side logout.", e);
    }
    setAuthorizedUser(null);
    try {
      localStorage.removeItem(AUTH_USER_KEY);
    } catch (e) {
      console.error("Failed to clear authorized user:", e);
    }
    getWsClient()?.reconnect('user-logged-out');
  }

  function handleAuthError() {
    console.warn("Authorization error detected, logging out.");
    logout();
  }

  return { authorizedUser, login, logout, handleAuthError };
}
</file>

<file path="src/styles/themed-controls.css">
/* src/styles/themed-controls.css
──────────────────────────────────────────────────────────────
Contents
1) Themed segmented controls
2) Light 1px dialog borders
3) Docs typography (.sv-docs)
4) Code & syntax highlighting (Shiki / pretty-code)
────────────────────────────────────────────────────────────── */

/* ---------------------------------------------- */
/* 1) Themed segmented controls                   */
/* ---------------------------------------------- */

.themed-segment {
  display: inline-flex;
  gap: 6px;
  padding: 4px;
  border: 1px solid hsl(var(--border));
  border-radius: 9999px;
  background: hsl(var(--muted));
}

.themed-pill {
  appearance: none;
  cursor: pointer;
  border: 0;
  border-radius: 9999px;
  padding: 6px 12px;
  line-height: 1;
  font-weight: 600;
  background: transparent;
  color: hsl(var(--muted-foreground));
  outline: none;
}
.themed-pill:hover {
  background: hsl(var(--secondary));
  color: hsl(var(--secondary-foreground));
}
.themed-pill.is-active {
  background: hsl(var(--primary));
  color: hsl(var(--primary-foreground));
}
/* Keyboard focus (accessible) */
.themed-pill:focus-visible {
  outline: 2px solid hsl(var(--primary));
  outline-offset: 2px;
}

.themed-pill--icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 6px 10px;
}
.themed-pill--icon svg { display: block; }

/* ---------------------------------------------- */
/* 2) Light 1px dialog/panel border               */
/* ---------------------------------------------- */

.themed-dialog {
  border: 1px solid hsl(var(--border));
  border-radius: 0.5rem; /* preserves rounding if none set on element */
}

/* ---------------------------------------------- */
/* 3) Docs typography (.sv-docs)                  */
/* ---------------------------------------------- */

.sv-docs h1 {
  margin: 0 0 1rem;
  font-size: 1.75rem;
  line-height: 1.25;
  font-weight: 700;
  color: hsl(var(--foreground));
}
.sv-docs h2 {
  margin: 1.5rem 0 0.75rem;
  font-size: 1.25rem;
  line-height: 1.35;
  font-weight: 600;
  color: hsl(var(--foreground));
}
.sv-docs h3 {
  margin: 1.25rem 0 0.5rem;
  font-size: 1.05rem;
  line-height: 1.35;
  font-weight: 600;
  color: hsl(var(--foreground));
}

.sv-docs p {
  margin: 0.5rem 0 0.85rem;
  line-height: 1.65;
  color: hsl(var(--foreground));
}

.sv-docs ul,
.sv-docs ol {
  margin: 0.6rem 0 0.9rem 1.25rem;
  padding: 0;
}
.sv-docs li { margin: 0.25rem 0; }

.sv-docs a {
  color: hsl(var(--primary));
  text-decoration: underline;
  text-underline-offset: 2px;
}
.sv-docs a:hover { opacity: 0.9; }

.sv-docs blockquote {
  margin: 1rem 0;
  padding: 0.6rem 0.9rem;
  border-left: 3px solid hsl(var(--border));
  background: hsl(var(--accent));
  color: hsl(var(--foreground));
  border-radius: 0.25rem;
}

.sv-docs table {
  width: 100%;
  margin: 1rem 0;
  border-collapse: collapse;
  font-size: 0.95rem;
}
.sv-docs th,
.sv-docs td {
  padding: 0.5rem 0.6rem;
  border: 1px solid hsl(var(--border));
}
.sv-docs th {
  text-align: left;
  background: hsl(var(--muted));
}

/* ---------------------------------------------- */
/* 4) Code & syntax highlighting                  */
/*    (rehype-pretty-code + Shiki)                */
/* ---------------------------------------------- */

/* Tweak here to change density in one place */
.sv-docs { --docs-code-lh: 0.9; } 

.sv-docs pre {
  position: relative;
  margin: 1rem 0 1.25rem;
  padding: 1rem 1.125rem;
  overflow-x: auto;
  border: 1px solid hsl(var(--border));
  border-radius: 0.5rem;
  font-size: 0.9rem;
  line-height: var(--docs-code-lh); /* was 1.45 */
}

/* Avoid double backgrounds inside fenced blocks */
.sv-docs pre code {
  background: transparent;
  padding: 0;
}

/* pretty-code: each line is a span; keep them block-level and inherit the tighter line-height */
.sv-docs pre code > span {
  display: block;
  line-height: inherit; /* ensures tighter spacing applies to each line */
}

/* Inline code */
.sv-docs :not(pre) > code {
  display: inline;
  padding: 0.12rem 0.35rem;
  border: 1px solid hsl(var(--border));
  border-radius: 0.35rem;
  background: hsl(var(--accent));
  color: hsl(var(--foreground));
  font-size: 0.9em;
}

/* Dual-theme token colors produced by Shiki */
.sv-docs code[data-theme*=" "],
.sv-docs code[data-theme*=" "] span {
  color: var(--shiki-light);
  background-color: var(--shiki-light-bg);
}
html.dark .sv-docs code[data-theme*=" "],
html.dark .sv-docs code[data-theme*=" "] span {
  color: var(--shiki-dark);
  background-color: var(--shiki-dark-bg);
}

/* Optional: line/word highlights from pretty-code */
.sv-docs .line--highlighted { background: hsl(var(--accent)); }
.sv-docs .word--highlighted {
  padding: 0.05rem 0.2rem;
  border-radius: 0.2rem;
  background: hsl(var(--primary));
  color: hsl(var(--primary-foreground));
}

/* Heading anchors */
.sv-docs .anchor {
  position: relative;
  color: inherit;
  text-decoration: none;
}
.sv-docs .anchor:hover { text-decoration: underline; }

/* Copy button */
.sv-docs pre .sv-copy-btn {
  position: absolute;
  top: 0.4rem;
  right: 0.4rem;
  padding: 0.2rem 0.55rem;
  border: 1px solid hsl(var(--border));
  border-radius: 0.35rem;
  background: hsl(var(--accent));
  color: hsl(var(--foreground));
  font-size: 0.75rem;
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.2s ease-in-out;
}
.sv-docs pre:hover .sv-copy-btn { opacity: 1; }
@media (prefers-reduced-motion: reduce) {
  .sv-docs pre .sv-copy-btn { transition: none; }
}

/* Let <pre> background follow computed theme vars from Shiki */
.sv-docs pre[data-theme] {
  background: var(--shiki-light-bg, hsl(var(--muted)));
  color: var(--shiki-light, hsl(var(--foreground)));
}
.dark .sv-docs pre[data-theme] {
  background: var(--shiki-dark-bg, hsl(var(--muted)));
  color: var(--shiki-dark, hsl(var(--foreground)));
}

/* Scroll-to-top floating button */
.sv-to-top {
  position: fixed;
  left: 50%;
  bottom: clamp(12px, 2.5vh, 24px);
  transform: translateX(-50%);
  display: inline-flex;
  align-items: center;
  justify-content: center;

  width: 38px;
  height: 38px;
  border-radius: 9999px;

  background: color-mix(in oklab, hsl(var(--card)) 88%, transparent);
  color: hsl(var(--foreground));
  border: 1px solid hsl(var(--border));
  box-shadow: 0 6px 18px rgba(0,0,0,.12);

  opacity: .85;
  backdrop-filter: blur(6px);
  transition: opacity .18s ease, transform .18s ease;
  z-index: 60;
}
.sv-to-top:hover { opacity: 1; transform: translateX(-50%) translateY(-2px); }
.sv-to-top:active { transform: translateX(-50%) translateY(0); }
</file>

<file path="package.json">
{
  "name": "savva-ui-solidjs",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "release": "node scripts/release.mjs",
    "i18n": "node scripts/i18n.mjs && node scripts/i18n-docs.mjs"
  },
  "dependencies": {
    "@shikijs/themes": "^3.11.0",
    "@solidjs/router": "^0.15.3",
    "dompurify": "^3.2.6",
    "dotenv": "^17.2.1",
    "js-yaml": "^4.1.0",
    "marked": "^16.2.0",
    "openai": "^5.12.2",
    "rehype-autolink-headings": "^7.1.0",
    "rehype-pretty-code": "^0.14.1",
    "rehype-slug": "^6.0.0",
    "rehype-stringify": "^10.0.1",
    "remark-breaks": "^4.0.0",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.1",
    "remark-parse": "^11.0.0",
    "remark-rehype": "^11.1.2",
    "shiki": "^3.11.0",
    "solid-js": "^1.9.8",
    "unified": "^11.0.5",
    "viem": "^2.33.3",
    "yaml": "^2.8.1"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.12",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.12",
    "vite": "^7.1.2",
    "vite-plugin-solid": "^2.11.8"
  }
}
</file>

<file path="src/components/editor/EditorFilesDrawer.jsx">
// src/components/editor/EditorFilesDrawer.jsx
import { Show, createSignal, For, createEffect, on, createMemo } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { listUploadedFiles, addUploadedFile, addUploadedFileFromUrl, deleteUploadedFile } from "../../editor/storage.js";
import FileGridItem from "./FileGridItem.jsx";
import UploadFromUrlModal from "./UploadFromUrlModal.jsx";
import { pushToast, pushErrorToast } from "../../ui/toast.js";
import ConfirmModal from "../ui/ConfirmModal.jsx";
import FileContextMenu from "./FileContextMenu.jsx";
import { formatBytes } from "../../utils/format.js";
function CloseIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-6 h-6"} fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
  );
}

export default function EditorFilesDrawer(props) {
 const { t } = useApp();
  const [files, setFiles] = createSignal([]);
  const [showUrlModal, setShowUrlModal] = createSignal(false);
  const [fileToDelete, setFileToDelete] = createSignal(null);
  const [menuData, setMenuData] = createSignal(null);
  let fileInputRef;
  let drawerContentRef;

   const baseDir = () => props.baseDir;

  const sortedFiles = createMemo(() => {
    return [...files()].sort((a, b) => (b.size || 0) - (a.size || 0));
  });

  const totalSize = createMemo(() => {
    return files().reduce((acc, file) => acc + (file.size || 0), 0);
  });

  const refreshFiles = async () => {
    if (!baseDir()) return;
    const fileList = await listUploadedFiles(baseDir());
    setFiles(fileList);
  };

  createEffect(on(() => props.isOpen, (isOpen) => {
    if (isOpen) refreshFiles();
    else setMenuData(null);
  }));

  createEffect(on(() => props.filesRevision, () => {
    if (props.isOpen) {
      refreshFiles();
    }
  }, { defer: true }));

  const handleFileSelect = async (e) => {
    const selectedFiles = Array.from(e.currentTarget.files);
    if (selectedFiles.length === 0) return;
    for (const file of selectedFiles) await addUploadedFile(baseDir(), file);
    await refreshFiles();
    if (fileInputRef) fileInputRef.value = "";
  };

  const handleUrlUpload = async (url) => {
    try {
      const file = await addUploadedFileFromUrl(baseDir(), url);
      pushToast({ type: "success", message: t("editor.files.uploadSuccess", { name: file.name }) });
      await refreshFiles();
    } catch (error) {
      pushErrorToast(error, { context: t("editor.files.uploadError") });
      throw error;
    }
  };

  const handleDelete = (fileName) => setFileToDelete(fileName);
  
  const confirmDelete = async () => {
    try {
      await deleteUploadedFile(baseDir(), fileToDelete());
      await refreshFiles();
    } catch (error) {
      pushErrorToast(error, { context: "File deletion failed" });
    }
  };


  const handleMenuOpen = ({ file, fileType, element }) => {
    const drawerRect = drawerContentRef.getBoundingClientRect();
    const itemRect = element.getBoundingClientRect();
    
    let x = itemRect.left - drawerRect.left;
    let y = element.offsetTop;

    const menuWidth = 192;
    const menuHeight = 150;
    const padding = 16;

    if (x + menuWidth > drawerRect.width - padding) {
      x = drawerRect.width - menuWidth - padding;
    }
    if (y + menuHeight > drawerContentRef.scrollHeight) {
      y = drawerContentRef.scrollHeight - menuHeight - 5;
    }
    
    setMenuData({ file, fileType, x, y });
  };

  const menuItems = createMemo(() => {
    const data = menuData();
    if (!data) return [];
    const { file, fileType } = data;
    const items = [];
    if (fileType === 'image' || fileType === 'video' || fileType === 'audio') {
      items.push({ label: t("editor.files.menu.insert"), onClick: () => props.onInsert(file.name, fileType) });
    }
    if (fileType === 'image') {
      items.push({ label: t("editor.files.menu.setThumbnail"), onClick: () => props.onSetThumbnail(file.name) });
    }
    items.push({ label: t("editor.files.menu.insertUrl"), onClick: () => props.onInsertUrl(file.name) });
    items.push({ label: t("editor.files.menu.delete"), onClick: () => handleDelete(file.name) });
    return items;
  });

  return (
    <>
      <div
        class={`fixed top-0 right-0 w-80 h-full bg-[hsl(var(--popover))] text-[hsl(var(--popover-foreground))] shadow-lg z-50 transition-transform duration-300 ${props.isOpen ? "translate-x-0" : "translate-x-full"}`}
        style="border-left: 1px solid hsl(var(--border));"
      >
        <div class="h-full flex flex-col">
          <header class="flex items-center justify-between p-4 border-b border-[hsl(var(--border))]">
            <h3 class="font-semibold">{t("editor.sidebar.files")}</h3>
            <button onClick={props.onClose} class="p-1 rounded-full hover:bg-[hsl(var(--accent))]"><CloseIcon /></button>
          </header>

          <div class="p-4 border-b border-[hsl(var(--border))] space-y-2">
            <input type="file" ref={fileInputRef} multiple onChange={handleFileSelect} class="hidden" />
            <button onClick={() => fileInputRef.click()} class="w-full text-sm px-3 py-2 rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))]">
              {t("editor.files.uploadFromDisk")}
            </button>
            <button onClick={() => setShowUrlModal(true)} class="w-full text-sm px-3 py-2 rounded border border-[hsl(var(--input))] hover:bg-[hsl(var(--accent))]">
              {t("editor.files.uploadFromUrl")}
            </button>
          </div>

          <div ref={drawerContentRef} class="flex-1 p-4 overflow-y-auto relative">
            <Show when={sortedFiles().length > 0} fallback={
              <div class="h-full flex items-center justify-center text-center text-xs text-[hsl(var(--muted-foreground))]">
                {t("editor.files.empty")}
              </div>
            }>
              <div class="grid grid-cols-3 gap-2">
                <For each={sortedFiles()}>
                  {(file) => <FileGridItem 
                    file={file}
                    onMenuOpen={handleMenuOpen}
                  />}
                </For>
              </div>
            </Show>
            <Show when={menuData()}>
              <FileContextMenu 
                x={menuData().x} 
                y={menuData().y} 
                items={menuItems()} 
                onClose={() => setMenuData(null)} 
              />
            </Show>
          </div>

          <footer class="p-4 border-t border-[hsl(var(--border))] text-xs text-center text-[hsl(var(--muted-foreground))]">
            Total Size: <strong>{formatBytes(totalSize())}</strong>
          </footer>
        </div>
      </div>
      <Show when={props.isOpen}><div class="fixed inset-0 z-40 bg-black/20" onClick={props.onClose} /></Show>
      <UploadFromUrlModal isOpen={showUrlModal()} onClose={() => setShowUrlModal(false)} onUpload={handleUrlUpload} />
      <ConfirmModal
        isOpen={!!fileToDelete()}
        onClose={() => setFileToDelete(null)}
        onConfirm={confirmDelete}
        title={t("editor.files.confirmDeleteTitle")}
        message={t("editor.files.confirmDeleteMessage", { name: fileToDelete() })}
      />
    </>
  );
}
</file>

<file path="src/components/post/ReactionInput.jsx">
// src/components/post/ReactionInput.jsx
import { createMemo, Show, createSignal, createEffect, For, onCleanup } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import ReactionIcon, { REACTION_TYPES } from "../ui/icons/ReactionIcon.jsx";
import { pushErrorToast } from "../../ui/toast.js";
import { dbg } from "../../utils/debug.js";

export default function ReactionInput(props) {
  const app = useApp();
  const { t, wsCall } = app;
  const [isProcessing, setIsProcessing] = createSignal(false);
  const [showPalette, setShowPalette] = createSignal(false);
  const [isMouseOver, setIsMouseOver] = createSignal(false);
  const [isGracePeriod, setIsGracePeriod] = createSignal(false);
  const [paletteStyle, setPaletteStyle] = createSignal({});
  let containerRef;
  let showTimerId, graceTimerId;

  const [myReactionIndex, setMyReactionIndex] = createSignal(
    props.post?._raw?.my_reaction ?? props.post?.my_reaction ?? -1
  );

  createEffect(() => {
    const update = app.postUpdate();
    const authorizedUserAddress = app.authorizedUser()?.address;
    const postId = props.post?._raw?.savva_cid || props.post?.savva_cid || props.post?.id;

    if (
      update &&
      update.type === 'reactionsChanged' &&
      update.cid === postId &&
      authorizedUserAddress &&
      update.data?.user?.toLowerCase() === authorizedUserAddress.toLowerCase()
    ) {
      setMyReactionIndex(update.data.reaction);
    }
  });
  
  createEffect(() => {
    if (showPalette() && containerRef) {
      const buttonRect = containerRef.getBoundingClientRect();
      const paletteWidth = 300; // Estimated width of the palette
      const screenPadding = 10;

      const idealViewportLeft = buttonRect.left + (buttonRect.width / 2) - (paletteWidth / 2);

      let finalRelativeLeft;

      if (idealViewportLeft + paletteWidth > window.innerWidth - screenPadding) {
        finalRelativeLeft = buttonRect.width - paletteWidth;
      } 
      else if (idealViewportLeft < screenPadding) {
        finalRelativeLeft = 0;
      } 
      else {
        finalRelativeLeft = (buttonRect.width / 2) - (paletteWidth / 2);
      }
      
      setPaletteStyle({ left: `${finalRelativeLeft}px` });
    }
  });

  onCleanup(() => {
    if (showTimerId) clearTimeout(showTimerId);
    if (graceTimerId) clearTimeout(graceTimerId);
  });

  const handleContainerEnter = () => {
    setIsMouseOver(true);
    if (showTimerId) clearTimeout(showTimerId);
    if (showPalette()) return; 

    showTimerId = setTimeout(() => {
      setShowPalette(true);
      setIsGracePeriod(true);
      if (graceTimerId) clearTimeout(graceTimerId);
      graceTimerId = setTimeout(() => {
        setIsGracePeriod(false);
        if (!isMouseOver()) {
          setShowPalette(false);
        }
      }, 3000);
    }, 1000);
  };

  const handleContainerLeave = () => {
    setIsMouseOver(false);
    if (showTimerId) clearTimeout(showTimerId);
    if (!isGracePeriod()) {
      setShowPalette(false);
    }
  };

  const sendReaction = async (reactionIndex) => {
    if (isProcessing()) return;
    setIsProcessing(true);
    
    const postId = props.post?._raw?.savva_cid || props.post?.savva_cid || props.post?.id;

    try {
      await wsCall('react', {
        domain: app.selectedDomainName(),
        'obj-type': 0,
        'obj-id': postId,
        n: 0,
        reaction: reactionIndex,
      });
    } catch (e) {
      pushErrorToast(e, { context: "Failed to submit reaction" });
      dbg.error("ReactionInput", "Failed to send reaction", e);
    } finally {
      setIsProcessing(false);
      setShowPalette(false);
      setIsGracePeriod(false);
      if (graceTimerId) clearTimeout(graceTimerId);
    }
  };

  const handleMainButtonClick = (e) => {
    e.stopPropagation();
    const newReaction = myReactionIndex() >= 0 ? -1 : 0; 
    sendReaction(newReaction);
  };

  const hasReacted = createMemo(() => myReactionIndex() >= 0);
  const reactionType = createMemo(() => {
    const index = myReactionIndex();
    return index >= 0 ? REACTION_TYPES[index] : 'like';
  });
  const reactionLabel = createMemo(() => t(`reactions.${reactionType()}`));

  return (
    <div 
      class="relative inline-block reaction-input-container" 
      onMouseEnter={handleContainerEnter}
      onMouseLeave={handleContainerLeave}
      ref={containerRef}
    >
      <Show when={showPalette()}>
        <div 
          class="absolute bottom-full z-50 mb-1 p-1.5 flex items-center gap-1 rounded-full bg-[hsl(var(--popover))] shadow-lg border border-[hsl(var(--border))]"
          style={paletteStyle()}
        >
          <For each={REACTION_TYPES}>
            {(type, index) => (
              <button 
                onClick={(e) => {
                  e.stopPropagation();
                  sendReaction(index());
                }}
                class="p-1 rounded-full hover:bg-[hsl(var(--accent))]"
                title={t(`reactions.${type}`)}
              >
                <ReactionIcon type={type} class="text-xl" />
              </button>
            )}
          </For>
        </div>
      </Show>

      <button
        onClick={handleMainButtonClick}
        disabled={isProcessing()}
        class="flex items-center justify-center gap-2 px-3 py-1.5 rounded-md text-sm bg-transparent hover:bg-[hsl(var(--accent))] disabled:opacity-50"
        classList={{
          "text-[hsl(var(--muted-foreground))]": !hasReacted(),
          "text-blue-500": hasReacted()
        }}
      >
        <ReactionIcon
          type={reactionType()}
          class={`text-sm ${!hasReacted() ? 'grayscale' : ''}`}
        />
        <Show when={hasReacted()}>
          <span>{reactionLabel()}</span>
        </Show>
      </button>
    </div>
  );
}
</file>

<file path="src/components/tabs/LeadersTab.jsx">
// src/components/tabs/LeadersTab.jsx
import { createMemo, createResource, createSignal, Show, For, createEffect } from "solid-js";
import ContentFeed from "../feed/ContentFeed.jsx";
import { useApp } from "../../context/AppContext.jsx";
import { loadAssetResource } from "../../utils/assetLoader";
import ViewModeToggle, { viewMode } from "../ui/ViewModeToggle.jsx";
import { toChecksumAddress } from "../../blockchain/utils.js";
import { whenWsOpen } from "../../net/wsRuntime.js";

function useDomainCategories(app) {
  const cfg = () => app.domainAssetsConfig?.();
  const relPath = createMemo(() => cfg()?.modules?.categories || null);
  const lang = () => (app.lang?.() || "en").toLowerCase();
  const params = createMemo(() => ({ rel: relPath(), lang: lang() }));
  const [cats] = createResource(params, async ({ rel, lang }) => {
    if (!rel) return [];
    try {
      const data = await loadAssetResource(app, rel, { type: "yaml" });
      const listByLang = data?.locales?.[lang] || data?.locales?.en || [];
      return (Array.isArray(listByLang) ? listByLang : []).map(String);
    } catch (err) {
      console.error(`Failed to load categories from ${rel}:`, err);
      return [];
    }
  });
  return cats;
}

const TIME_FRAMES = ["month", "week", "year", "all"];

export default function LeadersTab(props) {
  const app = useApp();
  const lang = createMemo(() => (app.lang?.() || "en").toLowerCase());
  const [category, setCategory] = createSignal("ALL");
  const [timeFrame, setTimeFrame] = createSignal("month");
  const categoriesRes = useDomainCategories(app);
  const categoriesWithAll = createMemo(() => ["ALL", ...(categoriesRes() || [])]);

  createEffect(() => {
    const newList = categoriesRes();
    const currentSelection = category();
    if (newList && currentSelection !== "ALL" && !newList.includes(currentSelection)) {
      setCategory("ALL");
    }
  });

  const domainName = () => {
    const d = app.selectedDomain?.();
    return typeof d === "string" ? d : d?.name || "";
  };
  const contentList = app.wsMethod ? app.wsMethod("content-list") : null;

  const feedResetKey = createMemo(() => `${domainName()}|${category()}|${timeFrame()}`);

  async function fetchPage(page, pageSize) {
    const limit = pageSize;
    const offset = (page - 1) * pageSize;
    try {
      await whenWsOpen();
      if (!contentList) return [];
      const params = {
        domain: domainName(),
        content_type: "post",
        limit,
        offset,
        lang: lang(),
        order_by: 'total_author_share'
      };
      
      const cat = category();
      if (cat && cat !== "ALL") {
        params.category = `${lang()}:${cat}`;
      }

      const user = app.authorizedUser();
      if (user?.address) {
        params.my_addr = toChecksumAddress(user.address);
      }

      const selectedTime = timeFrame();
      if (selectedTime !== "all") {
        const now = new Date();
        let pastDate = new Date();
        if (selectedTime === 'week') pastDate.setDate(now.getDate() - 7);
        if (selectedTime === 'month') pastDate.setMonth(now.getMonth() - 1);
        if (selectedTime === 'year') pastDate.setFullYear(now.getFullYear() - 1);


        // MODIFICATION: Changed to standard ISO string format.
        params.min_time = pastDate.toISOString();
      }

      const res = await contentList(params);
      const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];
      return arr.map((it) => ({
        id: it?.savva_cid || it?.savvaCID || it?.id,
        _raw: it,
      }));
    } catch (err) {
      console.error("fetchPage error:", err);
      return [];
    }
  }

  return (
    <section class="w-full">
      <div class="mb-3 flex items-center gap-3">
        <ViewModeToggle size="md" />
        <div class="ml-auto flex items-center gap-4">
          <div class="flex items-center gap-2 min-w-[220px]">
            <span class="text-xs opacity-70">{app.t("newTab.category")}</span>
            <select
              class="flex-1 px-3 h-9 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
              value={category()}
              onInput={(e) => setCategory(e.currentTarget.value)}
              aria-label={app.t("newTab.category")}
            >
              <For each={categoriesWithAll()}>
                {(c) => <option value={c}>{c === "ALL" ? app.t("categories.all") : c}</option>}
              </For>
            </select>
          </div>
          <div class="flex items-center gap-2">
            <select
              class="flex-1 px-3 h-9 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
              value={timeFrame()}
              onInput={(e) => setTimeFrame(e.currentTarget.value)}
              aria-label="Time frame"
            >
              <For each={TIME_FRAMES}>
                {(frame) => <option value={frame}>{app.t(`timeFrame.${frame}`)}</option>}
              </For>
            </select>
          </div>
        </div>
      </div>
      <ContentFeed
        mode={viewMode()}
        fetchPage={fetchPage}
        pageSize={12}
        resetOn={feedResetKey()}
        isRailVisible={props.isRailVisible}
        isActivated={props.isActivated}
      />
    </section>
  );
}
</file>

<file path="src/components/ui/IpfsImage.jsx">
// src/components/ui/IpfsImage.jsx
import { createSignal, createEffect, Show, Switch, Match } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { ipfs } from "../../ipfs/index.js";
import Spinner from "./Spinner.jsx";

export default function IpfsImage(props) {
  const app = useApp();
  const [imageUrl, setImageUrl] = createSignal(null);
  const [loading, setLoading] = createSignal(true);

  createEffect(async () => {
    setLoading(true);
    setImageUrl(null);

    const gateways = app.activeIpfsGateways();
    if (!props.src || gateways.length === 0) {
      setLoading(false);
      return;
    }

    try {
      const { url } = await ipfs.fetchBest(app, props.src, { postGateways: props.postGateways });
      setImageUrl(url);
    } catch (e) {
      // Fallback silently on any error, but keep the log for debugging.
      console.error(`[IpfsImage] All gateways failed for ${props.src}:`, e.causes || e);
    } finally {
      setLoading(false);
    }
  });

  return (
    <div class={`relative w-full h-full ${props.class || ""}`}>
      <Switch>
        <Match when={loading()}>
          <div class="absolute inset-0 flex items-center justify-center bg-[hsl(var(--muted))]">
            <Spinner />
          </div>
        </Match>
        <Match when={imageUrl()}>
          <img
            src={imageUrl()}
            alt={props.alt || "IPFS Image"}
            class="absolute inset-0 w-full h-full object-cover"
            onError={() => setImageUrl(null)}
          />
        </Match>
        <Match when={!imageUrl()}>
          {props.fallback}
        </Match>
      </Switch>
    </div>
  );
}
</file>

<file path="src/components/ui/UserCard.jsx">
// src/components/ui/UserCard.jsx
import { Show, createMemo } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import IpfsImage from "./IpfsImage.jsx";
import UnknownUserIcon from "./icons/UnknownUserIcon.jsx";
import VerifiedBadge from "./icons/VerifiedBadge.jsx";
import StakerLevelIcon from "./StakerLevelIcon.jsx";
import { navigate } from "../../routing/hashRouter.js";

function isVerified(a) {
    return Boolean(a && a.name);
}

function shortAddr(addr) {
  if (!addr) return "";
  return addr.slice(0, 6) + "…" + addr.slice(-4);
}

export default function UserCard(props) {
    const { t } = useApp();
    const author = () => props.author || {};

    const hasName = createMemo(() => author().name || author().display_name);

    const handleUserClick = (e) => {
        e.stopPropagation();
        const user = author();
        if (!user) return;
        const targetPath = user.name ? `/@${user.name}` : `/${user.address}`;
        navigate(targetPath);
    };

    return (
        <Show when={author()}>
            <div class={`flex items-center w-full ${props.compact ? 'h-auto' : 'h-10'}`}>
                <div class="flex items-center gap-2 cursor-pointer min-w-0" onClick={handleUserClick}>
                    <Show when={!props.compact}>
                        <div class="w-8 h-8 rounded-full overflow-hidden shrink-0 bg-[hsl(var(--muted))]">
                            <Show
                                when={author().avatar}
                                fallback={<UnknownUserIcon class="w-full h-full object-cover" />}
                            >
                                <IpfsImage
                                    src={author().avatar}
                                    alt={`${author().name || t("default.user")} ${t("default.avatar")}`}
                                    class="w-full h-full object-cover"
                                />
                            </Show>
                        </div>
                    </Show>

                    <div class="min-w-0">
                        <Show when={author().display_name && !props.compact}>
                            <div class="text-xs truncate text-[hsl(var(--foreground))] w-full">
                                {author().display_name}
                            </div>
                        </Show>

                        <div class={`flex items-center gap-1 min-w-0 ${props.compact ? 'text-[11px]' : 'text-xs'} text-[hsl(var(--muted-foreground))]`}>
                            <Show when={author().name}>
                                <div class="min-w-0 flex items-center">
                                    <span class="truncate uppercase font-semibold">{author().name}</span>
                                    <Show when={isVerified(author())}>
                                        <VerifiedBadge class="ml-0.5 w-3.5 h-3.5 shrink-0" />
                                    </Show>
                                </div>
                            </Show>
                            
                            <Show when={!hasName() && author().address}>
                                <span class="font-mono">{shortAddr(author().address)}</span>
                            </Show>

                            <StakerLevelIcon
                                staked={author().staked}
                                class={`${props.compact ? 'w-5 h-4' : 'w-7 h-6'} shrink-0 text-[hsl(var(--muted-foreground))]`}
                            />
                        </div>
                    </div>
                </div>
            </div>
        </Show>
    );
}
</file>

<file path="src/components/App.jsx">
// src/components/App.jsx
import { createSignal, onMount, Show, createMemo, createEffect, on, Switch, Match } from "solid-js";
import Header from "./Header";
import RightPane from "./RightPane";
import Settings from "../pages/Settings";
import Docs from "../pages/Docs";
import { useHashRouter, navigate } from "../routing/hashRouter";
import { useApp } from "../context/AppContext.jsx";
import Toaster from "./Toaster";
import MainView from "./main/MainView";
import DomainCssLoader from "../theme/DomainCssLoader.jsx";
import FaviconLoader from "../theme/FaviconLoader.jsx";
import GoogleAnalyticsLoader from "../theme/GoogleAnalyticsLoader.jsx";
import WsConnector from "./net/WsConnector.jsx";
import ConnectionError from "./main/ConnectionError.jsx";
import Spinner from "./ui/Spinner.jsx";
import AssetDebugTap from "../dev/AssetDebugTap.jsx";
import PostPage from "../pages/PostPage";
import EditorPage from "../pages/EditorPage.jsx";
import AlertManager from "../alerts/AlertManager.jsx";
import SwitchAccountModal from "./auth/SwitchAccountModal.jsx";
import ProfilePage from "../pages/ProfilePage.jsx";

export default function App() {
  const [isPaneOpen, setIsPaneOpen] = createSignal(false);
  const { route } = useHashRouter();
  const app = useApp();

  const currentView = createMemo(() => {
    const r = route();
    if (r.startsWith("/post/")) return "post";
    if (r.startsWith("/settings")) return "settings";
    if (r.startsWith("/docs")) return "docs";
    if (r.startsWith("/editor/")) return "editor";
    if (r.startsWith("/@") || r.startsWith("/0x")) return "profile";
    return "main";
  });

  // ADD THIS BLOCK BACK
  const domainRevision = createMemo(() => {
    if (app.loading()) return null;
    const domainName = app.selectedDomainName?.();
    const source = app.domainAssetsSource?.();
    const cfg = app.domainAssetsConfig?.();
    const cid = cfg?.assets_cid || cfg?.cid || "";
    const tabsPath = cfg?.modules?.tabs || "";
    return `${domainName}|${source}|${cid}|${tabsPath}`;
  });

  onMount(() => {
    const handleKeydown = (e) => {
      if (e.key !== "Escape") return;
      
      const view = currentView();
      if (view !== 'main') {
        navigate(app.lastTabRoute() || "/");
        return; 
      }
      
      setIsPaneOpen(false);
    };
    document.addEventListener("keydown", handleKeydown);
    return () => document.removeEventListener("keydown", handleKeydown);
  });

  createEffect(on(currentView, (view) => {
    if (view === 'main') {
      requestAnimationFrame(() => {
        const y = app.savedScrollY();
        window.scrollTo(0, y);
      });
    }
  }));

  const togglePane = () => setIsPaneOpen(!isPaneOpen());

  return (
    <Show
      when={!app.loading()}
      fallback={
        <div class="fixed inset-0 flex items-center justify-center bg-[hsl(var(--background))]">
          <Spinner class="w-8 h-8" />
        </div>
      }
    >
      <Show
        when={!app.error()}
        fallback={<ConnectionError error={app.error()} />}
      >
        <div class="min-h-screen bg-[hsl(var(--background))] text-[hsl(var(--foreground))] transition-colors duration-300">
          <DomainCssLoader />
          <FaviconLoader />
          <GoogleAnalyticsLoader />
          <WsConnector />
          <AlertManager />
          
          <Show when={domainRevision()} keyed>
            <>
              <Header onTogglePane={togglePane} />
              
              <Switch>
                <Match when={currentView() === 'main'}>
                  <MainView />
                </Match>
                <Match when={currentView() === 'post'}>
                  <PostPage />
                </Match>
                <Match when={currentView() === 'profile'}>
                  <ProfilePage />
                </Match>
                <Match when={currentView() === 'settings'}>
                  <Settings />
                </Match>
                <Match when={currentView() === 'docs'}>
                  <Docs />
                </Match>
                <Match when={currentView() === 'editor'}>
                  <EditorPage />
                </Match>
              </Switch>
            </>
          </Show>
          
          <RightPane isOpen={isPaneOpen} onClose={togglePane} />
          <Toaster />
          <AssetDebugTap />
          
          <SwitchAccountModal
            isOpen={app.isSwitchAccountModalOpen()}
            requiredAddress={app.requiredAccount()}
            onSuccess={app.resolveSwitchAccountPrompt}
            onCancel={app.rejectSwitchAccountPrompt}
          />
        </div>
      </Show>
    </Show>
  );
}
</file>

<file path="src/net/WsClient.js">
// src/net/WsClient.js
import { dbg } from "../utils/debug";
import { wsUrl as endpointsWsUrl } from "./endpoints";

/**
 * Pure WebSocket transport.
 * Request:  { id: number, type: string, data: any }
 * Response: { id?: number, type?: string, error?: string, data?: any }
 * Alerts:   { type: string, data?: any }  (no id)
 */
export default class WsClient {
  constructor({ url = "", protocols } = {}) {
    this._url = url || "";
    this._protocols = protocols || undefined;
    this._ws = null;
    this._manualClose = false;

    this._status = "idle"; // idle | connecting | open | closed
    this._attempt = 0;
    this._shouldReconnect = true;
    this._reconnectTid = null;

    this._heartbeatTid = null;
    this._heartbeatMs = 25_000;

    this._sendQueue = [];
    this._pending = new Map(); // id (string) -> { resolve, reject, timer }
    this._nextId = 1;

    this._listeners = new Map();

    this._onOnline = () => this.reconnect("online");
    if (typeof window !== "undefined") {
      window.addEventListener("online", this._onOnline);
      window.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible" && this._status !== "open") {
          this.reconnect("visible");
        }
      });
    }
  }

  // ─── public API ───────────────────────────────────────────────────────────────
  dispose() {
    this._shouldReconnect = false;
    this._clearReconnect();
    this._stopHeartbeat();
    if (this._ws) {
      try {
        this._ws.close();
      } catch {}
    }
    this._ws = null;
    if (typeof window !== "undefined") {
      window.removeEventListener("online", this._onOnline);
    }
    this._failInflight(new Error("WS disposed"));
    this._emit("status", "closed");
  }

  url() {
    return this._url;
  }
  status() {
    return this._status;
  }
  attempt() {
    return this._attempt;
  }

  setUrl(nextUrl) {
    const source = nextUrl == null ? endpointsWsUrl() : nextUrl;
    const u = String(source || "");
    if (!u) {
      dbg.warn("ws", "No WS URL configured");
      return;
    }
    if (u === this._url) return;
    this._url = u;
    dbg.log("ws", "URL updated", { url: u });
  }

  setAutoReconnect(on) {
    this._shouldReconnect = !!on;
  }

  connect() {
    if (!this._url) return;
    if (
      this._ws &&
      (this._ws.readyState === WebSocket.OPEN ||
        this._ws.readyState === WebSocket.CONNECTING)
    ) {
      return;
    }
    this._clearReconnect();
    this._setStatus("connecting");
    dbg.log("ws", "Connecting…", { url: this._url });

    try {
      const ws = new WebSocket(this._url, this._protocols);
      this._ws = ws;

      ws.addEventListener("open", () => {
        this._attempt = 0;
        this._setStatus("open");
        dbg.log("ws", "Connected", { url: this._url });
        this._flushQueue();
        this._startHeartbeat();
        this._emit("open");
      });

      ws.addEventListener("message", (ev) => this._onMessage(ev));

      ws.addEventListener("error", (ev) => {
        dbg.warn("ws", "Error", { event: ev });
        this._emit("error", ev);
      });

      ws.addEventListener("close", (ev) => {
        dbg.warn("ws", "Closed", { code: ev.code, reason: ev.reason });
        this._stopHeartbeat();
        this._setStatus("closed");
        this._emit("close", ev);
        
        // Only fail inflight requests on unexpected closures.
        if (!this._manualClose) {
          this._failInflight(new Error("WS closed"));
        }
        
        if (this._shouldReconnect && !this._manualClose) {
          this._scheduleReconnect();
        }
        this._manualClose = false;
      });
    } catch (e) {
      dbg.error("ws", "Connect exception", e);
      this._setStatus("closed");
      this._scheduleReconnect();
    }
  }

  reconnect(reason = "manual") {
    dbg.log("ws", "Reconnecting…", { reason });
    this._clearReconnect();
    if (this._ws) {
      this._manualClose = true; 
      try { this._ws.close(1000, `reconnect: ${reason}`); } catch {}
    }
    this._ws = null;
    
    this.connect();
  }

  close() {
    this._manualClose = true;
    this._clearReconnect();
    this._stopHeartbeat();
    this._shouldReconnect = false;
    try {
      this._ws && this._ws.close(1000, "client-close");
    } catch {}
    this._ws = null;
    this._setStatus("closed");
    this._failInflight(new Error("WS closed by client"));
  }

  send(data) {
    const open = this._ws && this._ws.readyState === WebSocket.OPEN;
    if (open) this._ws.send(data);
    else this._sendQueue.push(data);
  }
  sendJson(obj) {
    this.send(JSON.stringify(obj));
  }

  call(method, params = {}, { timeoutMs = 15_000, id } = {}) {
    const numericId = Number.isFinite(id) ? id : this._nextId++;
    const callId = String(numericId);

    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        this._pending.delete(callId);
        const err = new Error("WS request timeout");
        err.code = "ETIMEDOUT";
        reject(err);
      }, timeoutMs);

      this._pending.set(callId, { resolve, reject, timer });
      this.sendJson({
        id: numericId,
        type: String(method),
        data: params || {},
      });
    });
  }

  on(type, fn) {
    const key = String(type || "");
    const set = this._listeners.get(key) || new Set();
    set.add(fn);
    this._listeners.set(key, set);
    return () => this.off(key, fn);
  }
  off(type, fn) {
    const set = this._listeners.get(type);
    if (!set) return;
    set.delete(fn);
    if (set.size === 0) this._listeners.delete(type);
  }

  _setStatus(s) {
    if (this._status !== s) {
      this._status = s;
      this._emit("status", s);
    }
  }

  _emit(type, payload) {
    const set = this._listeners.get(type);
    if (!set || set.size === 0) return;
    for (const fn of Array.from(set)) {
      try {
        fn(payload);
      } catch (e) {
        dbg.error("ws", "listener error", e);
      }
    }
  }

  _onMessage(ev) {
    try {
      const obj = JSON.parse(ev.data);

      if (obj && obj.id > 0) {
        const key = String(obj.id);
        const entry = this._pending.get(key);
        if (entry) {
          clearTimeout(entry.timer);
          this._pending.delete(key);

          if (typeof obj.error === "string" && obj.error) {
            if (obj.error.toLowerCase() === "not authenticated") {
              this._emit("auth_error", obj);
            }
            const err = new Error(obj.error || "WS error");
            err.code = "WS_ERROR";
            entry.reject(err);
          } else if ("data" in obj) {
            entry.resolve(obj.data);
          } else if ("result" in obj) {
            entry.resolve(obj.result);
          } else {
            entry.resolve(obj);
          }
        } else {
          dbg.warn("ws", "Received response for untracked call ID", { id: obj.id });
        }
      } else {
        if (obj && obj.type) {
          this._emit(obj.type, obj.data ?? obj);
          this._emit("message", obj);
        } else {
          this._emit("message", obj);
        }
      }
    } catch {
      this._emit("raw", ev.data);
    }
  }

  _flushQueue() {
    if (!this._ws || this._ws.readyState !== WebSocket.OPEN) return;
    while (this._sendQueue.length) {
      const item = this._sendQueue.shift();
      try {
        this._ws.send(item);
      } catch {}
    }
  }

  _startHeartbeat() {
    this._stopHeartbeat();
    if (this._heartbeatMs > 0) {
      this._heartbeatTid = setInterval(() => {
        try {
          if (this._ws && this._ws.readyState === WebSocket.OPEN) {
            this._ws.send('{"type":"ping"}');
          }
        } catch {}
      }, this._heartbeatMs);
    }
  }
  _stopHeartbeat() {
    if (this._heartbeatTid) {
      clearInterval(this._heartbeatTid);
      this._heartbeatTid = null;
    }
  }

  _scheduleReconnect() {
    if (!this._shouldReconnect) return;
    this._attempt += 1;
    const base = 300 * Math.pow(2, this._attempt - 1);
    const jitter = Math.floor(Math.random() * 400);
    const delay = Math.min(10_000, base + jitter);
    dbg.log("ws", "Reconnect scheduled", {
      inMs: delay,
      attempt: this._attempt,
    });
    this._clearReconnect();
    this._reconnectTid = setTimeout(() => this.connect(), delay);
  }
  _clearReconnect() {
    if (this._reconnectTid) {
      clearTimeout(this._reconnectTid);
      this._reconnectTid = null;
    }
  }

  _failInflight(err) {
    if (!this._pending.size) return;
    for (const [, entry] of this._pending) {
      clearTimeout(entry.timer);
      try {
        entry.reject(err);
      } catch {}
    }
    this._pending.clear();
  }
}
</file>

<file path="src/components/editor/wizard_steps/StepPublish.jsx">
// src/components/editor/wizard_steps/StepPublish.jsx
import { createSignal, onMount, Show, createEffect, on } from "solid-js";
import { useApp } from "../../../context/AppContext.jsx";
import Spinner from "../../ui/Spinner.jsx";
import { getSavvaContract } from "../../../blockchain/contracts.js";
import { toHexBytes32 } from "../../../blockchain/utils.js";
import { dbg } from "../../../utils/debug.js";
import { createPublicClient, http } from "viem";

function parseViemError(e) {
  if (e?.shortMessage) {
    return e.shortMessage;
  }
  if (e?.message?.includes('User rejected the request')) {
    return 'User rejected the request.';
  }
  if (e?.name === 'TransactionExecutionError' && e.cause?.shortMessage) {
    return e.cause.shortMessage;
  }
  return e.message;
}

export default function StepPublish(props) {
  const app = useApp();
  const { t } = app;
  const [error, setError] = createSignal(null);
  const [status, setStatus] = createSignal("waiting_signature");
  const [txHash, setTxHash] = createSignal(null);

  createEffect(() => {
    dbg.log("StepPublish:Props Update", {
        publishedData: props.publishedData(),
        postParams: props.postParams()
    });
  });

  const attemptPublish = async () => {
    setError(null);
    setTxHash(null);
    setStatus("waiting_signature");

    try {
      const { postParams, publishedData, editorMode } = props;
      const user = app.authorizedUser();
      const domain = app.selectedDomainName();
      const descriptorCid = publishedData().descriptorCid;
      const guid = postParams().guid;

      dbg.group("StepPublish: Pre-Flight Check");
      dbg.log("User:", user);
      dbg.log("Domain:", domain);
      dbg.log("Descriptor CID:", descriptorCid);
      dbg.log("GUID:", guid);
      dbg.log("Full postParams:", postParams());
      dbg.log("Full publishedData:", publishedData());
      dbg.groupEnd();

      if (!user?.address || !domain || !descriptorCid || !guid) {
        throw new Error("Missing required data for publishing (user, domain, descriptorCid, or guid).");
      }

      let contentType;
      switch (editorMode) {
        case 'new_post':
          contentType = 'post';
          break;
        case 'edit_post':
          contentType = postParams().publishAsNewPost ? 'post' : 'post-edit';
          break;
        case 'new_comment':
          contentType = 'comment';
          break;
        case 'edit_comment':
          contentType = 'comment-edit';
          break;
        default:
          throw new Error(`Unknown editor mode for content type: ${editorMode}`);
      }
      
      dbg.log("StepPublish", "Publishing with params:", { domain, author: user.address, guid, ipfs: descriptorCid, contentType });

      const contract = await getSavvaContract(app, "ContentRegistry", { write: true });
      
      const hash = await contract.write.reg([
        domain,
        user.address,
        guid,
        descriptorCid,
        toHexBytes32(contentType)
      ]);

      setStatus("publishing");
      setTxHash(hash);
      dbg.log("StepPublish", "Transaction sent, hash:", hash);

      const desiredChain = app.desiredChain();
      if (!desiredChain?.rpcUrls?.[0]) {
        throw new Error("RPC URL for the desired chain is not configured.");
      }
      const transport = http(desiredChain.rpcUrls[0]);
      const publicClient = createPublicClient({ chain: desiredChain, transport: transport });

      const receipt = await publicClient.waitForTransactionReceipt({ hash });
      if (receipt.status !== 'success') {
        throw new Error(`Transaction failed with status: ${receipt.status}`);
      }

      dbg.log("StepPublish", "Transaction confirmed:", receipt);
      props.onComplete?.();
    } catch (e) {
      dbg.error("StepPublish", "Publishing failed:", e);
      setError(parseViemError(e));
    }
  };

  onMount(() => {
    setTimeout(attemptPublish, 500);
  });

  return (
    <div class="flex flex-col items-center justify-center h-full text-center p-4">
      <Show when={!error()}
        fallback={
          <>
            <h4 class="font-bold text-red-600">{t("editor.publish.publishing.errorTitle")}</h4>
            <p class="mt-2 text-sm break-all">{error()}</p>
            <div class="mt-4 flex gap-2 justify-center">
              <button onClick={props.onCancel} class="px-4 py-2 rounded border border-[hsl(var(--input))] hover:bg-[hsl(var(--accent))]">
                {t("editor.publish.validation.backToEditor")}
              </button>
              <button onClick={props.onRetry} class="px-4 py-2 rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] hover:opacity-90">
                {t("common.retry")}
              </button>
            </div>
          </>
        }
      >
        <Spinner />
        <Show when={status() === 'waiting_signature'}>
            <p class="mt-2 text-sm font-semibold">{t("editor.publish.publishing.waitSignature")}</p>
            <p class="mt-1 text-xs text-[hsl(var(--muted-foreground))] max-w-sm">
              {t("editor.publish.publishing.waitSignatureHelp")}
            </p>
        </Show>
         <Show when={status() === 'publishing'}>
            <p class="mt-2 text-sm">{t("editor.publish.publishing.waitFinalize")}</p>
        </Show>
        <Show when={txHash()}>
          <div class="mt-4 text-xs text-[hsl(var(--muted-foreground))]">
            <p>{t("editor.publish.publishing.txHash")}:</p>
            <a href={`${app.desiredChain().blockExplorers[0]}/tx/${txHash()}`} target="_blank" class="font-mono break-all underline">
              {txHash()}
            </a>
          </div>
        </Show>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/wizard_steps/StepUploadDescriptor.jsx">
// src/components/editor/wizard_steps/StepUploadDescriptor.jsx
import { createSignal, createEffect, on, Show } from "solid-js";
import { useApp } from "../../../context/AppContext.jsx";
import Spinner from "../../ui/Spinner.jsx";
import { stringify as toYaml } from "yaml";
import { httpBase } from "../../../net/endpoints.js";
import { dbg } from "../../../utils/debug.js";
import { createTextPreview } from "../../../editor/preview-utils.js";
import { isPinningEnabled, getPinningServices } from "../../../ipfs/pinning/storage.js";

export default function StepUploadDescriptor(props) {
  const app = useApp();
  const { t } = app;
  const [error, setError] = createSignal(null);
  const [isUploading, setIsUploading] = createSignal(true);
  const [hasStarted, setHasStarted] = createSignal(false);

  const uploadDescriptor = async (data_cid) => {
    const { postData, postParams, editorMode } = props;
    dbg.log("StepUploadDescriptor:init", "Received postParams:", postParams());

    const contentType = (editorMode === 'new_comment' || editorMode === 'edit_comment') ? 'comment' : 'post';
    const params = postParams();

    const descriptor = {
      savva_spec_version: "2.0",
      data_cid: data_cid,
      locales: {}
    };

    // Explicitly copy required top-level fields from params to the descriptor
    if (params.guid) descriptor.guid = params.guid;
    if (params.parent_savva_cid) descriptor.parent_savva_cid = params.parent_savva_cid;
    if (params.root_savva_cid) descriptor.root_savva_cid = params.root_savva_cid;
    if (params.nsfw) descriptor.nsfw = params.nsfw;
    if (params.fundraiser) descriptor.fundraiser = params.fundraiser;
    if (params.thumbnail) descriptor.thumbnail = params.thumbnail;

    // Conditionally add gateways based on user settings
    if (isPinningEnabled()) {
      const userServices = getPinningServices();
      const userGateways = userServices.map(s => s.gatewayUrl).filter(Boolean);
      if (userGateways.length > 0) {
        descriptor.gateways = userGateways;
      }
    } else {
      const systemGateways = app.info()?.ipfs_gateways || [];
      if (systemGateways.length > 0) {
        descriptor.gateways = systemGateways;
      }
    }
    
    const content = postData();

    for (const lang in content) {
      const data = content[lang];
      const hasTitle = data.title?.trim().length > 0;
      const hasBody = data.body?.trim().length > 0;
      const hasChapters = data.chapters?.some(c => c.body?.trim().length > 0);

      if (!hasTitle && !hasBody && !hasChapters) {
        continue;
      }
      
      const langParams = params.locales?.[lang] || {};
      
      const localeObject = {
        title: data.title || "",
        text_preview: createTextPreview(data.body || "", contentType),
        tags: langParams.tags || [],
        categories: langParams.categories || [],
        data_path: `${lang}/data.md`,
        chapters: []
      };

      if (Array.isArray(data.chapters)) {
        for (let i = 0; i < data.chapters.length; i++) {
          const chapterParams = langParams.chapters?.[i] || {};
          localeObject.chapters.push({
            title: chapterParams.title || `Chapter ${i + 1}`,
            data_path: `${lang}/chapters/${i + 1}.md`
          });
        }
      }
      
      descriptor.locales[lang] = localeObject;
    }
    
    dbg.log("StepUploadDescriptor", "Final descriptor object:", descriptor);

    const yamlStr = toYaml(descriptor);
    const descriptorFile = new File([yamlStr], "info.yaml", { type: 'application/x-yaml' });
    const formData = new FormData();
    formData.append('file', descriptorFile);

    const url = `${httpBase()}store`;
    const response = await fetch(url, {
      method: 'POST',
      body: formData,
      credentials: 'include'
    });

    if (!response.ok) {
      const errText = await response.text();
      throw new Error(`Descriptor upload failed: ${response.status} ${errText}`);
    }

    const result = await response.json();
    if (!result?.cid) {
      throw new Error("API did not return a 'cid' for the uploaded descriptor.");
    }

    return result.cid;
  };

  createEffect(() => {
    const dataCid = props.publishedData().ipfsCid;
    if (dataCid && !hasStarted()) {
      setHasStarted(true);
      
      setTimeout(async () => {
        try {
          const descriptorCid = await uploadDescriptor(dataCid);
          props.onComplete?.(descriptorCid);
        } catch (e) {
          dbg.error("StepUploadDescriptor", "An error occurred:", e);
          setError(e.message);
        } finally {
          setIsUploading(false);
        }
      }, 500);
    }
  });


  return (
    <div class="flex flex-col items-center justify-center h-full">
      <Show when={isUploading()}>
        <Spinner />
        <p class="mt-2 text-sm">{t("editor.publish.uploadingDescriptor")}...</p>
      </Show>
      <Show when={error()}>
        <div class="text-center p-4">
          <h4 class="font-bold text-red-600">{t("editor.publish.descriptor.errorTitle")}</h4>
          <p class="mt-2 text-sm">{error()}</p>
          <button onClick={props.onCancel} class="mt-4 px-4 py-2 rounded border border-[hsl(var(--input))] hover:bg-[hsl(var(--accent))]">
            {t("editor.publish.validation.backToEditor")}
          </button>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/editor/EditorFullPreview.jsx">
// src/components/editor/EditorFullPreview.jsx
import { createMemo, Show, createSignal } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import MarkdownView from "../docs/MarkdownView.jsx";
import UserCard from "../ui/UserCard.jsx";
import PostTags from "../post/PostTags.jsx";
import IpfsImage from "../ui/IpfsImage.jsx";
import UnknownUserIcon from "../ui/icons/UnknownUserIcon.jsx";
import { rehypeResolveDraftUrls } from "../../docs/rehype-resolve-draft-urls.js";
import ChapterSelector from "../post/ChapterSelector.jsx";
import ChapterPager from "../post/ChapterPager.jsx";
import LangSelector from "../ui/LangSelector.jsx";

export default function EditorFullPreview(props) {
  const app = useApp();
  const { t } = app;
  const [selectedChapterIndex, setSelectedChapterIndex] = createSignal(0);
  const [previewLang, setPreviewLang] = createSignal(props.activeLang);

  const author = () => app.authorizedUser();
  const lang = () => previewLang();

  const title = createMemo(() => props.postData?.[lang()]?.title || "");

  const chapterList = createMemo(() => {
    const prologue = { title: t("post.chapters.prologue") };
    const currentChapters = props.chapters?.filter(c => props.postData[lang()]?.chapters.includes(c)) || [];
    return [prologue, ...(props.chapters || [])];
  });

  const currentContent = createMemo(() => {
    const data = props.postData?.[lang()];
    if (!data) return "";
    const index = selectedChapterIndex();
    if (index === 0) {
      return data.body || "";
    }
    return data.chapters?.[index - 1]?.body || "";
  });

  const postForTags = createMemo(() => ({
    savva_content: {
      locales: {
        [lang()]: {
          categories: props.postParams?.locales?.[lang()]?.categories || [],
          tags: props.postParams?.locales?.[lang()]?.tags || [],
        }
      }
    }
  }));

  const markdownPlugins = createMemo(() => [[rehypeResolveDraftUrls, { baseDir: props.baseDir }]]);

  return (
    <div class="max-w-5xl mx-auto space-y-4">
      <div class="p-3 pr-4 rounded-lg flex items-center justify-between" style={{ background: "var(--gradient)" }}>
        <button onClick={props.onBack} class="ml-5 px-4 py-2 rounded bg-[hsl(var(--secondary))] text-[hsl(var(--secondary-foreground))] hover:opacity-90">
          {t("editor.fullPreview.back")}
        </button>
        <div class="text-center text-[hsl(var(--card))]">
          <h2 class="font-bold">{t("editor.fullPreview.title")}</h2>
          <p class="text-xs opacity-90">{t("editor.fullPreview.help")}</p>
        </div>
        <button 
          onClick={props.onContinue}
          class="mr-5 px-4 py-2 rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] font-semibold hover:opacity-90"
        >
          {t("editor.fullPreview.publish")}
        </button>
      </div>
      
      <div class="bg-[hsl(var(--background))] p-4 rounded-lg border border-[hsl(var(--border))]">
        <article class="space-y-4">
          <header class="flex justify-between items-start gap-4">
            <div class="flex-1 min-w-0 space-y-3">
              <h1 class="text-2xl lg:text-3xl font-bold break-words">{title()}</h1>
              <UserCard author={author()} />
              <PostTags postData={postForTags()} />
            </div>
            <div class="w-48 flex-shrink-0 space-y-2">
              <Show when={props.thumbnailUrl}>
                <img src={props.thumbnailUrl} alt="Thumbnail preview" class="w-full aspect-video rounded-md object-cover border border-[hsl(var(--border))]" />
              </Show>
              <Show when={(props.filledLangs || []).length > 1}>
                <div class="flex justify-center">
                    <LangSelector
                        codes={props.filledLangs}
                        value={previewLang()}
                        onChange={setPreviewLang}
                    />
                </div>
              </Show>
            </div>
          </header>

          <div class="pt-4 border-t border-[hsl(var(--border))]">
              <Show when={(chapterList()?.length || 0) > 1}>
                  <div class="flex justify-end mb-4">
                  <ChapterSelector 
                      chapters={chapterList()} 
                      selectedIndex={selectedChapterIndex()} 
                      onSelect={setSelectedChapterIndex}
                  />
                  </div>
              </Show>
              <MarkdownView markdown={currentContent()} rehypePlugins={markdownPlugins()} />
              <Show when={(chapterList()?.length || 0) > 1}>
                  <ChapterPager 
                      chapters={chapterList()}
                      currentIndex={selectedChapterIndex()}
                      onSelect={setSelectedChapterIndex}
                  />
              </Show>
          </div>
        </article>
      </div>
    </div>
  );
}
</file>

<file path="src/components/editor/PostSubmissionWizard.jsx">
// src/components/editor/wizard_steps/PostSubmissionWizard.jsx
import { createSignal, createMemo, Show, For, Switch, Match, createEffect, on } from "solid-js";
import { Dynamic } from "solid-js/web";
import { useApp } from "../../context/AppContext.jsx";
import StepValidate from "./wizard_steps/StepValidate.jsx";
import StepCheckRights from "./wizard_steps/StepCheckRights.jsx";
import StepUploadIPFS from "./wizard_steps/StepUploadIPFS.jsx";
import StepUploadDescriptor from "./wizard_steps/StepUploadDescriptor.jsx";
import StepPublish from "./wizard_steps/StepPublish.jsx";
import { dbg } from "../../utils/debug.js";

const STEPS = [
  { id: "validate",      title: "editor.publish.steps.validate",      help: "editor.publish.steps.validate.help",      component: StepValidate },
  { id: "check_rights",  title: "editor.publish.steps.check_rights",  help: "editor.publish.steps.check_rights.help",  component: StepCheckRights },
  { id: "ipfs",          title: "editor.publish.steps.ipfs",          help: "editor.publish.steps.ipfs.help",          component: StepUploadIPFS },
  { id: "ipfs_publish",  title: "editor.publish.steps.ipfs_publish",  help: "editor.publish.steps.ipfs_publish.help",  component: StepUploadDescriptor },
  { id: "publish",       title: "editor.publish.steps.publish",       help: "editor.publish.steps.publish.help",       component: StepPublish },
];

function CheckmarkIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-5 h-5"} fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="20 6 9 17 4 12"></polyline>
    </svg>
  );
}

function StepIcon(props) {
  return (
    <div class={`w-8 h-8 rounded-full flex items-center justify-center border-2 ${props.class}`}>
      <Show when={props.status === "completed"}><CheckmarkIcon class="text-white" /></Show>
      <Show when={props.status === "active"}><div class="w-4 h-4 rounded-full bg-blue-500" /></Show>
      <Show when={props.status === "pending"}><div class="w-2 h-2 rounded-full bg-gray-400" /></Show>
    </div>
  );
}

export default function PostSubmissionWizard(props) {
  const { t } = useApp();
  const [currentStepIndex, setCurrentStepIndex] = createSignal(0);
  const [publishedData, setPublishedData] = createSignal({});

  createEffect(on(() => props.isOpen, (isOpen) => {
    if (isOpen) {
      setCurrentStepIndex(0);
      setPublishedData({});
    }
  }));

  const activeComponent = createMemo(() => STEPS[currentStepIndex()]?.component);

  const handleNextStep = (stepResult) => {
    const currentStep = STEPS[currentStepIndex()];
    dbg.log("Wizard:handleNextStep", `Completed step '${currentStep.id}'. Received result:`, stepResult);

    if (currentStep.id === 'ipfs') {
      setPublishedData(prev => ({ ...prev, ipfsCid: stepResult }));
    } else if (currentStep.id === 'ipfs_publish') {
      setPublishedData(prev => ({ ...prev, descriptorCid: stepResult }));
    }

    if (currentStepIndex() < STEPS.length - 1) {
      setCurrentStepIndex(currentStepIndex() + 1);
    } else {
      props.onSuccess?.();
    }
  };
  
  const handleRetry = () => {
    setCurrentStepIndex(0);
    setPublishedData({});
  };

  const getStepStatus = (index) => {
    if (index < currentStepIndex()) return "completed";
    if (index === currentStepIndex()) return "active";
    return "pending";
  };

  const handleValidationBack = () => {
    props.onClose?.();
  };

  return (
    <Show when={props.isOpen}>
      <div class="fixed inset-0 z-50 flex items-center justify-center">
        <div class="absolute inset-0 bg-black/40" />
        <div class="relative themed-dialog rounded-lg shadow-lg w-full max-w-3xl p-4 bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))]">
          <header class="flex items-center justify-between pb-3 border-b border-[hsl(var(--border))]">
            <h3 class="text-lg font-semibold">{t("editor.publish.title")}</h3>
            <button class="px-3 py-1 rounded hover:bg-[hsl(var(--accent))]" onClick={props.onClose}>
              {t("common.cancel")}
            </button>
          </header>

          <div class="flex gap-6 py-4">
            <div class="w-48 flex-shrink-0">
              <For each={STEPS}>
                {(step, index) => (
                  <div class="flex items-start">
                    <div class="flex flex-col items-center mr-4">
                      <StepIcon status={getStepStatus(index())} class={getStepStatus(index()) === "completed" ? "bg-green-500 border-green-500" : "border-gray-400"} />
                      <Show when={index() < STEPS.length - 1}>
                        <div class="w-px h-8 bg-gray-300" />
                      </Show>
                    </div>
                    <div>
                      <h4 class="font-semibold text-sm">{t(step.title)}</h4>
                      <p class="text-xs text-[hsl(var(--muted-foreground))]">{t(step.help)}</p>
                    </div>
                  </div>
                )}
              </For>
            </div>

            <div class="flex-1 min-w-0 min-h-[20rem]">
              <Switch>
                <Match when={activeComponent()}>
                  <Dynamic
                    component={activeComponent()}
                    postData={props.postData}
                    postParams={props.postParams}
                    publishedData={publishedData}
                    onComplete={handleNextStep}
                    onCancel={handleValidationBack}
                    onRetry={handleRetry}
                    editorMode={props.editorMode}
                  />
                </Match>
              </Switch>
            </div>
          </div>
        </div>
      </div>
    </Show>
  );
}
</file>

<file path="src/components/feed/ContentFeed.jsx">
// src/components/feed/ContentFeed.jsx
import { createSignal, onCleanup, onMount, For, Show, createEffect, on } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import PostListView from "./PostListView.jsx";
import { dbg } from "../../utils/debug.js";

export default function ContentFeed(props) {
  const { t } = useApp();
  const [items, setItems] = createSignal([]);
  const [page, setPage] = createSignal(0);
  const [hasMore, setHasMore] = createSignal(true);
  const [loading, setLoading] = createSignal(false);
  const [hasLoadedOnce, setHasLoadedOnce] = createSignal(false);

  async function loadMore() {
    if (loading() || !hasMore()) return;
    setLoading(true);
    try {
      const nextPage = page() + 1;
      dbg.log("ContentFeed", "loadMore → page", nextPage);
      const chunk = (await props.fetchPage?.(nextPage, props.pageSize || 12)) ?? [];
      dbg.log("ContentFeed", "page result length", chunk.length);
      if (!chunk.length) setHasMore(false);
      
      setItems((prev) => {
        const next = prev.concat(chunk);
        props.onItemsChange?.(next);
        return next;
      });

      setPage(nextPage);
    } finally {
      setLoading(false);
    }
  }

  createEffect(() => {
    // This effect triggers the very first load once the component is activated.
    if (props.isActivated && !hasLoadedOnce()) {
      dbg.log('ContentFeed', 'Component activated. Firing initial loadMore().');
      setHasLoadedOnce(true);
      loadMore();
    }
  });

  onMount(() => {
    const handleScroll = () => {
      // Only load more content if the feed has been activated.
      if (!props.isActivated) return;
      const scrollThreshold = 600;
      const scrolledToBottom = window.innerHeight + window.scrollY >= document.documentElement.scrollHeight - scrollThreshold;
      if (scrolledToBottom) loadMore();
    };
    let timeoutId = null;
    const throttledHandleScroll = () => {
      if (timeoutId === null) {
        timeoutId = setTimeout(() => { handleScroll(); timeoutId = null; }, 200);
      }
    };
    window.addEventListener('scroll', throttledHandleScroll, { passive: true });
    onCleanup(() => {
      window.removeEventListener('scroll', throttledHandleScroll);
      if (timeoutId) clearTimeout(timeoutId);
    });
  });

  createEffect(on(() => props.resetOn, () => {
    setItems([]);
    props.onItemsChange?.([]);
    setPage(0);
    setHasMore(true);
    setLoading(false);
    setHasLoadedOnce(false); // Reset the load trigger

    // If the component is already active when a reset occurs, load immediately.
    // Otherwise, the activation effect will handle the load.
    if (props.isActivated) {
      queueMicrotask(() => {
          setHasLoadedOnce(true);
          loadMore();
      });
    }
  }, { defer: true }));

  return (
    <div class="w-full">
      <PostListView
        items={items()}
        mode={props.mode}
        isRailVisible={props.isRailVisible}
      />
      <Show when={loading()}>
        <div class="py-4 text-sm text-[hsl(var(--muted-foreground))] text-center">{t("common.loading")}</div>
      </Show>
    </div>
  );
}
</file>

<file path="src/i18n/useI18n.js">
// src/i18n/useI18n.js
import { createSignal } from "solid-js";
import en from "./en";
import ru from "./ru";
import sr from "./sr";
import ua from "./ua";
import fr from "./fr";
import { dbg } from "../utils/debug";

// Used by the Lang selector for labels
export const LANG_INFO = {
  en: { code: "EN", name: "English" },
  ru: { code: "RU", name: "Русский" },
  fr: { code: "FR", name: "Français" },
  ua: { code: "UA", name: "Українська" },
  sr: { code: "SR", name: "Српски" },
};

// All built-in application dictionaries. The keys must match LANG_INFO.
const APP_DICTS = { en, ru, fr, ua, sr };

const DEFAULT_LANG = "en";
const LANG_KEY = "lang";
const SHOW_KEYS_KEY = "i18n_show_keys";

let i18nSingleton;

// !!!!! special comment to include the keys generated automatically
// !!!!! Do not edit this section manually
// t("tabs.title.leaders") t("tabs.title.actual") t("tabs.title.comments")
// t("tabs.title.new") t("tabs.title.for-you")

function normalizeLang(code) {
  const s = String(code || "").trim().toLowerCase();
  const [base] = s.split(/[-_]/); // "en-US" -> "en"
  return base || DEFAULT_LANG;
}

export function useI18n() {
  if (!i18nSingleton) {
    const [domainDicts, setDomainDicts] = createSignal({});
    const [domainLangCodes, setDomainLangCodes] = createSignal([]);

    const resolveKey = (lang, key) => {
      const d = domainDicts();
      const fromDomain = d[lang]?.[key];
      if (fromDomain != null) return fromDomain;

      const fromApp = APP_DICTS[lang]?.[key];
      if (fromApp != null) return fromApp;

      if (APP_DICTS[DEFAULT_LANG]?.[key] != null) return APP_DICTS[DEFAULT_LANG][key];
      return `[${key}]`;
    }

    const readInitialLang = () => {
      try {
        const v = localStorage.getItem(LANG_KEY);
        return normalizeLang(v || DEFAULT_LANG);
      } catch {
        return DEFAULT_LANG;
      }
    };
    const readInitialShowKeys = () => {
      try {
        return localStorage.getItem(SHOW_KEYS_KEY) === "1";
      } catch {
        return false;
      }
    };

    const [lang, setLangSignal] = createSignal(readInitialLang());
    const [showKeys, setShowKeysSignal] = createSignal(readInitialShowKeys());

    function setLang(next) {
      const v = normalizeLang(next);
      const current = lang();

      dbg.log("useI18n", `setLang called. Request: '${next}', Normalized: '${v}', Current: '${current}'.`);
      if (current === v) {
        dbg.log("useI18n", "-> SKIPPING: Language is already set to this value.");
        return;
      }

      setLangSignal(v);
      try { localStorage.setItem(LANG_KEY, v); } catch {}
      if (typeof document !== "undefined") {
        document.documentElement.setAttribute("lang", v);
      }
      if (typeof window !== "undefined") {
        window.dispatchEvent(new CustomEvent("savva:lang", { detail: { lang: v } }));
      }
    }

    function setShowKeys(on) {
      const v = !!on;
      setShowKeysSignal(v);
      try { localStorage.setItem(SHOW_KEYS_KEY, v ? "1" : "0"); } catch {}
    }

    const t = (key, params) => {
      let base = resolveKey(lang(), key);
      if (params) {
        for (const [paramKey, paramValue] of Object.entries(params)) {
          base = base.replace(`{${paramKey}}`, String(paramValue));
        }
      }
      return showKeys() ? `${base} [${key}]` : base;
    };

    if (typeof window !== "undefined") {
      window.addEventListener("storage", (e) => {
        if (e.key === LANG_KEY && e.newValue) setLangSignal(normalizeLang(e.newValue));
        if (e.key === SHOW_KEYS_KEY) setShowKeysSignal(e.newValue === "1");
      });
    }

    const available = () => {
      const domainCodes = domainLangCodes();
      if (domainCodes.length > 0) return domainCodes;
      return Object.keys(APP_DICTS);
    };

    i18nSingleton = {
      t,
      lang,
      setLang,
      showKeys,
      setShowKeys,
      available,
      setDomainDictionaries: (d) => setDomainDicts(d || {}),
      setDomainLangCodes: (codes) => setDomainLangCodes(codes || []),
    };
  }
  return i18nSingleton;
}
</file>

<file path="src/components/feed/PostInfo.jsx">
// src/components/feed/PostInfo.jsx
import { Show, createMemo, createSignal, createEffect, on } from "solid-js";
import { formatUnits } from "viem";
import { useApp } from "../../context/AppContext.jsx";
import SavvaTokenIcon from "../ui/icons/SavvaTokenIcon.jsx";
import PostTime from "../ui/PostTime.jsx";
import PostReactions from "../ui/PostReactions.jsx";
import ReactionInput from "../post/ReactionInput.jsx";

function PostComments(props) {
  const [isAnimating, setIsAnimating] = createSignal(false);
  const sourceCount = createMemo(() => props.item?._raw?.total_childs || props.item?.total_childs || 0);
  const [displayCount, setDisplayCount] = createSignal(sourceCount());

  createEffect(on(sourceCount, (newCount, prevCount) => {
    if (prevCount === undefined) {
      setDisplayCount(newCount);
      return;
    }
    setDisplayCount(prevCount);
    setIsAnimating(true);
    setTimeout(() => setDisplayCount(newCount), 200);
    setTimeout(() => setIsAnimating(false), 400);
  }, { defer: true }));

  return (
    <Show when={displayCount() > 0 || isAnimating()}>
      <div 
        class="flex items-center gap-1 text-xs"
        classList={{ "default-animation": isAnimating() }}
      >
        <span>💬</span>
        <span>{displayCount()}</span>
      </div>
    </Show>
  );
}

function PostRewards(props) {
  const amount = createMemo(() => {
    const rawAmount = props.item?._raw?.fund?.total_author_share || props.item?.fund?.total_author_share;
    if (!rawAmount) return 0;
    const formatted = formatUnits(BigInt(rawAmount), 18);
    return parseFloat(formatted);
  });

  const localizedAmount = createMemo(() => {
    const currentLang = props.lang();
    return amount().toLocaleString(currentLang, {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    });
  });

  return (
    <Show when={amount() > 0}>
      <div class="flex items-center gap-1 text-xs">
        <span>{localizedAmount()}</span>
        <SavvaTokenIcon class="w-3.5 h-3.5" />
      </div>
    </Show>
  );
}

export default function PostInfo(props) {
  const app = useApp();
  const { lang } = app;
  const isListMode = () => props.mode === 'list';
  const postData = createMemo(() => props.item?._raw || props.item || {});

  return (
    <div class={`flex w-full items-center justify-between ${isListMode() ? 'gap-2' : 'gap-4'} ${props.hideTopBorder ? '' : 'pt-0.5 border-t border-[hsl(var(--border))]'}`}>
      <div class="flex items-center gap-2">
        <PostTime 
          timestamp={postData().effective_time} 
          format={props.timeFormat || "short"} 
        />
        <PostReactions item={props.item} />
        <PostRewards item={props.item} lang={lang} />
        <PostComments item={props.item} />
      </div>
      
      <Show when={!props.hideActions}>
        <div class="flex-shrink-0">
          <Show when={app.authorizedUser()}>
            <ReactionInput post={props.item} />
          </Show>
        </div>
      </Show>
    </div>
  );
}
</file>

<file path="src/components/post/CommentCard.jsx">
// src/components/post/CommentCard.jsx
import { For, Show, createMemo, createSignal, createResource, Switch, Match } from "solid-js";
import { useApp } from "../../context/AppContext";
import PostInfo from "../feed/PostInfo";
import UserCard from "../ui/UserCard";
import MarkdownView from "../docs/MarkdownView";
import { ipfs } from "../../ipfs";
import { getPostContentBaseCid, getPostDescriptorPath } from "../../ipfs/utils";
import Spinner from "../ui/Spinner";
import ContextMenu from "../ui/ContextMenu.jsx";
import { getPostAdminItems } from "../../ui/contextMenuBuilder.js";
import { navigate } from "../../routing/hashRouter.js";
import { rehypeRewriteLinks } from "../../docs/rehype-rewrite-links.js";
import { preparePostForEditing } from "../../editor/postImporter.js";
import { pushErrorToast } from "../../ui/toast.js";
import ConfirmModal from "../ui/ConfirmModal.jsx";
import { EditIcon, TrashIcon } from "../ui/icons/ActionIcons.jsx";
import { useDeleteAction } from "../../hooks/useDeleteAction.js";
import { parse } from "yaml";
import ReactionInput from "../post/ReactionInput.jsx";

async function fetchFullContent(params) {
  const { app, comment, lang } = params;
  if (!comment || !lang) return "";

  try {
    const descriptorPath = getPostDescriptorPath(comment);
    if (!descriptorPath) {
      return comment.savva_content?.locales?.[lang]?.text_preview || "";
    }

    const { res: descriptorRes } = await ipfs.fetchBest(app, descriptorPath, { postGateways: comment.gateways });
    const descriptorText = await descriptorRes.text();
    const descriptor = parse(descriptorText);
    if (!descriptor) throw new Error("Could not parse comment descriptor.");

    const dataCidForContent = getPostContentBaseCid(comment);
    const localizedDescriptor = descriptor.locales?.[lang] || descriptor.locales?.en || descriptor.locales?.[Object.keys(descriptor.locales)[0]];
    const dataPath = localizedDescriptor?.data_path;

    if (!dataCidForContent || !dataPath) {
      return localizedDescriptor?.text_preview || "";
    }

    const fullIpfsPath = `${dataCidForContent}/${dataPath}`;
    const postGateways = descriptor?.gateways || [];
    const { res: contentRes } = await ipfs.fetchBest(app, fullIpfsPath, { postGateways });
    return await contentRes.text();
  } catch (e) {
    console.error("Failed to fetch full comment content:", e);
    return `Error: Could not load full content.`;
  }
}

export default function CommentCard(props) {
  const app = useApp();
  const { t } = app;
  const level = () => props.level || 0;
  
  const [isExpanded, setIsExpanded] = createSignal(false);
  const [isHovered, setIsHovered] = createSignal(false);
  const [isPreparing, setIsPreparing] = createSignal(false);
  
  // This makes the comment data reactive to global updates
  const comment = createMemo(() => {
    const baseComment = props.comment;
    const update = app.postUpdate();

    if (update && update.cid === baseComment.savva_cid) {
        let updatedRaw = { ...baseComment };
        
        if (update.type === 'reactionsChanged') {
            updatedRaw.reactions = update.data.reactions;
            if (app.authorizedUser()?.address?.toLowerCase() === update.data?.user?.toLowerCase()) {
                updatedRaw.my_reaction = update.data.reaction;
            }
        }
        
        return updatedRaw;
    }
    
    return baseComment;
  });

  const { showConfirm, openConfirm, closeConfirm, confirmDelete, modalProps } = useDeleteAction(comment);

  const isAuthor = createMemo(() => {
    const userAddr = app.authorizedUser()?.address?.toLowerCase();
    const authorAddr = comment()?.author?.address?.toLowerCase();
    return !!userAddr && userAddr === authorAddr;
  });

  const localizedPreview = createMemo(() => {
    const locales = comment().savva_content?.locales;
    if (!locales) return "";
    const lang = app.lang();
    if (locales[lang]?.text_preview) return locales[lang].text_preview;
    if (locales.en?.text_preview) return locales.en.text_preview;
    const firstKey = Object.keys(locales)[0];
    return firstKey ? locales[firstKey].text_preview : "";
  });

  const [fullContent] = createResource(
    () => ({
      shouldFetch: isExpanded(),
      app: app,
      comment: comment(),
      lang: app.lang()
    }),
    async (params) => {
      if (!params.shouldFetch) return null;
      return fetchFullContent(params);
    }
  );

  const contextMenuItems = createMemo(() => {
    if (!comment()) return [];
    return getPostAdminItems(comment(), t);
  });

  const needsTruncation = createMemo(() => {
    const preview = localizedPreview();
    return preview.endsWith("...");
  });

  const ipfsBaseUrl = createMemo(() => {
    const c = comment();
    if (!c) return "";
    const dataCid = getPostContentBaseCid(c);
    if (!dataCid) return "";
    
    let bestGateway;
    if (app.localIpfsEnabled() && app.localIpfsGateway()) {
      bestGateway = app.localIpfsGateway();
    } else if (Array.isArray(c.gateways) && c.gateways.length > 0) {
      bestGateway = c.gateways[0];
    } else {
      bestGateway = app.remoteIpfsGateways()[0] || "https://ipfs.io/";
    }
    
    const gatewayUrl = bestGateway.endsWith("/") ? bestGateway : `${bestGateway}/`;
    return `${gatewayUrl}ipfs/${dataCid}`;
  });

  const markdownPlugins = createMemo(() => [
    [rehypeRewriteLinks, { base: ipfsBaseUrl() }]
  ]);

  const handleReply = (e) => {
    e.stopPropagation();
    const commentCid = comment()?.savva_cid;
    if (commentCid) {
      navigate(`/editor/new-comment/${commentCid}`);
    }
  };

  const handleEdit = async (e) => {
    e.stopPropagation();
    setIsPreparing(true);
    try {
      await preparePostForEditing(comment(), app);
      navigate(`/editor/comment/${comment().savva_cid}`);
    } catch (err) {
      pushErrorToast(err, { context: "Failed to prepare comment for editing." });
    } finally {
      setIsPreparing(false);
    }
  };

  return (
    <div
      class="relative flex flex-col"
      style={{ "padding-left": level() > 0 ? "1.5rem" : "0" }}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <div class="p-3 rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))]">
        <div class="mb-2">
          <UserCard author={comment().author} compact={false} />
        </div>
        
        <div class="text-sm prose prose-sm max-w-none">
          <Switch>
            <Match when={isExpanded() && fullContent.loading}>
              <div class="flex items-center justify-center h-24">
                <Spinner />
              </div>
            </Match>
            <Match when={isExpanded() && fullContent()}>
              <MarkdownView markdown={fullContent()} rehypePlugins={markdownPlugins()} />
            </Match>
            <Match when={!isExpanded()}>
              <MarkdownView markdown={localizedPreview()} rehypePlugins={markdownPlugins()} />
            </Match>
          </Switch>
        </div>

        <div class="mt-2 flex items-center justify-between">
          <PostInfo item={{ _raw: comment() }} hideTopBorder={true} timeFormat="long" hideActions={true} />
          <div class="flex items-center gap-2 text-xs font-semibold">
            <Show when={app.authorizedUser()}>
              <ReactionInput post={{_raw: comment()}} />
            </Show>
            <Show when={isAuthor()}>
              <button class="p-1" onClick={handleEdit} disabled={isPreparing()} title="Edit Comment">
                <Show when={isPreparing()} fallback={<EditIcon class="w-4 h-4 text-[hsl(var(--muted-foreground))] hover:text-[hsl(var(--primary))]" />}>
                  <Spinner class="w-4 h-4" />
                </Show>
              </button>
              <button
                  class="p-1"
                  onClick={openConfirm}
                  disabled={modalProps().isDeleting}
                  title="Delete Comment"
                >
                <TrashIcon class="w-4 h-4 text-[hsl(var(--muted-foreground))] hover:text-[hsl(var(--destructive))]" />
              </button>
            </Show>
            <Show when={needsTruncation() || isExpanded()}>
              <button class="hover:underline" onClick={() => setIsExpanded(!isExpanded())}>
                {isExpanded() ? t("comment.showLess") : t("comment.showMore")}
              </button>
            </Show>
            <button class="hover:underline" onClick={handleReply}>{t("comment.reply")}</button>
          </div>
        </div>
      </div>
      
      <Show when={app.authorizedUser()?.isAdmin && isHovered() && contextMenuItems().length > 0}>
        <div class="context-menu-container">
          <ContextMenu items={contextMenuItems()} />
        </div>
      </Show>
      
      <Show when={comment().children?.length > 0}>
        <div class="mt-3 space-y-3 border-l-2 border-[hsl(var(--border))]">
          <For each={comment().children}>
            {(reply) => <CommentCard comment={reply} level={level() + 1} />}
          </For>
        </div>
      </Show>

      <ConfirmModal
        isOpen={showConfirm()}
        onClose={closeConfirm}
        onConfirm={confirmDelete}
        {...modalProps()}
      />
    </div>
  );
}
</file>

<file path="src/components/settings/LocalIpfsSection.jsx">
// src/components/settings/LocalIpfsSection.jsx
import { createSignal, Show, For } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { fetchWithTimeout } from "../../utils/net.js";

export default function LocalIpfsSection() {
  const app = useApp();
  const { t } = app;

  const [testing, setTesting] = createSignal(false);
  const [apiUrl, setApiUrl] = createSignal(app.localIpfsApiUrl() || "http://127.0.0.1:5001");

  const [diagRunning, setDiagRunning] = createSignal(false);
  const [diagResults, setDiagResults] = createSignal(null);

  async function runDiagnostics() {
    setDiagRunning(true);
    setDiagResults([]);
    const results = [];
    
    const localApi = apiUrl().trim().replace(/\/+$/, "");
    const localGateway = localApi.replace(/:\d+$/, ":8080");
    const currentOrigin = window.location.origin;

    // Step 1: Check basic API liveness and fetch config
    let config = null;
    try {
      const res = await fetchWithTimeout(`${localApi}/api/v0/config/show`, { method: "POST" });
      if (!res.ok) throw new Error(`API responded with status ${res.status}`);
      config = await res.json();
      results.push({ name: t("ipfs.diag.liveness.name"), status: "ok", details: t("ipfs.diag.liveness.ok") });
    } catch (err) {
      const originsJson = JSON.stringify([currentOrigin]);
      const fixCommand = 
`# 1. ${t("ipfs.diag.fix.daemon")}
ipfs daemon

# 2. ${t("ipfs.diag.fix.browser")}

# 3. ${t("ipfs.diag.fix.cors")}
ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '${originsJson}'`;

      results.push({ name: t("ipfs.diag.liveness.name"), status: "error", details: t("ipfs.diag.liveness.error"), fixCommand: fixCommand });
      setDiagResults(results);
      setDiagRunning(false);
      return;
    }
    setDiagResults([...results]);

    // Step 2: Analyze Gateway CORS Configuration
    const gatewayOrigins = config?.Gateway?.HTTPHeaders?.["Access-Control-Allow-Origin"] || [];
    if (gatewayOrigins.includes(currentOrigin) || gatewayOrigins.includes("*")) {
      results.push({ name: t("ipfs.diag.cors.name"), status: "ok", details: t("ipfs.diag.cors.ok") });
    } else {
      const newOriginsList = [...new Set([currentOrigin, ...gatewayOrigins])];
      const fixCommand = `ipfs config --json Gateway.HTTPHeaders.Access-Control-Allow-Origin '${JSON.stringify(newOriginsList)}'`;
      results.push({
        name: t("ipfs.diag.cors.name"),
        status: "error",
        details: t("ipfs.diag.cors.error"),
        fixCommand: fixCommand
      });
    }
    
    // Step 3: Final Live Gateway Fetch Test
    const testCID = app.info()?.savva_contracts?.Config?.abi_cid;
    if (testCID) {
      try {
        const testUrl = `${localGateway}/ipfs/${testCID}`;
        await fetchWithTimeout(testUrl);
        results.push({ name: t("ipfs.diag.fetch.name"), status: "ok", details: t("ipfs.diag.fetch.ok") });
      } catch (err) {
        // MODIFICATION START
        const singleOriginJson = JSON.stringify([currentOrigin]);
        const wildcardOriginJson = JSON.stringify(['*']);

        const fixCommand = 
`# ${t("ipfs.diag.fix.gatewayTitle")}

# ${t("ipfs.diag.fix.gatewaySingleOrigin")}
ipfs config --json Gateway.HTTPHeaders.Access-Control-Allow-Origin '${singleOriginJson}'

# --- OR ---

# ${t("ipfs.diag.fix.gatewayWildcard")}
ipfs config --json Gateway.HTTPHeaders.Access-Control-Allow-Origin '${wildcardOriginJson}'
`;

        results.push({
          name: t("ipfs.diag.fetch.name"),
          status: "error",
          details: t("ipfs.diag.fetch.errorFirewall"),
          fixCommand: fixCommand
        });
        // MODIFICATION END
      }
    } else {
      results.push({ name: t("ipfs.diag.fetch.name"), status: "warn", details: t("ipfs.diag.fetch.warnSkipped") });
    }

    setDiagResults(results);
    setDiagRunning(false);
  }

  async function onEnableLocal() {
    setTesting(true);
    try {
      await app.enableLocalIpfs(apiUrl().trim());
    } finally {
      setTesting(false);
    }
  }

  const statusColorClass = (status) => {
    if (status === 'ok') return 'text-emerald-600';
    if (status === 'error') return 'text-red-600';
    return 'text-amber-500'; // for 'warn'
  };

  return (
    <section class="bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] rounded-lg shadow p-4 space-y-3">
        <h3 class="text-lg font-medium">{t("settings.localIpfs.title")}</h3>
        <label class="flex items-center gap-2">
            <input type="checkbox" checked={app.localIpfsEnabled()} onInput={(e) => {
                const checked = e.currentTarget.checked;
                if (checked) { onEnableLocal(); } else { app.disableLocalIpfs(); }
            }}/>
            <span>{t("settings.localIpfs.enableCheckbox")}</span>
        </label>
        <div class="grid grid-cols-1 md:grid-cols-[minmax(0,1fr)_auto] gap-2 md:items-end">
            <label class="block">
                <span class="text-sm text-[hsl(var(--muted-foreground))]">{t("settings.localIpfs.apiUrl.label")}</span>
                <input class="mt-1 w-full px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
                    value={apiUrl()}
                    onInput={(e) => {
                        const val = e.currentTarget.value;
                        setApiUrl(val);
                        app.setLocalIpfsApiUrl?.(val);
                    }}
                    placeholder="http://127.0.0.1:5001" spellcheck={false}/>
            </label>
            <div class="flex md:self-end">
                <Show when={!app.localIpfsEnabled()}
                    fallback={<button class="h-10 px-3 rounded bg-[hsl(var(--destructive))] text-[hsl(var(--destructive-foreground))] hover:opacity-90" onClick={()=> app.disableLocalIpfs()}>{t("settings.localIpfs.disable")}</button>}>
                    <button class="h-10 px-3 rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] hover:opacity-90 disabled:opacity-60" onClick={onEnableLocal} disabled={testing()} title={t("settings.localIpfs.testEnable")}>
                        {testing() ? t("common.checking") : t("settings.localIpfs.testEnable")}
                    </button>
                </Show>
            </div>
        </div>
        <div class="text-sm text-[hsl(var(--muted-foreground))]">
            {t("settings.localIpfs.status.label")}:{" "}
            <span class={app.localIpfsStatus()==='ok' ? "text-[hsl(var(--primary))]" : app.localIpfsStatus()==='down' ? "text-[hsl(var(--destructive))]" : "opacity-70"}>
                {app.localIpfsStatus()}
            </span>
            <Show when={app.localIpfsEnabled() && app.localIpfsGateway()}>
                <span class="ml-2 opacity-70">• {t("settings.localIpfs.gateway.label")}: {app.localIpfsGateway()}</span>
            </Show>
        </div>

        <Show when={app.localIpfsEnabled()}>
            <div class="pt-2 border-t border-[hsl(var(--border))]">
                <div class="flex items-center justify-between">
                    <h4 class="font-medium">{t("ipfs.diag.title")}</h4>
                    <button class="h-9 px-3 rounded-md border border-[hsl(var(--border))] text-sm hover:bg-[hsl(var(--accent))]"
                        onClick={runDiagnostics}
                        disabled={diagRunning()}>
                        {diagRunning() ? t("common.loading") : t("ipfs.diag.run")}
                    </button>
                </div>
                <Show when={diagResults() && diagResults().length > 0}>
                    <div class="mt-2 space-y-2 text-xs">
                        <For each={diagResults()}>
                            {(result) => (
                                <div class="p-2 rounded bg-[hsl(var(--muted))]">
                                    <div class="flex items-center">
                                        <span class={`font-bold ${statusColorClass(result.status)}`}>
                                            {result.status.toUpperCase()}:
                                        </span>
                                        <span class="font-semibold ml-2">{result.name}</span>
                                    </div>
                                    <p class="mt-1 text-[hsl(var(--muted-foreground))]">{result.details}</p>
                                    <Show when={result.fixCommand}>
                                        <p class="mt-2 font-medium">{t("ipfs.diag.fix.title")}</p>
                                        <pre class="mt-1 p-2 rounded bg-[hsl(var(--background))] text-[hsl(var(--foreground))] font-mono text-[11px] whitespace-pre-wrap break-all">
                                            {result.fixCommand}
                                        </pre>
                                    </Show>
                                </div>
                            )}
                        </For>
                    </div>
                </Show>
            </div>
        </Show>
    </section>
  );
}
</file>

<file path="src/i18n/fr.js">
// Auto-generated by scripts/i18n.mjs. Do not edit by hand.
export default {
  "app.versionLabel": "Version",
  "brand.name": "SAVVA",
  "categories.all": "Toutes les catégories",
  "clipboard.copied": "Copié dans le presse-papiers !",
  "clipboard.copy": "Copier",
  "comment.reply": "Répondre",
  "comment.showLess": "Voir moins",
  "comment.showMore": "Voir plus",
  "commentsTab.replyTo": "En réponse à :",
  "common.apply": "Appliquer",
  "common.applying": "Application…",
  "common.cancel": "Annuler",
  "common.checking": "Vérification…",
  "common.confirm": "Confirmer",
  "common.error": "Erreur",
  "common.exists": "Existe",
  "common.fail": "Échouer",
  "common.loading": "Chargement…",
  "common.notFound": "Non trouvé",
  "common.ok": "OK",
  "common.remove": "Supprimer",
  "common.retry": "Réessayer",
  "default.avatar": "Avatar",
  "default.user": "Utilisateur",
  "delete.confirm.${type}.title": "Confirmer la Suppression",
  "delete.confirm.confirm": "Supprimer",
  "delete.confirm.deleting": "Suppression...",
  "delete.confirm.message": "Cela masquera le contenu, mais il ne peut pas être retiré de la blockchain. Cette action est irréversible. Êtes-vous sûr ?",
  "delete.toast.error": "Échec de la soumission de la transaction de suppression.",
  "delete.toast.success": "Suppression soumise. Elle sera masquée après que le backend ait traité la transaction.",
  "docs.article": "Article de documentation",
  "docs.nav": "Docs Développeur",
  "docs.next": "Suivant",
  "docs.prev": "Précédent",
  "docs.section": "Section",
  "docs.sidebar.empty": "Pas encore de docs. Ajoutez sidebar.yaml sous dev_docs/<lang>/",
  "docs.title": "Documentation développeur",
  "editor.bodyPlaceholder": "Commencez à écrire le contenu de votre post ici...",
  "editor.chapters.add": "Ajouter un Chapitre",
  "editor.chapters.confirmDeleteMessage": "Êtes-vous sûr de vouloir supprimer ce chapitre ? Cette action ne peut pas être annulée.",
  "editor.chapters.confirmDeleteTitle": "Supprimer le Chapitre",
  "editor.chapters.newChapterTitle": "Nouveau Chapitre",
  "editor.chapters.remove": "Supprimer le Chapitre",
  "editor.chapters.title": "Chapitres",
  "editor.chapters.titlePlaceholder": "Entrez le titre du chapitre",
  "editor.clearDraft": "Effacer le brouillon",
  "editor.clearDraftMessage": "Êtes-vous sûr de vouloir effacer ce brouillon ?",
  "editor.clearDraftTitle": "Confirmer l'effacement du brouillon",
  "editor.files.confirmDeleteTitle": "Supprimer le Fichier",
  "editor.files.empty": "Aucun fichier téléchargé pour l'instant. Utilisez les boutons ci-dessus pour ajouter des fichiers à votre publication.",
  "editor.files.menu.delete": "Supprimer",
  "editor.files.menu.insert": "Insérer",
  "editor.files.menu.insertUrl": "Insérer l'URL",
  "editor.files.menu.setThumbnail": "Définir comme Miniature",
  "editor.files.uploadError": "Échec de l'envoi. Veuillez réessayer.",
  "editor.files.uploadFromDisk": "Télécharger depuis le Disque",
  "editor.files.uploadFromUrl": "Télécharger depuis l'URL",
  "editor.files.uploadModalConfirm": "Confirmer le Téléchargement",
  "editor.files.uploadModalPlaceholder": "Glissez-déposez des fichiers ici ou cliquez pour sélectionner.",
  "editor.files.uploadModalTitle": "Télécharger des Fichiers",
  "editor.files.uploading": "Téléchargement en cours...",
  "editor.fullPreview.back": "Retour à l'Édition",
  "editor.fullPreview.help": "Ceci est un aperçu de l'apparence de votre publication une fois publiée. Vérifiez-le attentivement avant de continuer.",
  "editor.fullPreview.publish": "Publier",
  "editor.fullPreview.title": "Vérification Finale",
  "editor.params.fundraiser.label": "ID de campagne de collecte de fonds promue",
  "editor.params.nsfw.help": "Le contenu contient un langage ou des images explicites.",
  "editor.params.nsfw.label": "NSFW",
  "editor.params.publishAsNew.help": "Si coché, cela sera publié en tant que nouveau post avec un horodatage mis à jour, apparaissant en haut des fils.",
  "editor.params.publishAsNew.label": "Publier en tant que nouveau post",
  "editor.params.title": "Paramètres supplémentaires",
  "editor.previewPost": "Aperçu du Post",
  "editor.publish.descriptor.errorTitle": "Échec du téléchargement du descripteur",
  "editor.publish.draftCleared": "Brouillon effacé.",
  "editor.publish.ipfs.errorNetworkOrTooLarge": "Une erreur réseau est survenue. Cela peut se produire si le post est trop volumineux pour que le serveur l'accepte. Si vous souhaitez publier un contenu très lourd, envisagez d'utiliser vos propres services de PIN.",
  "editor.publish.ipfs.errorTitle": "Échec du téléchargement IPFS",
  "editor.publish.ipfs.errorTooLarge": "Ce post est trop volumineux, si vous souhaitez publier un contenu très lourd, envisagez d'utiliser vos propres services de PIN.",
  "editor.publish.publishing.errorTitle": "Échec de la Publication",
  "editor.publish.publishing.txHash": "Hash de la transaction",
  "editor.publish.publishing.waitFinalize": "La publication est en cours de finalisation sur la blockchain...",
  "editor.publish.publishing.waitSignature": "Veuillez confirmer la transaction dans votre portefeuille.",
  "editor.publish.publishing.waitSignatureHelp": "Si la fenêtre du portefeuille n'apparaît pas, ouvrez votre extension de portefeuille pour compléter la signature.",
  "editor.publish.rights.errorConfig": "Impossible de récupérer l'exigence minimale de mise de fonds depuis le contrat.",
  "editor.publish.rights.errorNoAuth": "Vous devez être connecté pour publier.",
  "editor.publish.rights.errorTitle": "Permission Refusée",
  "editor.publish.steps.check_rights": "Vérification des Droits",
  "editor.publish.steps.check_rights.help": "Vérification de vos autorisations de publication",
  "editor.publish.steps.ipfs": "Télécharger sur IPFS",
  "editor.publish.steps.ipfs.help": "Sauvegarde des données sur IPFS",
  "editor.publish.steps.ipfs_publish": "Publication IPFS",
  "editor.publish.steps.ipfs_publish.help": "En attente de disponibilité du contenu",
  "editor.publish.steps.publish": "Publication",
  "editor.publish.steps.publish.help": "Publication dans le fil",
  "editor.publish.steps.validate": "Validation de la Publication",
  "editor.publish.steps.validate.help": "Vérification de la structure de la publication",
  "editor.publish.success": "Publié avec succès !",
  "editor.publish.title": "Publier la Publication",
  "editor.publish.uploadingDescriptor": "Téléchargement du descripteur de publication",
  "editor.publish.uploadingToIpfs": "Téléchargement vers IPFS",
  "editor.publish.validation.backToEditor": "Retour à l'Éditeur",
  "editor.publish.validation.errorTitle": "Erreur de validation",
  "editor.sidebar.files": "Fichiers",
  "editor.sidebar.filesPlaceholder": "Gestionnaire de fichiers à venir.",
  "editor.sidebar.language": "Langue",
  "editor.sidebar.thumbnail": "Miniature",
  "editor.sidebar.thumbnailPlaceholder": "Aperçu de la miniature",
  "editor.thumbnail.delete": "Supprimer la miniature",
  "editor.title": "Éditeur de Post",
  "editor.titleEditComment": "Modifier le Commentaire",
  "editor.titleEditPost": "Modifier le Post",
  "editor.titleNewCommentFor": "Nouveau Commentaire Pour :",
  "editor.titleNewPost": "Nouveau Post",
  "editor.titlePlaceholder": "Titre du Post",
  "editor.toolbar.bold": "Gras",
  "editor.toolbar.files": "Fichiers",
  "editor.toolbar.hidePreview": "Masquer l'Aperçu",
  "editor.toolbar.image": "Image",
  "editor.toolbar.italic": "Italique",
  "editor.toolbar.link": "Lien",
  "editor.toolbar.maximize": "Maximiser",
  "editor.toolbar.minimize": "Minimiser",
  "editor.toolbar.showPreview": "Afficher l'Aperçu",
  "error.connection.message": "L'application n'a pas pu se connecter au serveur backend. Il est peut-être temporairement hors ligne. Veuillez réessayer plus tard.",
  "error.connection.retry": "Rafraîchir la page",
  "error.connection.title": "Échec de la connexion",
  "error.ws.message": "Impossible de se connecter. Veuillez réessayer.",
  "error.ws.title": "Erreur de connexion",
  "header.newPost": "Nouveau Post",
  "ipfs.diag.cors.error": "Problème de configuration CORS.",
  "ipfs.diag.cors.name": "Vérification CORS de la passerelle",
  "ipfs.diag.cors.ok": "CORS est configuré correctement.",
  "ipfs.diag.fetch.errorFirewall": "Échec de la récupération en raison d'un pare-feu.",
  "ipfs.diag.fetch.name": "Récupération de la passerelle en direct",
  "ipfs.diag.fetch.ok": "Récupération réussie.",
  "ipfs.diag.fetch.warnSkipped": "Ignoré : ABI CID non trouvé dans la réponse /info.",
  "ipfs.diag.fix.browser": "S'il fonctionne, vérifiez votre navigateur. Pour Brave, désactivez les boucliers pour ce site. Pour d'autres navigateurs comme Chrome, vous devrez peut-être 'Autoriser le contenu non sécurisé' dans les paramètres du site.",
  "ipfs.diag.fix.cors": "S'il échoue toujours, exécutez cette commande pour corriger la politique CORS de l'API :",
  "ipfs.diag.fix.daemon": "Tout d'abord, assurez-vous que votre démon IPFS fonctionne dans un terminal :",
  "ipfs.diag.fix.gatewaySingleOrigin": "Option 1 (Recommandée) : Autoriser uniquement l'origine actuelle.",
  "ipfs.diag.fix.gatewayTitle": "Votre configuration de passerelle empêche probablement le navigateur de récupérer. Essayez l'une de ces commandes :",
  "ipfs.diag.fix.gatewayWildcard": "Option 2 (Plus facile pour les développeurs) : Autoriser n'importe quelle origine. À utiliser avec prudence sur les nœuds publics.",
  "ipfs.diag.fix.title": "Pour corriger, exécutez ceci dans votre terminal (puis redémarrez le démon) :",
  "ipfs.diag.liveness.error": "Le nœud ne répond pas.",
  "ipfs.diag.liveness.name": "Vérification de la vivacité de l'API",
  "ipfs.diag.liveness.ok": "Le nœud est actif.",
  "ipfs.diag.run": "Exécuter les diagnostics",
  "ipfs.diag.title": "Diagnostics du nœud IPFS",
  "main.newContentAvailable": "Nouveau contenu disponible !",
  "main.tabs.empty": "Cet onglet est vide pour l'instant.",
  "main.tabs.loading": "Chargement des onglets…",
  "main.tabs.untitled": "Sans titre",
  "newTab.category": "Catégorie",
  "newTab.view.grid": "Vue en grille",
  "newTab.view.group": "Groupe de vue",
  "newTab.view.list": "Vue en liste",
  "post.addComment": "Ajouter un commentaire...",
  "post.chapters.prologue": "Prologue",
  "post.chapters.title": "Table des matières",
  "post.comments": "Commentaires",
  "post.loadMoreComments": "Charger plus de commentaires",
  "post.noComments": "Pas encore de commentaires.",
  "post.notFound.message": "La publication que vous recherchez n'existe pas ou a été supprimée.",
  "post.notFound.title": "Publication non trouvée",
  "postcard.copyDataCid": "Copier le Data CID",
  "postcard.copyDescriptorCid": "Copier le Descriptor CID",
  "postcard.copySavvaCid": "Copier le SAVVA CID",
  "postcard.pin": "Épingler le Post",
  "postcard.unpin": "Détacher le Post",
  "reactions.${reactionType()}": "Réagir avec {reactionType}",
  "reactions.${type}": "Réaction {type}",
  "reactions.angry": "Fâché",
  "reactions.clap": "👏 Applaudir",
  "reactions.dislike": "👎 Je n'aime pas",
  "reactions.fire": "🔥",
  "reactions.ha_ha": "Ha Ha",
  "reactions.hot": "Chaud",
  "reactions.laugh": "Haha",
  "reactions.like": "J'aime",
  "reactions.love": "Amour",
  "reactions.sad": "Triste",
  "reactions.star": "⭐",
  "reactions.super": "🌟 Génial",
  "reactions.trophy": "Trophée",
  "reactions.wow": "Wow",
  "rightPane.language": "Langue",
  "rightPane.settings": "Paramètres",
  "rightPane.switch.backend.help": "L'application récupérera /info depuis cette URL pour lister les domaines pris en charge.",
  "rightPane.switch.backend.label": "URL du backend",
  "rightPane.switch.backend.placeholder": "https://example.com/api/",
  "rightPane.switch.domain.label": "Domaine",
  "rightPane.switch.domain.website": "Site Web",
  "rightPane.switch.noDomains": "Le backend n'a retourné aucun domaine. Vous pouvez toujours postuler, mais le domaine sera vide.",
  "rightPane.switch.open": "Changer de backend / domaine",
  "rightPane.switch.reload": "Charger les domaines",
  "rightPane.switch.reload.title": "Récupérer /info et rafraîchir la liste des domaines",
  "rightPane.switch.reset": "Réinitialiser aux valeurs par défaut",
  "rightPane.switch.reset.title": "Effacer la surcharge locale et recharger les valeurs par défaut depuis default_connect.yaml",
  "rightPane.switch.title": "Changer de backend / domaine",
  "rightPane.switch.validation.protocol": "L'URL du backend doit commencer par http:// ou https://",
  "rightPane.theme": "Thème",
  "settings.back": "Retour",
  "settings.dev.assets.baseUrl": "URL de base des actifs",
  "settings.dev.assets.configUrl": "URL de configuration",
  "settings.dev.assets.configUrl.computed": "URL calculée",
  "settings.dev.assets.configUrl.open": "Ouvrir l'URL de configuration",
  "settings.dev.assets.diagnostics.default": "Configuration par défaut",
  "settings.dev.assets.diagnostics.error": "Erreur de diagnostic",
  "settings.dev.assets.diagnostics.hasCategories": "A des catégories",
  "settings.dev.assets.diagnostics.hasConfig": "A une configuration",
  "settings.dev.assets.diagnostics.hasFavicon": "Favicon détecté",
  "settings.dev.assets.diagnostics.hasLocales": "A des locales",
  "settings.dev.assets.diagnostics.hasLogos": "A des logos",
  "settings.dev.assets.diagnostics.hasTabs": "A des onglets",
  "settings.dev.assets.diagnostics.noteNetwork": "Vérifiez votre connexion réseau.",
  "settings.dev.assets.diagnostics.primary": "Configuration principale",
  "settings.dev.assets.diagnostics.run": "Exécuter les diagnostics",
  "settings.dev.assets.diagnostics.sampleFetches": "Exemples de récupérations",
  "settings.dev.assets.diagnostics.title": "Diagnostics des actifs",
  "settings.dev.assets.domain": "Domaine",
  "settings.dev.assets.env": "Environnement",
  "settings.dev.assets.env.prod": "Production",
  "settings.dev.assets.env.test": "Test",
  "settings.dev.assets.prefix.active": "Préfixe actif",
  "settings.dev.assets.prefix.computed": "Préfixe calculé",
  "settings.dev.assets.source": "Source",
  "settings.dev.assets.title": "Actifs",
  "settings.developer.debug.enable": "Activer la journalisation de débogage",
  "settings.developer.showKeys": "Afficher les clés API",
  "settings.developer.title": "Paramètres du développeur",
  "settings.ipfs.localDisabled": "IPFS local désactivé",
  "settings.localIpfs.apiUrl.label": "URL API IPFS local",
  "settings.localIpfs.disable": "Désactiver",
  "settings.localIpfs.enableCheckbox": "Utiliser le nœud IPFS local",
  "settings.localIpfs.gateway.label": "Passerelle",
  "settings.localIpfs.status.label": "Statut",
  "settings.localIpfs.testEnable": "Tester et activer",
  "settings.localIpfs.title": "IPFS local",
  "settings.title": "Paramètres",
  "stakerLevels.${l.key}": "Niveau de Staker {l.key}",
  "stakerLevels.clam": "Palourde",
  "stakerLevels.dolphin": "Dauphin",
  "stakerLevels.fish": "Poisson",
  "stakerLevels.guest": "Invité",
  "stakerLevels.orca": "Orque",
  "stakerLevels.seahorse": "Hippocampe",
  "stakerLevels.shark": "Requin",
  "stakerLevels.shrimp": "Crevette",
  "stakerLevels.stingray": "Raie",
  "stakerLevels.whale": "Baleine",
  "tabs.aria": "Onglets de section",
  "tabs.title.${slug(tab.type)}": "Onglet : {tab.type}",
  "tabs.title.actual": "Actuel",
  "tabs.title.comments": "Commentaires",
  "tabs.title.for-you": "Pour Vous",
  "tabs.title.leaders": "Leaders",
  "tabs.title.new": "Nouveau",
  "time.day.plural": "il y a {n} jours",
  "time.day.singular": "il y a {n} jour",
  "time.hour.plural": "il y a {n} heures",
  "time.hour.singular": "il y a {n} heure",
  "time.minute.plural": "il y a {n} minutes",
  "time.minute.singular": "il y a {n} minute",
  "time.now": "Maintenant",
  "timeFrame.${frame}": "Période : {frame}",
  "timeFrame.all": "Tout le temps",
  "timeFrame.month": "Mois",
  "timeFrame.week": "Semaine",
  "timeFrame.year": "Année",
  "ui.mode.dark": "Mode sombre",
  "ui.mode.light": "Mode clair",
  "ui.toTop": "Retour en haut",
  "wallet.changeChain": "Changer de réseau",
  "wallet.connect": "Connecter le portefeuille",
  "wallet.copyAddress": "Copier l'adresse",
  "wallet.error.userCanceled": "Transaction annulée.",
  "wallet.onRequiredNetwork": "Sur le réseau requis"
};
</file>

<file path="src/i18n/sr.js">
// Auto-generated by scripts/i18n.mjs. Do not edit by hand.
export default {
  "app.versionLabel": "Verzija",
  "brand.name": "SAVVA",
  "categories.all": "Sve kategorije",
  "clipboard.copied": "Kopirano u međuspremnik!",
  "clipboard.copy": "Kopiraj",
  "comment.reply": "Odgovori",
  "comment.showLess": "Prikaži manje",
  "comment.showMore": "Prikaži više",
  "commentsTab.replyTo": "U odgovoru na:",
  "common.apply": "Primeni",
  "common.applying": "Primena…",
  "common.cancel": "Otkaži",
  "common.checking": "Proveravam…",
  "common.confirm": "Potvrdi",
  "common.error": "Greška",
  "common.exists": "Postoji",
  "common.fail": "Neuspeh",
  "common.loading": "Učitavanje…",
  "common.notFound": "Nije pronađeno",
  "common.ok": "U redu",
  "common.remove": "Ukloni",
  "common.retry": "Pokušaj ponovo",
  "default.avatar": "Avatar",
  "default.user": "Korisnik",
  "delete.confirm.${type}.title": "Potvrdi brisanje",
  "delete.confirm.confirm": "Obriši",
  "delete.confirm.deleting": "Brišem...",
  "delete.confirm.message": "Ovo će sakriti sadržaj, ali ga ne može ukloniti sa blockchain-a. Ova akcija se ne može poništiti. Da li ste sigurni?",
  "delete.toast.error": "Nije uspelo slanje zahteva za brisanje.",
  "delete.toast.success": "Zahtev za brisanje je poslat. Biće sakriven nakon što backend obradi transakciju.",
  "docs.article": "Dokumentacioni članak",
  "docs.nav": "Dokumentacija za programere",
  "docs.next": "Sledeće",
  "docs.prev": "Prethodno",
  "docs.section": "Sekcija",
  "docs.sidebar.empty": "Još nema dokumenata. Dodajte sidebar.yaml pod dev_docs/<lang>/",
  "docs.title": "Dokumentacija za programere",
  "editor.bodyPlaceholder": "Počnite da pišete sadržaj posta ovde...",
  "editor.chapters.add": "Dodaj Poglavlje",
  "editor.chapters.confirmDeleteMessage": "Da li ste sigurni da želite da obrišete ovo poglavlje? Ova akcija se ne može poništiti.",
  "editor.chapters.confirmDeleteTitle": "Obriši Poglavlje",
  "editor.chapters.newChapterTitle": "Novo Poglavlje",
  "editor.chapters.remove": "Obriši Poglavlje",
  "editor.chapters.title": "Poglavlja",
  "editor.chapters.titlePlaceholder": "Unesite naslov poglavlja",
  "editor.clearDraft": "Obriši nacrt",
  "editor.clearDraftMessage": "Da li ste sigurni da želite da obrišete ovaj nacrt?",
  "editor.clearDraftTitle": "Potvrdi brisanje nacrta",
  "editor.files.confirmDeleteTitle": "Obriši Datoteku",
  "editor.files.empty": "Još nema učitanih datoteka. Iskoristite dugmadi iznad da dodate datoteke u vaš post.",
  "editor.files.menu.delete": "Obriši",
  "editor.files.menu.insert": "Umetni",
  "editor.files.menu.insertUrl": "Umetni URL",
  "editor.files.menu.setThumbnail": "Postavi kao Sliku",
  "editor.files.uploadError": "Učitavanje nije uspelo. Pokušajte ponovo.",
  "editor.files.uploadFromDisk": "Učitaj sa diska",
  "editor.files.uploadFromUrl": "Učitaj sa URL-a",
  "editor.files.uploadModalConfirm": "Potvrdi Učitavanje",
  "editor.files.uploadModalPlaceholder": "Prevucite i ispustite datoteke ovde ili kliknite da izaberete.",
  "editor.files.uploadModalTitle": "Učitaj Datoteke",
  "editor.files.uploading": "Učitavanje...",
  "editor.fullPreview.back": "Nazad na Uređivanje",
  "editor.fullPreview.help": "Ovo je pregled kako će vaš post izgledati kada bude objavljen. Pažljivo ga pregledajte pre nego što nastavite.",
  "editor.fullPreview.publish": "Objavi",
  "editor.fullPreview.title": "Završna Provera",
  "editor.params.fundraiser.label": "ID Promovisanog Kampanje Prikupljanja Sredstava",
  "editor.params.nsfw.help": "Sadržaj sadrži eksplicitni jezik ili slike.",
  "editor.params.nsfw.label": "NSFW",
  "editor.params.publishAsNew.help": "Ako je označeno, ovo će biti objavljeno kao nova objava sa ažuriranim vremenom, pojavljujući na vrhu feedova.",
  "editor.params.publishAsNew.label": "Objavi kao novu objavu",
  "editor.params.title": "Dodatni Parametri",
  "editor.previewPost": "Pregled Posta",
  "editor.publish.descriptor.errorTitle": "Neuspešno otpremanje opisa",
  "editor.publish.draftCleared": "Nacrt obrisan.",
  "editor.publish.ipfs.errorNetworkOrTooLarge": "Došlo je do greške u mreži. Ovo se može desiti ako je post prevelik za server. Ako želite da objavite veoma veliki sadržaj, razmislite o korišćenju svojih PIN usluga.",
  "editor.publish.ipfs.errorTitle": "Neuspešno otpremanje na IPFS",
  "editor.publish.ipfs.errorTooLarge": "Ovo je prevelik post, ako želite da objavite veoma veliki sadržaj, razmislite o korišćenju svojih PIN usluga.",
  "editor.publish.publishing.errorTitle": "Objavljivanje Neuspešno",
  "editor.publish.publishing.txHash": "Hesh transakcije",
  "editor.publish.publishing.waitFinalize": "Objavljivanje se finalizuje na blockchain-u...",
  "editor.publish.publishing.waitSignature": "Molimo potvrdite transakciju u vašem novčaniku.",
  "editor.publish.publishing.waitSignatureHelp": "Ako prozor novčanika ne pojavi, otvorite ekstenziju novčanika da završite potpisivanje.",
  "editor.publish.rights.errorConfig": "Nije moguće preuzeti minimalne zahteve za ulog iz ugovora.",
  "editor.publish.rights.errorNoAuth": "Morate biti prijavljeni da biste objavili.",
  "editor.publish.rights.errorTitle": "Dozvola Odbijena",
  "editor.publish.steps.check_rights": "Proverava Prava",
  "editor.publish.steps.check_rights.help": "Verifikacija vaših dozvola za objavljivanje",
  "editor.publish.steps.ipfs": "Učitavanje na IPFS",
  "editor.publish.steps.ipfs.help": "Čuvanje podataka na IPFS-u",
  "editor.publish.steps.ipfs_publish": "Objavljivanje na IPFS-u",
  "editor.publish.steps.ipfs_publish.help": "Čekanje na dostupnost sadržaja",
  "editor.publish.steps.publish": "Objavljivanje",
  "editor.publish.steps.publish.help": "Objavljivanje na feed",
  "editor.publish.steps.validate": "Validacija Posta",
  "editor.publish.steps.validate.help": "Proverava strukturu posta",
  "editor.publish.success": "Uspešno objavljeno!",
  "editor.publish.title": "Objavi Post",
  "editor.publish.uploadingDescriptor": "Otpremanje opisa posta",
  "editor.publish.uploadingToIpfs": "Otpremanje na IPFS",
  "editor.publish.validation.backToEditor": "Nazad na Uređivač",
  "editor.publish.validation.errorTitle": "Greška u validaciji",
  "editor.sidebar.files": "Datoteke",
  "editor.sidebar.filesPlaceholder": "Upravljač datotekama uskoro dolazi.",
  "editor.sidebar.language": "Jezik",
  "editor.sidebar.thumbnail": "Sličica",
  "editor.sidebar.thumbnailPlaceholder": "Pregled sličice",
  "editor.thumbnail.delete": "Obriši sličicu",
  "editor.title": "Uređivač Posta",
  "editor.titleEditComment": "Izmeni komentar",
  "editor.titleEditPost": "Izmeni Post",
  "editor.titleNewCommentFor": "Novi komentar za:",
  "editor.titleNewPost": "Novi Post",
  "editor.titlePlaceholder": "Naslov Posta",
  "editor.toolbar.bold": "Podebljano",
  "editor.toolbar.files": "Datoteke",
  "editor.toolbar.hidePreview": "Sakrij Pregled",
  "editor.toolbar.image": "Slika",
  "editor.toolbar.italic": "Kurziv",
  "editor.toolbar.link": "Link",
  "editor.toolbar.maximize": "Povećaj",
  "editor.toolbar.minimize": "Smanji",
  "editor.toolbar.showPreview": "Prikaži Pregled",
  "error.connection.message": "Aplikacija nije mogla da se poveže sa backend serverom. Možda je privremeno van mreže. Pokušajte ponovo kasnije.",
  "error.connection.retry": "Osveži stranicu",
  "error.connection.title": "Neuspešna konekcija",
  "error.ws.message": "Nije moguće povezati se. Pokušajte ponovo.",
  "error.ws.title": "Greška u vezi",
  "header.newPost": "Novi Post",
  "ipfs.diag.cors.error": "Problem sa CORS konfiguracijom.",
  "ipfs.diag.cors.name": "Provera CORS-a na gateway-u",
  "ipfs.diag.cors.ok": "CORS je ispravno konfigurisan.",
  "ipfs.diag.fetch.errorFirewall": "Preuzimanje nije uspelo zbog vatrozida.",
  "ipfs.diag.fetch.name": "Preuzimanje sa aktivnog gateway-a",
  "ipfs.diag.fetch.ok": "Preuzimanje uspešno.",
  "ipfs.diag.fetch.warnSkipped": "Preskočeno: ABI CID nije pronađen u /info odgovoru.",
  "ipfs.diag.fix.browser": "Ako radi, proverite vaš pregledač. Za Brave, onemogućite Shields za ovu stranicu. Za druge pregledače kao što je Chrome, možda ćete morati da 'Dozvolite nesiguran sadržaj' u podešavanjima stranice.",
  "ipfs.diag.fix.cors": "Ako i dalje ne radi, pokrenite ovu komandu da popravite CORS politiku API-ja:",
  "ipfs.diag.fix.daemon": "Prvo, proverite da li vaš IPFS demon radi u terminalu:",
  "ipfs.diag.fix.gatewaySingleOrigin": "Opcija 1 (Preporučeno): Dozvolite samo trenutni izvor.",
  "ipfs.diag.fix.gatewayTitle": "Vaša konfiguracija gateway-a verovatno sprečava pretraživač da preuzme. Pokušajte sa jednim od ovih komandi:",
  "ipfs.diag.fix.gatewayWildcard": "Opcija 2 (Lakše za razvoj): Dozvolite bilo koji izvor. Koristite sa oprezom na javnim čvorovima.",
  "ipfs.diag.fix.title": "Da biste popravili, pokrenite ovo u vašem terminalu (zatim restartujte demon):",
  "ipfs.diag.liveness.error": "Čvor ne odgovara.",
  "ipfs.diag.liveness.name": "Provera aktivnog API-ja",
  "ipfs.diag.liveness.ok": "Čvor je aktivan.",
  "ipfs.diag.run": "Pokreni dijagnostiku",
  "ipfs.diag.title": "IPFS Dijagnostika čvora",
  "main.newContentAvailable": "Novi sadržaj je dostupan!",
  "main.tabs.empty": "Ovaj tab je trenutno prazan.",
  "main.tabs.loading": "Učitavanje tabova…",
  "main.tabs.untitled": "Bez naslova",
  "newTab.category": "Kategorija",
  "newTab.view.grid": "Mrežni prikaz",
  "newTab.view.group": "Grupni prikaz",
  "newTab.view.list": "Lista",
  "post.addComment": "Dodaj komentar...",
  "post.chapters.prologue": "Prolog",
  "post.chapters.title": "Sadržaj",
  "post.comments": "Komentari",
  "post.loadMoreComments": "Učitaj više komentara",
  "post.noComments": "Još nema komentara.",
  "post.notFound.message": "Objava koju tražite ne postoji ili je uklonjena.",
  "post.notFound.title": "Objava nije pronađena",
  "postcard.copyDataCid": "Kopiraj Data CID",
  "postcard.copyDescriptorCid": "Kopiraj Descriptor CID",
  "postcard.copySavvaCid": "Kopiraj SAVVA CID",
  "postcard.pin": "Prikazivanje Posta",
  "postcard.unpin": "Ukloni Prikazivanje Posta",
  "reactions.${reactionType()}": "Reaguj sa {reactionType}",
  "reactions.${type}": "{type} reakcija",
  "reactions.angry": "Ljut",
  "reactions.clap": "👏 Aplauz",
  "reactions.dislike": "👎 Ne sviđa mi se",
  "reactions.fire": "🔥",
  "reactions.ha_ha": "Haha",
  "reactions.hot": "Vruće",
  "reactions.laugh": "Haha",
  "reactions.like": "Sviđa mi se",
  "reactions.love": "Volim",
  "reactions.sad": "Tužno",
  "reactions.star": "⭐",
  "reactions.super": "🌟 Super",
  "reactions.trophy": "Pehar",
  "reactions.wow": "Vau",
  "rightPane.language": "Jezik",
  "rightPane.settings": "Podešavanja",
  "rightPane.switch.backend.help": "Aplikacija će preuzeti /info sa ove URL adrese da bi prikazala podržane domene.",
  "rightPane.switch.backend.label": "Backend URL",
  "rightPane.switch.backend.placeholder": "https://example.com/api/",
  "rightPane.switch.domain.label": "Domen",
  "rightPane.switch.domain.website": "Vebsajt",
  "rightPane.switch.noDomains": "Backend nije vratio nijedan domen. Možete se prijaviti, ali domen će biti prazan.",
  "rightPane.switch.open": "Promeni backend / domen",
  "rightPane.switch.reload": "Učitaj domene",
  "rightPane.switch.reload.title": "Preuzmi /info i osveži listu domena",
  "rightPane.switch.reset": "Vrati na podrazumevano",
  "rightPane.switch.reset.title": "Obriši lokalne izmene i ponovo učitaj podrazumevane vrednosti iz default_connect.yaml",
  "rightPane.switch.title": "Promeni backend / domen",
  "rightPane.switch.validation.protocol": "Backend URL mora početi sa http:// ili https://",
  "rightPane.theme": "Tema",
  "settings.back": "Nazad",
  "settings.dev.assets.baseUrl": "Osnovni URL resursa",
  "settings.dev.assets.configUrl": "Config URL",
  "settings.dev.assets.configUrl.computed": "Izračunati URL",
  "settings.dev.assets.configUrl.open": "Otvorite Config URL",
  "settings.dev.assets.diagnostics.default": "Podrazumevana konfiguracija",
  "settings.dev.assets.diagnostics.error": "Greška u dijagnostici",
  "settings.dev.assets.diagnostics.hasCategories": "Ima kategorije",
  "settings.dev.assets.diagnostics.hasConfig": "Ima konfiguraciju",
  "settings.dev.assets.diagnostics.hasFavicon": "Favicon otkriven",
  "settings.dev.assets.diagnostics.hasLocales": "Ima jezike",
  "settings.dev.assets.diagnostics.hasLogos": "Ima logotipe",
  "settings.dev.assets.diagnostics.hasTabs": "Ima kartice",
  "settings.dev.assets.diagnostics.noteNetwork": "Proverite vašu mrežnu konekciju.",
  "settings.dev.assets.diagnostics.primary": "Primarna konfiguracija",
  "settings.dev.assets.diagnostics.run": "Pokreni dijagnostiku",
  "settings.dev.assets.diagnostics.sampleFetches": "Uzorci preuzimanja",
  "settings.dev.assets.diagnostics.title": "Dijagnostika resursa",
  "settings.dev.assets.domain": "Domen",
  "settings.dev.assets.env": "Okruženje",
  "settings.dev.assets.env.prod": "Proizvodnja",
  "settings.dev.assets.env.test": "Test",
  "settings.dev.assets.prefix.active": "Aktivni prefiks",
  "settings.dev.assets.prefix.computed": "Izračunati prefiks",
  "settings.dev.assets.source": "Izvor",
  "settings.dev.assets.title": "Resursi",
  "settings.developer.debug.enable": "Omogući logovanje grešaka",
  "settings.developer.showKeys": "Prikaži API ključeve",
  "settings.developer.title": "Podešavanja za programere",
  "settings.ipfs.localDisabled": "Lokalni IPFS onemogućen",
  "settings.localIpfs.apiUrl.label": "Lokalni IPFS API URL",
  "settings.localIpfs.disable": "Onemogući",
  "settings.localIpfs.enableCheckbox": "Koristi lokalni IPFS čvor",
  "settings.localIpfs.gateway.label": "Gateway",
  "settings.localIpfs.status.label": "Status",
  "settings.localIpfs.testEnable": "Testiraj i omogući",
  "settings.localIpfs.title": "Lokalni IPFS",
  "settings.title": "Podešavanja",
  "stakerLevels.${l.key}": "Nivo stakera {l.key}",
  "stakerLevels.clam": "Školjka",
  "stakerLevels.dolphin": "Delfin",
  "stakerLevels.fish": "Riba",
  "stakerLevels.guest": "Gost",
  "stakerLevels.orca": "Orka",
  "stakerLevels.seahorse": "Morski konjić",
  "stakerLevels.shark": "Ajkula",
  "stakerLevels.shrimp": "Krevetica",
  "stakerLevels.stingray": "Raža",
  "stakerLevels.whale": "Kit",
  "tabs.aria": "Kartice sekcija",
  "tabs.title.${slug(tab.type)}": "Kartica: {tab.type}",
  "tabs.title.actual": "Trenutno",
  "tabs.title.comments": "Komentari",
  "tabs.title.for-you": "Za Vas",
  "tabs.title.leaders": "Lideri",
  "tabs.title.new": "Novi",
  "time.day.plural": "pre {n} dana",
  "time.day.singular": "pre {n} dan",
  "time.hour.plural": "pre {n} sati",
  "time.hour.singular": "pre {n} sat",
  "time.minute.plural": "pre {n} minuta",
  "time.minute.singular": "pre {n} minut",
  "time.now": "Sada",
  "timeFrame.${frame}": "Vremenski okvir: {frame}",
  "timeFrame.all": "Sve Vreme",
  "timeFrame.month": "Mesec",
  "timeFrame.week": "Nedelja",
  "timeFrame.year": "Godina",
  "ui.mode.dark": "Tamni režim",
  "ui.mode.light": "Svetli režim",
  "ui.toTop": "Nazad na vrh",
  "wallet.changeChain": "Promeni mrežu",
  "wallet.connect": "Poveži novčanik",
  "wallet.copyAddress": "Kopiraj adresu",
  "wallet.error.userCanceled": "Transakcija otkazana.",
  "wallet.onRequiredNetwork": "Na potrebnoj mreži"
};
</file>

<file path="src/i18n/ua.js">
// Auto-generated by scripts/i18n.mjs. Do not edit by hand.
export default {
  "app.versionLabel": "Версія",
  "brand.name": "SAVVA",
  "categories.all": "Всі категорії",
  "clipboard.copied": "Скопійовано в буфер обміну!",
  "clipboard.copy": "Копіювати",
  "comment.reply": "Відповісти",
  "comment.showLess": "Показати менше",
  "comment.showMore": "Показати більше",
  "commentsTab.replyTo": "Відповідь на:",
  "common.apply": "Застосувати",
  "common.applying": "Застосування…",
  "common.cancel": "Скасувати",
  "common.checking": "Перевірка…",
  "common.confirm": "Підтвердити",
  "common.error": "Помилка",
  "common.exists": "Існує",
  "common.fail": "Не вдалося",
  "common.loading": "Завантаження…",
  "common.notFound": "Не знайдено",
  "common.ok": "Гаразд",
  "common.remove": "Видалити",
  "common.retry": "Спробувати ще раз",
  "default.avatar": "Аватар",
  "default.user": "Користувач",
  "delete.confirm.${type}.title": "Підтвердити видалення",
  "delete.confirm.confirm": "Видалити",
  "delete.confirm.deleting": "Видалення...",
  "delete.confirm.message": "Це приховає вміст, але не дозволить видалити його з блокчейну. Цю дію не можна скасувати. Ви впевнені?",
  "delete.toast.error": "Не вдалося надіслати запит на видалення.",
  "delete.toast.success": "Запит на видалення надіслано. Він буде прихований після обробки транзакції на сервері.",
  "docs.article": "Стаття документації",
  "docs.nav": "Документація для розробників",
  "docs.next": "Наступний",
  "docs.prev": "Попередній",
  "docs.section": "Розділ",
  "docs.sidebar.empty": "Документації ще немає. Додайте sidebar.yaml під dev_docs/<lang>/",
  "docs.title": "Документація для розробників",
  "editor.bodyPlaceholder": "Почніть писати контент поста тут...",
  "editor.chapters.add": "Додати Розділ",
  "editor.chapters.confirmDeleteMessage": "Ви впевнені, що хочете видалити цей розділ? Цю дію не можна скасувати.",
  "editor.chapters.confirmDeleteTitle": "Видалити розділ",
  "editor.chapters.newChapterTitle": "Новий Розділ",
  "editor.chapters.remove": "Видалити Розділ",
  "editor.chapters.title": "Розділи",
  "editor.chapters.titlePlaceholder": "Введіть назву розділу",
  "editor.clearDraft": "Очистити чернетку",
  "editor.clearDraftMessage": "Ви впевнені, що хочете очистити цю чернетку?",
  "editor.clearDraftTitle": "Підтвердити очищення чернетки",
  "editor.files.confirmDeleteTitle": "Видалити Файл",
  "editor.files.empty": "Ще не завантажено жодного файлу. Використовуйте кнопки вище, щоб додати файли до вашого посту.",
  "editor.files.menu.delete": "Видалити",
  "editor.files.menu.insert": "Вставити",
  "editor.files.menu.insertUrl": "Вставити URL",
  "editor.files.menu.setThumbnail": "Встановити як Мініатюру",
  "editor.files.uploadError": "Завантаження не вдалося. Спробуйте ще раз.",
  "editor.files.uploadFromDisk": "Завантажити з Диска",
  "editor.files.uploadFromUrl": "Завантажити з URL",
  "editor.files.uploadModalConfirm": "Підтвердити Завантаження",
  "editor.files.uploadModalPlaceholder": "Перетягніть файли сюди або натисніть, щоб вибрати.",
  "editor.files.uploadModalTitle": "Завантажити Файли",
  "editor.files.uploading": "Завантаження...",
  "editor.fullPreview.back": "Назад до Редагування",
  "editor.fullPreview.help": "Це попередній перегляд того, як виглядатиме ваш пост після публікації. Уважно перевірте його перед продовженням.",
  "editor.fullPreview.publish": "Опублікувати",
  "editor.fullPreview.title": "Остаточна Перевірка",
  "editor.params.fundraiser.label": "ID просуваної кампанії збору коштів",
  "editor.params.nsfw.help": "Контент містить відверту мову або зображення.",
  "editor.params.nsfw.label": "NSFW",
  "editor.params.publishAsNew.help": "Якщо вибрано, це буде опубліковано як новий пост з оновленим часом, з'являючись на початку стрічок.",
  "editor.params.publishAsNew.label": "Опублікувати як новий пост",
  "editor.params.title": "Додаткові параметри",
  "editor.previewPost": "Попередній перегляд поста",
  "editor.publish.descriptor.errorTitle": "Не вдалося завантажити опис",
  "editor.publish.draftCleared": "Чернетка очищена.",
  "editor.publish.ipfs.errorNetworkOrTooLarge": "Сталася помилка мережі. Це може статися, якщо пост занадто великий для прийняття сервером. Якщо ви хочете опублікувати дуже великий контент, будь ласка, розгляньте можливість використання власних PIN-сервісів.",
  "editor.publish.ipfs.errorTitle": "Не вдалося завантажити до IPFS",
  "editor.publish.ipfs.errorTooLarge": "Цей пост занадто великий, якщо ви хочете опублікувати дуже великий контент, будь ласка, розгляньте можливість використання власних PIN-сервісів.",
  "editor.publish.publishing.errorTitle": "Не вдалося опублікувати",
  "editor.publish.publishing.txHash": "Хеш транзакції",
  "editor.publish.publishing.waitFinalize": "Публікація завершується в блокчейні...",
  "editor.publish.publishing.waitSignature": "Будь ласка, підтвердіть транзакцію у вашому гаманці.",
  "editor.publish.publishing.waitSignatureHelp": "Якщо вікно гаманця не з'являється, відкрийте розширення гаманця, щоб завершити підпис.",
  "editor.publish.rights.errorConfig": "Не вдалося отримати мінімальні вимоги до стейкінгу з контракту.",
  "editor.publish.rights.errorNoAuth": "Вам потрібно увійти, щоб публікувати.",
  "editor.publish.rights.errorTitle": "Доступ заборонено",
  "editor.publish.steps.check_rights": "Перевірка Прав",
  "editor.publish.steps.check_rights.help": "Перевірка ваших прав на публікацію",
  "editor.publish.steps.ipfs": "Завантаження в IPFS",
  "editor.publish.steps.ipfs.help": "Збереження даних в IPFS",
  "editor.publish.steps.ipfs_publish": "Публікація в IPFS",
  "editor.publish.steps.ipfs_publish.help": "Очікування доступності контенту",
  "editor.publish.steps.publish": "Публікація",
  "editor.publish.steps.publish.help": "Публікація в стрічку",
  "editor.publish.steps.validate": "Перевірка Поста",
  "editor.publish.steps.validate.help": "Перевірка структури поста",
  "editor.publish.success": "Успішно опубліковано!",
  "editor.publish.title": "Опублікувати Пост",
  "editor.publish.uploadingDescriptor": "Завантаження опису поста",
  "editor.publish.uploadingToIpfs": "Завантаження до IPFS",
  "editor.publish.validation.backToEditor": "Назад до Редактора",
  "editor.publish.validation.errorTitle": "Помилка валідації",
  "editor.sidebar.files": "Файли",
  "editor.sidebar.filesPlaceholder": "Менеджер файлів незабаром.",
  "editor.sidebar.language": "Мова",
  "editor.sidebar.thumbnail": "Мініатюра",
  "editor.sidebar.thumbnailPlaceholder": "Попередній перегляд мініатюри",
  "editor.thumbnail.delete": "Видалити ескіз",
  "editor.title": "Редактор постів",
  "editor.titleEditComment": "Редагувати коментар",
  "editor.titleEditPost": "Редагувати пост",
  "editor.titleNewCommentFor": "Новий коментар для:",
  "editor.titleNewPost": "Новий пост",
  "editor.titlePlaceholder": "Заголовок поста",
  "editor.toolbar.bold": "Жирний",
  "editor.toolbar.files": "Файли",
  "editor.toolbar.hidePreview": "Сховати Попередній Перегляд",
  "editor.toolbar.image": "Зображення",
  "editor.toolbar.italic": "Курсив",
  "editor.toolbar.link": "Посилання",
  "editor.toolbar.maximize": "Розгорнути",
  "editor.toolbar.minimize": "Згорнути",
  "editor.toolbar.showPreview": "Показати Попередній Перегляд",
  "error.connection.message": "Додаток не зміг підключитися до сервера бекенду. Він може бути тимчасово недоступний. Спробуйте ще раз пізніше.",
  "error.connection.retry": "Оновити сторінку",
  "error.connection.title": "Не вдалося підключитися",
  "error.ws.message": "Не вдалося підключитися. Будь ласка, спробуйте ще раз.",
  "error.ws.title": "Помилка з'єднання",
  "header.newPost": "Новий пост",
  "ipfs.diag.cors.error": "Проблема з конфігурацією CORS.",
  "ipfs.diag.cors.name": "Перевірка CORS шлюзу",
  "ipfs.diag.cors.ok": "CORS налаштовано правильно.",
  "ipfs.diag.fetch.errorFirewall": "Запит не вдався через брандмауер.",
  "ipfs.diag.fetch.name": "Запит до живого шлюзу",
  "ipfs.diag.fetch.ok": "Запит успішний.",
  "ipfs.diag.fetch.warnSkipped": "Пропущено: ABI CID не знайдено у відповіді /info.",
  "ipfs.diag.fix.browser": "Якщо він працює, перевірте ваш браузер. Для Brave вимкніть Shields для цього сайту. Для інших браузерів, таких як Chrome, можливо, вам потрібно 'Дозволити небезпечний контент' у налаштуваннях сайту.",
  "ipfs.diag.fix.cors": "Якщо все ще не вдається, виконайте цю команду, щоб виправити політику CORS API:",
  "ipfs.diag.fix.daemon": "Спочатку переконайтеся, що ваш IPFS демон працює в терміналі:",
  "ipfs.diag.fix.gatewaySingleOrigin": "Опція 1 (Рекомендується): Дозволити лише поточний походження.",
  "ipfs.diag.fix.gatewayTitle": "Налаштування вашого шлюзу, ймовірно, заважає браузеру отримати доступ. Спробуйте одну з цих команд:",
  "ipfs.diag.fix.gatewayWildcard": "Опція 2 (Легше для розробників): Дозволити будь-яке походження. Використовуйте з обережністю на публічних вузлах.",
  "ipfs.diag.fix.title": "Щоб виправити, виконайте це у вашому терміналі (потім перезапустіть демон):",
  "ipfs.diag.liveness.error": "Вузол не відповідає.",
  "ipfs.diag.liveness.name": "Перевірка активності API",
  "ipfs.diag.liveness.ok": "Вузол активний.",
  "ipfs.diag.run": "Запустити діагностику",
  "ipfs.diag.title": "Діагностика вузла IPFS",
  "main.newContentAvailable": "Доступний новий контент!",
  "main.tabs.empty": "Ця вкладка поки що порожня.",
  "main.tabs.loading": "Завантаження вкладок…",
  "main.tabs.untitled": "Без назви",
  "newTab.category": "Категорія",
  "newTab.view.grid": "Сітка перегляду",
  "newTab.view.group": "Група перегляду",
  "newTab.view.list": "Список перегляду",
  "post.addComment": "Додати коментар...",
  "post.chapters.prologue": "Пролог",
  "post.chapters.title": "Зміст",
  "post.comments": "Коментарі",
  "post.loadMoreComments": "Завантажити більше коментарів",
  "post.noComments": "Коментарів ще немає.",
  "post.notFound.message": "Пост, який ви шукаєте, не існує або був видалений.",
  "post.notFound.title": "Пост не знайдено",
  "postcard.copyDataCid": "Копіювати Data CID",
  "postcard.copyDescriptorCid": "Копіювати Descriptor CID",
  "postcard.copySavvaCid": "Копіювати SAVVA CID",
  "postcard.pin": "Закріпити пост",
  "postcard.unpin": "Відкріпити пост",
  "reactions.${reactionType()}": "Реагувати з {reactionType}",
  "reactions.${type}": "Реакція {type}",
  "reactions.angry": "Злий",
  "reactions.clap": "👏 Аплодисменти",
  "reactions.dislike": "👎 Не подобається",
  "reactions.fire": "🔥",
  "reactions.ha_ha": "Ха-ха",
  "reactions.hot": "Гарячий",
  "reactions.laugh": "Ха-ха",
  "reactions.like": "Подобається",
  "reactions.love": "Люблю",
  "reactions.sad": "Сумно",
  "reactions.star": "⭐",
  "reactions.super": "🌟 Супер",
  "reactions.trophy": "Трофей",
  "reactions.wow": "Вау",
  "rightPane.language": "Мова",
  "rightPane.settings": "Налаштування",
  "rightPane.switch.backend.help": "Додаток отримає /info з цього URL, щоб перерахувати підтримувані домени.",
  "rightPane.switch.backend.label": "URL бекенду",
  "rightPane.switch.backend.placeholder": "https://example.com/api/",
  "rightPane.switch.domain.label": "Домен",
  "rightPane.switch.domain.website": "Вебсайт",
  "rightPane.switch.noDomains": "Бекенд не повернув доменів. Ви все ще можете подати заявку, але домен буде порожнім.",
  "rightPane.switch.open": "Переключити бекенд / домен",
  "rightPane.switch.reload": "Завантажити домени",
  "rightPane.switch.reload.title": "Отримати /info та оновити список доменів",
  "rightPane.switch.reset": "Скинути до значень за замовчуванням",
  "rightPane.switch.reset.title": "Очистити локальне переопределення та перезавантажити значення за замовчуванням з default_connect.yaml",
  "rightPane.switch.title": "Переключити бекенд / домен",
  "rightPane.switch.validation.protocol": "URL бекенду має починатися з http:// або https://",
  "rightPane.theme": "Тема",
  "settings.back": "Назад",
  "settings.dev.assets.baseUrl": "Базовий URL активів",
  "settings.dev.assets.configUrl": "URL конфігурації",
  "settings.dev.assets.configUrl.computed": "Обчислений URL",
  "settings.dev.assets.configUrl.open": "Відкрити URL конфігурації",
  "settings.dev.assets.diagnostics.default": "Конфігурація за замовчуванням",
  "settings.dev.assets.diagnostics.error": "Помилка діагностики",
  "settings.dev.assets.diagnostics.hasCategories": "Є категорії",
  "settings.dev.assets.diagnostics.hasConfig": "Є конфігурація",
  "settings.dev.assets.diagnostics.hasFavicon": "Виявлено фавікон",
  "settings.dev.assets.diagnostics.hasLocales": "Є локалі",
  "settings.dev.assets.diagnostics.hasLogos": "Є логотипи",
  "settings.dev.assets.diagnostics.hasTabs": "Є вкладки",
  "settings.dev.assets.diagnostics.noteNetwork": "Перевірте ваше мережеве з'єднання.",
  "settings.dev.assets.diagnostics.primary": "Основна конфігурація",
  "settings.dev.assets.diagnostics.run": "Запустити діагностику",
  "settings.dev.assets.diagnostics.sampleFetches": "Приклад запитів",
  "settings.dev.assets.diagnostics.title": "Діагностика активів",
  "settings.dev.assets.domain": "Домен",
  "settings.dev.assets.env": "Середовище",
  "settings.dev.assets.env.prod": "Продакшн",
  "settings.dev.assets.env.test": "Тест",
  "settings.dev.assets.prefix.active": "Активний префікс",
  "settings.dev.assets.prefix.computed": "Обчислений префікс",
  "settings.dev.assets.source": "Джерело",
  "settings.dev.assets.title": "Активи",
  "settings.developer.debug.enable": "Увімкнути журнал налагодження",
  "settings.developer.showKeys": "Показати API ключі",
  "settings.developer.title": "Налаштування розробника",
  "settings.ipfs.localDisabled": "Локальний IPFS вимкнено",
  "settings.localIpfs.apiUrl.label": "URL API локального IPFS",
  "settings.localIpfs.disable": "Вимкнути",
  "settings.localIpfs.enableCheckbox": "Використовувати локальний вузол IPFS",
  "settings.localIpfs.gateway.label": "Шлюз",
  "settings.localIpfs.status.label": "Статус",
  "settings.localIpfs.testEnable": "Перевірити та увімкнути",
  "settings.localIpfs.title": "Локальний IPFS",
  "settings.title": "Налаштування",
  "stakerLevels.${l.key}": "Рівень стейкера {l.key}",
  "stakerLevels.clam": "Молюск",
  "stakerLevels.dolphin": "Дельфін",
  "stakerLevels.fish": "Риба",
  "stakerLevels.guest": "Гість",
  "stakerLevels.orca": "Косатка",
  "stakerLevels.seahorse": "Морський кінь",
  "stakerLevels.shark": "Акула",
  "stakerLevels.shrimp": "Креветка",
  "stakerLevels.stingray": "Скат",
  "stakerLevels.whale": "Кит",
  "tabs.aria": "Вкладки розділів",
  "tabs.title.${slug(tab.type)}": "Вкладка: {tab.type}",
  "tabs.title.actual": "Поточні",
  "tabs.title.comments": "Коментарі",
  "tabs.title.for-you": "Для вас",
  "tabs.title.leaders": "Лідери",
  "tabs.title.new": "Нові",
  "time.day.plural": "__N__ днів тому",
  "time.day.singular": "__N__ день тому",
  "time.hour.plural": "__N__ годин тому",
  "time.hour.singular": "__N__ годину тому",
  "time.minute.plural": "__N__ хвилин тому",
  "time.minute.singular": "__N__ хвилину тому",
  "time.now": "Зараз",
  "timeFrame.${frame}": "Часовий проміжок: {frame}",
  "timeFrame.all": "Весь час",
  "timeFrame.month": "Місяць",
  "timeFrame.week": "Тиждень",
  "timeFrame.year": "Рік",
  "ui.mode.dark": "Темний режим",
  "ui.mode.light": "Світлий режим",
  "ui.toTop": "Назад до верху",
  "wallet.changeChain": "Змінити мережу",
  "wallet.connect": "Підключити гаманець",
  "wallet.copyAddress": "Копіювати адресу",
  "wallet.error.userCanceled": "Транзакцію скасовано.",
  "wallet.onRequiredNetwork": "На потрібній мережі"
};
</file>

<file path="src/index.css">
/* src/index.css */
@import "tailwindcss";
@import "./styles/tabs.css";
@import "./styles/themed-controls.css";
@import "./styles/layout.css";
@import "../public/domain_default/domain.css";

/* Custom utility for multi-line truncation */
.line-clamp-2 {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
}

.line-clamp-3 {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
  overflow: hidden;
}

/* Animation for the post fund badge */
@keyframes bounce-short {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-50%);
  }
}

.animate-bounce-short {
  animation: bounce-short 0.3s ease-in-out;
}

/* General purpose update animation */
@keyframes default-update-animation {
  0% {
    transform: translateY(0);
    opacity: 1;
  }
  49% {
    transform: translateY(50%);
    opacity: 0;
  }
  50% {
    transform: translateY(-50%);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}

.default-animation {
  animation: default-update-animation 0.4s ease-in-out;
}
</file>

<file path="src/alerts/handlers.js">
// src/alerts/handlers.js
import { dbg } from "../utils/debug";
import { getDraftParams, clearDraft, DRAFT_DIRS } from "../editor/storage.js";
import { pushToast } from "../ui/toast";

export function handleTokenPriceChanged(app, payload) {
  dbg.log("Alerts:token_price_changed", payload);
  app.updateTokenPrices?.(payload.data);
}

export async function handleContentProcessed(app, payload) {
  const { content } = payload.data || {};
  if (!content || !content.guid) {
    return;
  }

  dbg.log("Alerts:content_processed", "Handler triggered with content:", content);

  const draftParams = await getDraftParams(DRAFT_DIRS.NEW_POST);
  if (draftParams && draftParams.guid === content.guid) {
    await clearDraft(DRAFT_DIRS.NEW_POST);
    pushToast({ type: "success", message: app.t("editor.publish.draftCleared") });
  }

  const currentItems = app.newFeedItems();
  const isAlreadyVisible = currentItems.some(item => item.id === content.savva_cid);
  
  if (!isAlreadyVisible && content.content_type === 'post') {
    app.setNewContentAvailable(content);
  }
}

export function handleCommentCounterUpdate(app, payload) {
    dbg.log("Alerts:comment_counter", "Received comment counter alert", payload);
    const { savva_cid, n } = payload.data || {};
    if (!savva_cid) return;

    app.setPostUpdate({
        cid: savva_cid,
        type: 'commentCountChanged',
        data: {
            newTotal: n,
        }
    });
}

export function handlePing(app) {
  dbg.log("Alerts:ping", "Received ping, sending pong.");
  app.ws?.sendJson({ type: 'pong' });
}

export function handlePong() {
  dbg.log("Alerts:pong", "Received pong.");
  // Do nothing
}

export function handleReact(app, payload) {
  dbg.log("Alerts:react", "Received react alert", payload);
  
  const currentDomain = app.selectedDomainName()?.toLowerCase();
  const alertDomain = payload?.domain?.toLowerCase();

  if (alertDomain === currentDomain) {
    const d = payload.data;
    // Emit a specific event with only the changed data
    app.setPostUpdate({
      cid: d?.object_id,
      type: 'reactionsChanged',
      data: {
        reactions: d?.reactions,
        reaction: d?.reaction,
        user: d?.user?.address,
      }
    });
  } else {
    dbg.log("Alerts:react", `Ignoring react alert for different domain. App: ${currentDomain}, Alert: ${alertDomain}`);
  }
}
</file>

<file path="src/components/Header.jsx">
// src/components/Header.jsx
import { Show, createSignal, onMount, createMemo, Switch, Match } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import { connectWallet, walletAccount, walletChainId, isWalletAvailable, eagerConnect } from "../blockchain/wallet";
import { authorize } from "../blockchain/auth.js";
import { pushErrorToast } from "../ui/toast.js";
import { getChainLogo } from "../blockchain/chainLogos";
import BrandLogo from "./ui/BrandLogo.jsx";
import Container from "./layout/Container";
import AuthorizedUser from "./auth/AuthorizedUser.jsx";
import NewPostButton from "./main/NewPostButton.jsx";
import TokenPrice from "./main/TokenPrice.jsx";

function shortAddr(addr) {
  if (!addr) return "";
  return addr.slice(0, 6) + "…" + addr.slice(-4);
}

export default function Header({ onTogglePane }) {
  const app = useApp();
  const { t } = app;
  const [eagerDone, setEagerDone] = createSignal(false);
  const [isLoggingIn, setIsLoggingIn] = createSignal(false);

  const desiredId = () => app.desiredChainId();
  const mismatchedChain = () =>
    walletChainId() != null &&
    desiredId() != null &&
    walletChainId() !== desiredId();

  const isAddressMismatched = createMemo(() => {
    const walletAcc = walletAccount();
    const authorizedAcc = app.authorizedUser()?.address;
    if (!authorizedAcc || !walletAcc) return false;
    return walletAcc.toLowerCase() !== authorizedAcc.toLowerCase();
  });

  onMount(async () => {
    if (isWalletAvailable()) await eagerConnect();
    setEagerDone(true);
  });

  const handleLoginClick = async () => {
    setIsLoggingIn(true);
    try {
      await authorize(app);
    } catch (e) {
      console.error("Authorization failed:", e);
      pushErrorToast(e, { context: "Login failed" });
    } finally {
      setIsLoggingIn(false);
    }
  };

  async function onConnect() {
    try {
      await connectWallet();
      if (desiredId()) await app.ensureWalletOnDesiredChain();
    } catch (e) {
      pushErrorToast(e, { context: "Failed to connect wallet" });
    }
  }

  async function copyAddress() {
    try {
      await navigator.clipboard.writeText(walletAccount());
    } catch (e) {
      console.error("Failed to copy address:", e);
    }
  }

  async function onSwitchChain() {
    try {
      await app.ensureWalletOnDesiredChain();
    } catch (e) {
      pushErrorToast(e, { context: "Failed to switch chain" });
    }
  }

  const chainLogoSrc = () => getChainLogo(desiredId());

  return (
    <header class="sticky top-0 z-10 bg-[hsl(var(--background))] text-[hsl(var(--foreground))] shadow-sm">
      <Container>
        <div class="h-12 px-2 flex items-center justify-between">
          <div class="flex items-center gap-4">
            <BrandLogo class="h-6 sm:h-7" classTitle="text-xl font-bold text-[hsl(var(--card-foreground))]" />
            <TokenPrice />
          </div>

          <div class="flex items-center gap-3">
            {/* Show New Post button ONLY when authorized AND wallet is connected */}
            <Show when={app.authorizedUser() && walletAccount()}>
              <NewPostButton />
            </Show>

            {/* Show user avatar menu if a session exists, regardless of wallet connection */}
            <Show when={app.authorizedUser()}>
              <AuthorizedUser />
            </Show>

            {/* Logic for Connect/Login buttons */}
            <Switch>
              {/* Wallet not connected -> Show "Connect" button */}
              <Match when={!walletAccount() && eagerDone()}>
                <Show when={isWalletAvailable()}>
                  <button class="px-3 py-1.5 text-sm rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] hover:opacity-90" onClick={onConnect}>
                    {t("wallet.connect")}
                  </button>
                </Show>
              </Match>

              {/* Wallet connected BUT no session -> Show "Login" button */}
              <Match when={walletAccount() && !app.authorizedUser()}>
                <button class="px-3 py-1.5 text-sm rounded bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] hover:opacity-90 disabled:opacity-70" onClick={handleLoginClick} disabled={isLoggingIn()}>
                  {isLoggingIn() ? t("common.checking") : "Login"}
                </button>
              </Match>
            </Switch>

            {/* Wallet address and chain info */}
            <Show when={walletAccount()}>
                <div class="flex items-center gap-2">
                    <button
                        classList={{
                            "px-2 py-1 rounded bg-[hsl(var(--muted))] text-[hsl(var(--muted-foreground))] hover:bg-[hsl(var(--accent))] hover:text-[hsl(var(--accent-foreground))]": true,
                            "border-2 border-[hsl(var(--destructive))]": isAddressMismatched()
                        }}
                        onClick={copyAddress}
                        title={t("wallet.copyAddress")}
                    >
                        {shortAddr(walletAccount())}
                    </button>
                    <Show when={!mismatchedChain()} fallback={
                        <button class="px-2 py-1 rounded bg-[hsl(var(--destructive))] text-[hsl(var(--destructive-foreground))] hover:opacity-90" onClick={onSwitchChain}>
                            {t("wallet.changeChain")}
                        </button>
                    }>
                        <Show when={chainLogoSrc()}>
                            <img src={chainLogoSrc()} alt="chain" class="w-5 h-5" title={t("wallet.onRequiredNetwork")} />
                        </Show>
                    </Show>
                </div>
            </Show>

            {/* Hamburger menu */}
            <button class="p-1 rounded transition text-[hsl(var(--muted-foreground))] hover:bg-[hsl(var(--muted))]" onClick={onTogglePane}>
              <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
            </button>
          </div>
        </div>
      </Container>
    </header>
  );
}
</file>

<file path="src/components/RightPane.jsx">
// src/components/RightPane.jsx
import { createSignal, Show, createMemo, createEffect } from "solid-js";
import { navigate } from "../routing/hashRouter";
import { useApp } from "../context/AppContext.jsx";
import SwitchConnectDialog from "./SwitchConnectDialog.jsx";
import ThemeToggle from "./ui/ThemeToggle.jsx";
import LangSelector from "./ui/LangSelector.jsx";
import RightPaneFooter from "./RightPaneFooter.jsx";
import { dbg } from "../utils/debug.js";

export default function RightPane({ isOpen, onClose }) {
  const app = useApp();
  const { t } = app;
  const [showSwitch, setShowSwitch] = createSignal(false);

  const handlePanelClick = (e) => { if (e.target === e.currentTarget) onClose(); };

  const domainLangCodes = createMemo(() => {
    const config = app.domainAssetsConfig?.();
    if (!config || !Array.isArray(config.locales)) {
      dbg.log("RightPane", "domainLangCodes is EMPTY because config is missing or invalid.");
      return [];
    }
    const codes = config.locales.map((l) => l.code).filter(Boolean);
    dbg.log("RightPane", "domainLangCodes calculated:", codes);
    return codes;
  });

  const showLangSelector = createMemo(() => domainLangCodes().length > 1);

  createEffect(() => {
    const availableCodes = domainLangCodes();
    const currentLang = app.lang?.();
    dbg.log("RightPaneEffect", "Running check...", { currentLang, availableCodes: [...availableCodes] });

    if (availableCodes.length === 0) {
      dbg.log("RightPaneEffect", "-> SKIPPING: No available codes yet.");
      return;
    }

    if (!availableCodes.includes(currentLang)) {
      dbg.warn("RightPaneEffect", `-> MISMATCH! Lang '${currentLang}' is not in [${availableCodes.join(", ")}]. Resetting to '${availableCodes[0]}'.`);
      app.setLang?.(availableCodes[0]);
    } else {
      dbg.log("RightPaneEffect", `-> OK: Lang '${currentLang}' is valid.`);
    }
  });

  return (
    <>
      <div
        class={`fixed top-0 right-0 w-64 h-full bg-[hsl(var(--popover))] text-[hsl(var(--popover-foreground))] shadow-lg z-40 ${isOpen() ? "right-0" : "right-[-256px]"} transition-all duration-300`}
        onClick={handlePanelClick}
        data-testid="right-pane"
        style="border-left: 1px solid hsl(var(--border));"
      >
        <div class="h-full flex flex-col p-4 space-y-3">
          <nav class="pt-2">
            <ul class="space-y-3">
              <li><ThemeToggle /></li>

              <Show when={showLangSelector()}>
                <li><LangSelector codes={domainLangCodes()} /></li>
              </Show>

              {/* Gear settings link */}
              <Show when={app.config()?.gear}>
                <li>
                  <div
                    class="px-2  rounded cursor-pointer hover:bg-[hsl(var(--accent)))]"
                    role="button" tabIndex={0}
                    onClick={() => setShowSwitch(true)}
                    onKeyDown={(e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); setShowSwitch(true); } }}
                  >
                    {t("rightPane.switch.open")}
                  </div>
                </li>
              </Show>

              {/* Documentation link */}
              <li>
                <div
                  class="px-2  rounded cursor-pointer hover:bg-[hsl(var(--accent)))]"
                  role="button" tabIndex={0}
                  onClick={() => {
                    app.setSavedScrollY(window.scrollY);
                    navigate("/docs"); 
                    onClose(); 
                  }}
                  onKeyDown={(e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); app.setSavedScrollY(window.scrollY); navigate("/docs"); onClose(); } }}
                  aria-label={t("docs.nav")}
                  title={t("docs.nav")}
                >
                  {t("docs.nav")}
                </div>
              </li>

              {/* Settings link */}
              <li>
                <div
                  class="px-2 rounded cursor-pointer hover:bg-[hsl(var(--accent)))]"
                  role="button" tabIndex={0}
                  onClick={() => {
                    app.setSavedScrollY(window.scrollY);
                    navigate("/settings"); 
                    onClose(); 
                  }}
                  onKeyDown={(e) => { if (e.key === "Enter" || e.key === " ") { e.preventDefault(); app.setSavedScrollY(window.scrollY); navigate("/settings"); onClose(); } }}
                >
                  {t("rightPane.settings")}
                </div>
              </li>
            </ul>
          </nav>
          <RightPaneFooter />
        </div>
      </div>

      {isOpen() && (
        <div
          class="fixed inset-0 z-20"
          style={{ "background-color": "rgba(0,0,0,0.2)" }}
          data-testid="overlay"
          onClick={onClose}
        />
      )}

      <Show when={showSwitch()} keyed>
        <SwitchConnectDialog
          open={true}
          domain={app.config()?.domain}
          backendLink={app.config()?.backendLink}
          loading={app.loading()}
          error={app.error()}
          onApply={() => { }}
          onReset={app.clearConnectOverride}
          onClose={() => setShowSwitch(false)}
        />
      </Show>
    </>
  );
}
</file>

<file path="src/components/docs/MarkdownView.jsx">
// src/components/docs/MarkdownView.jsx
import { createEffect, onCleanup, createSignal, onMount } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import { dbg } from "../../utils/debug.js";
import { rehypeMediaPlayers } from "../../docs/rehype-media-players.js";
import rehypeSlug from "rehype-slug";
import rehypeAutolinkHeadings from "rehype-autolink-headings";
import rehypePrettyCode from "rehype-pretty-code";
import remarkBreaks from "remark-breaks";

export default function MarkdownView(props) {
  const { t } = useApp();
  const [html, setHtml] = createSignal("");
  let disposed = false;
  let container;

  const renderMd = async () => {
    if (disposed) return;
    try {
      const [
        { unified }, { default: remarkParse }, { default: remarkGfm },
        { default: remarkRehype }, { default: rehypeStringify }, { default: DOMPurify },
        { visit }
      ] = await Promise.all([
        import("unified"), import("remark-parse"), import("remark-gfm"),
        import("remark-rehype"), import("rehype-stringify"), import("dompurify"),
        import("unist-util-visit")
      ]);
  
      const rehypeCopyButton = () => (tree) => {
        visit(tree, "element", (node) => {
          if (node.tagName !== "pre" || node.children.some(c => c.properties?.className?.includes("sv-copy-btn"))) return;
          node.children.push({
            type: "element", tagName: "button",
            properties: { className: ["sv-copy-btn"], type: "button" },
            children: [{ type: "text", value: "Copy" }],
          });
        });
        return tree;
      };
      
      DOMPurify.addHook("uponSanitizeElement", (node, data) => {
        if (data.tagName === 'iframe' || data.tagName === 'video' || data.tagName === 'audio') {
          if (!node.hasAttribute('src')) node.remove();
        }
      });
  
      const processor = unified()
        .use(remarkParse)
        .use(remarkGfm)
        .use(remarkBreaks)
        .use(remarkRehype, { allowDangerousHtml: true });
  
      if (props.rehypePlugins) {
        for (const plugin of props.rehypePlugins) {
          processor.use(...(Array.isArray(plugin) ? plugin : [plugin]));
        }
      }
  
      processor
        .use(rehypeMediaPlayers)
        .use(rehypeSlug)
        .use(rehypeCopyButton)
        .use(rehypeStringify, { allowDangerousHtml: true });
  
      const file = await processor.process(String(props.markdown || ""));
      const rawHtml = String(file);
      
      const safe = DOMPurify.sanitize(rawHtml, {
        ADD_TAGS: ["iframe", "video", "audio"],
        ADD_ATTR: ["allowfullscreen", "frameborder", "controls", "style", "src"],
        ALLOWED_URI_REGEXP: /^(?:(?:https?|mailto|tel|ftp|cid|xmpp|blob):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
      });
  
      if (!disposed) setHtml(safe);
  
    } catch (err) {
      dbg.error("MarkdownView", "Markdown rendering failed:", err);
      const safeErr = String(err?.message || err).replace(/&/g, "&amp;").replace(/</g, "&lt;");
      const errorHtml = `<div style="color: red; border: 1px solid red; padding: 1rem;"><strong>Error:</strong><pre>${safeErr}</pre></div>`;
      if (!disposed) setHtml(errorHtml);
    }
  };

  function copy(text) {
    if (!text) return;
    try {
      navigator.clipboard.writeText(text);
    } catch (e) {
      console.error("Failed to copy text:", e);
    }
  }

  function onClick(e) {
    const btn = e.target.closest(".sv-copy-btn");
    if (!btn) return;
    const pre = btn.closest("pre");
    if (!pre) return;

    const codeNode = pre.querySelector("code");
    if (codeNode) {
      copy(codeNode.innerText);
      btn.textContent = t("clipboard.copied");
      setTimeout(() => { btn.textContent = t("clipboard.copy"); }, 2000);
    }
  }

  function relabelButtons() {
    if (!container) return;
    const buttons = container.querySelectorAll(".sv-copy-btn");
    buttons.forEach(btn => { btn.textContent = t("clipboard.copy"); });
  }

  // This effect now re-runs when markdown OR the plugins change.
  createEffect(async () => {
    props.markdown; // dependency
    props.rehypePlugins; // dependency
    
    await renderMd();
    relabelButtons();
  });

  onMount(() => {
    container?.addEventListener("click", onClick);
  });
  
  onCleanup(() => {
    disposed = true;
    container?.removeEventListener("click", onClick);
  });

  return (
    <article
      ref={(el) => (container = el)}
      class="sv-docs prose prose-sm md:prose-base max-w-none"
      innerHTML={html()}
      aria-label={t("docs.article")}
    />
  );
}
</file>

<file path="src/components/tabs/NewTab.jsx">
// src/components/tabs/NewTab.jsx
import { createMemo, createResource, createSignal, Show, For, createEffect } from "solid-js";
import ContentFeed from "../feed/ContentFeed.jsx";
import { useApp } from "../../context/AppContext.jsx";
import { loadAssetResource } from "../../utils/assetLoader";
import ViewModeToggle, { viewMode } from "../ui/ViewModeToggle.jsx";
import { toChecksumAddress } from "../../blockchain/utils.js";
import { dbg } from "../../utils/debug.js";
import { whenWsOpen } from "../../net/wsRuntime.js";
import { getDraftParams, clearDraft, DRAFT_DIRS } from "../../editor/storage.js";
import { pushToast } from "../../ui/toast.js";

function useDomainCategories(app) {
  const cfg = () => app.domainAssetsConfig?.();
  const relPath = createMemo(() => cfg()?.modules?.categories || null);
  const lang = () => (app.lang?.() || "en").toLowerCase();
  const params = createMemo(() => ({ rel: relPath(), lang: lang() }));
  const [cats] = createResource(params, async ({ rel, lang }) => {
    if (!rel) return [];
    try {
      const data = await loadAssetResource(app, rel, { type: "yaml" });
      const listByLang = data?.locales?.[lang] || data?.locales?.en || [];
      return (Array.isArray(listByLang) ? listByLang : []).map(String);
    } catch (err) {
      console.error(`Failed to load categories from ${rel}:`, err);
      return [];
    }
  });
  return cats;
}

export default function NewTab(props) {
  const app = useApp();
  const lang = createMemo(() => (app.lang?.() || "en").toLowerCase());
  const [category, setCategory] = createSignal("ALL");
  const categoriesRes = useDomainCategories(app);
  const categoriesWithAll = createMemo(() => ["ALL", ...(categoriesRes() || [])]);

  createEffect(() => {
    const newList = categoriesRes();
    const currentSelection = category();
    if (newList && currentSelection !== "ALL" && !newList.includes(currentSelection)) {
      setCategory("ALL");
    }
  });

  const domainName = () => {
    const d = app.selectedDomain?.();
    return typeof d === "string" ? d : d?.name || "";
  };
  const contentList = app.wsMethod ? app.wsMethod("content-list") : null;

  const feedResetKey = createMemo(() => `${domainName()}|${category()}|${app.newTabRefreshKey()}`);

  async function fetchPage(page, pageSize) {
    const limit = pageSize;
    const offset = (page - 1) * pageSize;
    try {
      dbg.log('NewTab', `fetchPage called for page ${page}. WS Status: ${app.wsStatus()}`);
      await whenWsOpen();
      dbg.log("NewTab", "after whenWsOpen");

      if (!contentList) {
        dbg.warn('NewTab', 'wsMethod("content-list") is not available at fetch time.');
        return [];
      }
      const params = { domain: domainName(), content_type: "post", limit, offset, lang: lang() };
      const cat = category();
      if (cat && cat !== "ALL") {
        params.category = `${lang()}:${cat}`;
      }

      const user = app.authorizedUser();
      if (user?.address) {
        params.my_addr = toChecksumAddress(user.address);
      }

      dbg.log('NewTab', 'Fetching with params:', params);
      const res = await contentList(params);
      const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];

      const draftParams = await getDraftParams(DRAFT_DIRS.NEW_POST);
      if (draftParams?.guid) {
        const newPostsHaveDraftGuid = arr.some(post => post.guid === draftParams.guid);
        if (newPostsHaveDraftGuid) {
          await clearDraft(DRAFT_DIRS.NEW_POST);
          pushToast({ type: "success", message: app.t("editor.publish.draftCleared") });
        }
      }

      return arr.map((it) => ({
        id: it?.savva_cid || it?.savvaCID || it?.id,
        _raw: it,
      }));
    } catch (err) {
      dbg.error('NewTab', "fetchPage error:", err);
      return [];
    }
  }

  return (
    <section class="w-full">
      <div class="mb-3 flex items-center gap-3">
        <ViewModeToggle size="md" />
        <div class="ml-auto flex items-center gap-2 min-w-[220px]">
          <span class="text-xs opacity-70">{app.t("newTab.category")}</span>
          <select
            class="flex-1 px-3 h-9 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
            value={category()}
            onInput={(e) => setCategory(e.currentTarget.value)}
            aria-label={app.t("newTab.category")}
          >
            <For each={categoriesWithAll()}>
              {(c) => <option value={c}>{c === "ALL" ? app.t("categories.all") : c}</option>}
            </For>
          </select>
          <Show when={categoriesRes.loading}>
            <div class="text-xs opacity-70">{app.t("common.loading")}</div>
          </Show>
        </div>
      </div>
      <ContentFeed
        mode={viewMode()}
        fetchPage={fetchPage}
        pageSize={12}
        resetOn={feedResetKey()}
        isRailVisible={props.isRailVisible}
        onItemsChange={app.setNewFeedItems}
        isActivated={props.isActivated}
      />
    </section>
  );
}
</file>

<file path="src/editor/storage.js">
// src/editor/storage.js
import { dbg } from "../utils/debug";
import { parse, stringify } from "yaml";
import { createTextPreview } from "./preview-utils.js";

export const DRAFT_DIRS = {
  NEW_POST: "new_post",
  NEW_COMMENT: "new_comment",
  EDIT: "edit",
  UPLOADS: "uploads",
};
const PARAMS_FILE = "params.json";

async function getDirectoryHandle(path) {
  try {
    if (!navigator.storage || !navigator.storage.getDirectory) {
      dbg.warn("storage", "Origin Private File System API not available.");
      return null;
    }
    const root = await navigator.storage.getDirectory();
    let currentHandle = root;
    for (const part of path.split('/').filter(Boolean)) {
      currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
    }
    return currentHandle;
  } catch (e) {
    dbg.error("storage", `Failed to get directory handle for '${path}'`, e);
    throw e;
  }
}

async function readFile(dirHandle, path) {
  if (!dirHandle) return null;
  try {
    const pathParts = path.split('/').filter(Boolean);
    let currentHandle = dirHandle;
    for (let i = 0; i < pathParts.length - 1; i++) {
      currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
    }
    const fileName = pathParts[pathParts.length - 1];
    const fileHandle = await currentHandle.getFileHandle(fileName);
    const file = await fileHandle.getFile();
    return await file.text();
  } catch (e) {
    if (e.name === 'NotFoundError') return null;
    dbg.error("storage", `Failed to read file: ${path}`, e);
    throw e;
  }
}

export async function writeFile(dirHandle, path, content) {
  if (!dirHandle) return;
  try {
    const pathParts = path.split('/').filter(Boolean);
    let currentHandle = dirHandle;
    for (let i = 0; i < pathParts.length - 1; i++) {
      currentHandle = await currentHandle.getDirectoryHandle(pathParts[i], { create: true });
    }
    const fileName = pathParts[pathParts.length - 1];
    const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(content);
    await writable.close();
  } catch (e) {
    dbg.error("storage", `Failed to write file: ${path}`, e);
    throw e;
  }
}

export async function listUploadedFiles(baseDir) {
  const uploadsDirHandle = await getDirectoryHandle(`${baseDir}/${DRAFT_DIRS.UPLOADS}`);
  if (!uploadsDirHandle) return [];
  
  const files = [];
  for await (const entry of uploadsDirHandle.values()) {
    if (entry.kind === 'file') {
      const file = await entry.getFile();
      const url = URL.createObjectURL(file);
      files.push({ name: entry.name, url, size: file.size });
    }
  }
  return files;
}

export async function addUploadedFile(baseDir, file) {
  const uploadsDirHandle = await getDirectoryHandle(`${baseDir}/${DRAFT_DIRS.UPLOADS}`);
  await writeFile(uploadsDirHandle, file.name, file);
}

export async function addUploadedFileFromUrl(baseDir, url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const blob = await response.blob();
    
    let fileName;
    try {
      const decodedUrl = decodeURIComponent(url);
      const urlObj = new URL(decodedUrl);
      
      let name = urlObj.pathname.substring(urlObj.pathname.lastIndexOf('/') + 1);
      const filenameParam = urlObj.searchParams.get('filename');
      if (name && !name.includes('.') && filenameParam && filenameParam.startsWith('.')) {
        name += filenameParam;
      }
      fileName = (name || "downloaded_file").replace(/[^a-zA-Z0-9._-]/g, '_');

    } catch (e) {
      const decodedUrl = decodeURIComponent(url);
      const cleanUrl = decodedUrl.split('?')[0].split('#')[0];
      let name = cleanUrl.substring(cleanUrl.lastIndexOf('/') + 1);
      fileName = (name || "downloaded_file").replace(/[^a-zA-Z0-9._-]/g, '_');
    }

    const file = new File([blob], fileName, { type: blob.type });
    await addUploadedFile(baseDir, file);
    return file;
  } catch (error) {
    dbg.error("storage", "Failed to upload from URL", { url, error });
    throw error;
  }
}

export async function deleteUploadedFile(baseDir, fileName) {
  try {
    const uploadsDirHandle = await getDirectoryHandle(`${baseDir}/${DRAFT_DIRS.UPLOADS}`);
    if (!uploadsDirHandle) return;
    await uploadsDirHandle.removeEntry(fileName);
    dbg.log("storage", `Deleted file: ${fileName} from ${baseDir}`);
  } catch (error) {
    dbg.error("storage", `Failed to delete file: ${fileName} from ${baseDir}`, error);
    throw error;
  }
}

export async function resolveDraftFileUrl(baseDir, relativePath) {
  if (!relativePath) return null;
  try {
    const dirHandle = await getDirectoryHandle(baseDir);
    const pathParts = relativePath.split('/').filter(Boolean);
    let currentHandle = dirHandle;
    for (let i = 0; i < pathParts.length - 1; i++) {
      currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
    }
    const fileName = pathParts[pathParts.length - 1];
    const fileHandle = await currentHandle.getFileHandle(fileName);
    const file = await fileHandle.getFile();
    return URL.createObjectURL(file);
  } catch (e) {
    if (e.name !== 'NotFoundError') {
      dbg.error("storage", `Failed to resolve draft file URL for ${relativePath} in ${baseDir}`, e);
    }
    return null;
  }
}

export async function getAllUploadedFileNames(baseDir) {
  const uploadsDirHandle = await getDirectoryHandle(`${baseDir}/${DRAFT_DIRS.UPLOADS}`);
  if (!uploadsDirHandle) return [];
  
  const names = [];
  for await (const entry of uploadsDirHandle.values()) {
    if (entry.kind === 'file') {
      names.push(entry.name);
    }
  }
  return names;
}

export async function getUploadedFileAsFileObject(baseDir, fileName) {
  try {
    const uploadsDirHandle = await getDirectoryHandle(`${baseDir}/${DRAFT_DIRS.UPLOADS}`);
    if (!uploadsDirHandle) return null;
    
    const fileHandle = await uploadsDirHandle.getFileHandle(fileName);
    return await fileHandle.getFile();
  } catch (e) {
    if (e.name !== 'NotFoundError') {
      dbg.error("storage", `Failed to get File object for ${fileName} in ${baseDir}`, e);
    }
    return null;
  }
}

export async function loadDraft(baseDir) {
  dbg.log("storage", `Loading draft from '${baseDir}'...`);
  const dirHandle = await getDirectoryHandle(baseDir);
  const descriptorYaml = await readFile(dirHandle, "info.yaml");
  const paramsJson = await readFile(dirHandle, PARAMS_FILE);

  const postData = {};
  const params = paramsJson ? JSON.parse(paramsJson) : {};

  if (descriptorYaml) {
    const descriptor = parse(descriptorYaml);
    for (const lang in descriptor.locales) {
      const localeData = descriptor.locales[lang];
      postData[lang] = { title: localeData.title || "", body: "", chapters: [] };
      
      if (localeData.data_path) {
        postData[lang].body = await readFile(dirHandle, localeData.data_path) || "";
      }
      
      if (Array.isArray(localeData.chapters)) {
        for (let i = 0; i < localeData.chapters.length; i++) {
          const chapterDesc = localeData.chapters[i];
          const chapterBody = await readFile(dirHandle, chapterDesc.data_path) || "";
          postData[lang].chapters.push({ body: chapterBody });
        }
      }
    }
  }

  const draft = {
    content: Object.keys(postData).length > 0 ? postData : { en: { title: "", body: "", chapters: [] } },
    params: params
  };

  if (!draft.content && !Object.keys(draft.params).length) {
    dbg.log("storage", `No draft found in '${baseDir}'.`);
    return null;
  }

  dbg.log("storage", `Draft loaded successfully from '${baseDir}'.`, draft);
  return draft;
}

export async function getDraftParams(baseDir) {
  try {
    const dirHandle = await getDirectoryHandle(baseDir);
    const paramsJson = await readFile(dirHandle, PARAMS_FILE);
    return paramsJson ? JSON.parse(paramsJson) : null;
  } catch (e) {
    if (e.name !== 'NotFoundError') {
      dbg.error("storage", `Failed to get draft params from '${baseDir}'`, e);
    }
    return null;
  }
}

export async function saveDraft(baseDir, draftData) {
  dbg.log("storage", `Saving draft to '${baseDir}'...`, draftData);
  const dirHandle = await getDirectoryHandle(baseDir);
  
  const { content, params } = draftData;

  const finalParams = JSON.parse(JSON.stringify(params || {}));
  if (!finalParams.locales) finalParams.locales = {};

  const descriptor = {
    savva_spec_version: "2.0",
    mime_type: "text/markdown",
    locales: {}
  };

  if (content) {
    for (const lang in content) {
      const data = content[lang];
      const dataPath = `${lang}/data.md`;
      
      descriptor.locales[lang] = {
        title: data.title || "",
        text_preview: createTextPreview(data.body || ""),
        data_path: dataPath,
        chapters: []
      };

      if (!finalParams.locales[lang]) finalParams.locales[lang] = { chapters: [] };
      
      await writeFile(dirHandle, dataPath, data.body || "");

      if (Array.isArray(data.chapters)) {
        for (let i = 0; i < data.chapters.length; i++) {
          const chapterContent = data.chapters[i];
          const chapterPath = `${lang}/chapters/${i + 1}.md`;
          
          descriptor.locales[lang].chapters.push({ data_path: chapterPath });
          
          await writeFile(dirHandle, chapterPath, chapterContent.body || "");
        }
      }
    }
    await writeFile(dirHandle, "info.yaml", stringify(descriptor));
  }
  
  await writeFile(dirHandle, PARAMS_FILE, JSON.stringify(finalParams, null, 2));
  dbg.log("storage", `Draft saved successfully to '${baseDir}'.`);
}

export async function clearDraft(baseDir) {
  dbg.log("storage", `Clearing draft directory '${baseDir}'...`);
  try {
    if (navigator.storage && navigator.storage.getDirectory) {
      const root = await navigator.storage.getDirectory();
      await root.removeEntry(baseDir, { recursive: true });
      dbg.log("storage", `Cleared draft directory '${baseDir}' from OPFS.`);
    }
  } catch (e) {
    if (e.name !== 'NotFoundError') {
      dbg.error("storage", `Failed to clear draft directory '${baseDir}'`, e);
    }
  }
}
</file>

<file path="src/i18n/ru.js">
// Auto-generated by scripts/i18n.mjs. Do not edit by hand.
export default {
  "app.versionLabel": "Версия",
  "brand.name": "SAVVA",
  "categories.all": "Все категории",
  "clipboard.copied": "Скопировано в буфер обмена!",
  "clipboard.copy": "Копировать",
  "comment.reply": "Ответить",
  "comment.showLess": "Скрыть",
  "comment.showMore": "Показать больше",
  "commentsTab.replyTo": "В ответ на:",
  "common.apply": "Применить",
  "common.applying": "Применение…",
  "common.cancel": "Отмена",
  "common.checking": "Проверка…",
  "common.confirm": "Подтвердить",
  "common.error": "Ошибка",
  "common.exists": "Существует",
  "common.fail": "Ошибка",
  "common.loading": "Загрузка…",
  "common.notFound": "Не найдено",
  "common.ok": "ОК",
  "common.remove": "Удалить",
  "common.retry": "Попробовать снова",
  "default.avatar": "Аватар",
  "default.user": "Пользователь",
  "delete.confirm.${type}.title": "Подтвердите удаление",
  "delete.confirm.confirm": "Удалить",
  "delete.confirm.deleting": "Удаление...",
  "delete.confirm.message": "Это скроет контент, но удалить его из блокчейна нельзя. Это действие нельзя отменить. Вы уверены?",
  "delete.toast.error": "Не удалось отправить транзакцию удаления.",
  "delete.toast.success": "Удаление отправлено. Оно будет скрыто после обработки транзакции на сервере.",
  "docs.article": "Статья документации",
  "docs.nav": "Документация",
  "docs.next": "Вперед",
  "docs.prev": "Назад",
  "docs.section": "Раздел",
  "docs.sidebar.empty": "Доков пока нет. Добавьте sidebar.yaml в dev_docs/<lang>/",
  "docs.title": "Документация разработчика",
  "editor.bodyPlaceholder": "Начните писать содержимое поста здесь...",
  "editor.chapters.add": "Добавить главу",
  "editor.chapters.confirmDeleteMessage": "Вы уверены, что хотите удалить эту главу? Это действие нельзя отменить.",
  "editor.chapters.confirmDeleteTitle": "Удалить главу",
  "editor.chapters.newChapterTitle": "Новая глава",
  "editor.chapters.remove": "Удалить главу",
  "editor.chapters.title": "Главы",
  "editor.chapters.titlePlaceholder": "Введите название главы",
  "editor.clearDraft": "Очистить черновик",
  "editor.clearDraftMessage": "Вы уверены, что хотите очистить этот черновик?",
  "editor.clearDraftTitle": "Подтвердите очистку черновика",
  "editor.files.confirmDeleteTitle": "Удалить файл",
  "editor.files.empty": "Пока нет загруженных файлов. Используйте кнопки выше, чтобы добавить файлы в ваш пост.",
  "editor.files.menu.delete": "Удалить",
  "editor.files.menu.insert": "Вставить",
  "editor.files.menu.insertUrl": "Вставить URL",
  "editor.files.menu.setThumbnail": "Установить как миниатюру",
  "editor.files.uploadError": "Ошибка загрузки. Пожалуйста, попробуйте снова.",
  "editor.files.uploadFromDisk": "Загрузить с диска",
  "editor.files.uploadFromUrl": "Загрузить по URL",
  "editor.files.uploadModalConfirm": "Подтвердить загрузку",
  "editor.files.uploadModalPlaceholder": "Перетащите файлы сюда или нажмите, чтобы выбрать.",
  "editor.files.uploadModalTitle": "Загрузить файлы",
  "editor.files.uploading": "Загрузка...",
  "editor.fullPreview.back": "Назад к редактированию",
  "editor.fullPreview.help": "Это предварительный просмотр того, как будет выглядеть ваш пост после публикации. Внимательно проверьте его перед продолжением.",
  "editor.fullPreview.publish": "Опубликовать",
  "editor.fullPreview.title": "Финальная проверка",
  "editor.params.fundraiser.label": "ID продвигаемой кампании по сбору средств",
  "editor.params.nsfw.help": "Контент содержит откровенный язык или изображения.",
  "editor.params.nsfw.label": "NSFW",
  "editor.params.publishAsNew.help": "Если отмечено, это будет опубликовано как новый пост с обновленной датой, появляясь вверху ленты.",
  "editor.params.publishAsNew.label": "Опубликовать как новый пост",
  "editor.params.title": "Дополнительные параметры",
  "editor.previewPost": "Предпросмотр поста",
  "editor.publish.descriptor.errorTitle": "Ошибка загрузки описания",
  "editor.publish.draftCleared": "Черновик очищен.",
  "editor.publish.ipfs.errorNetworkOrTooLarge": "Произошла ошибка сети. Это может произойти, если пост слишком большой для принятия сервером. Если вы хотите опубликовать очень большой контент, рассмотрите возможность использования собственных сервисов PIN.",
  "editor.publish.ipfs.errorTitle": "Ошибка загрузки IPFS",
  "editor.publish.ipfs.errorTooLarge": "Этот пост слишком большой, если вы хотите опубликовать очень большой контент, рассмотрите возможность использования собственных сервисов PIN.",
  "editor.publish.publishing.errorTitle": "Ошибка публикации",
  "editor.publish.publishing.txHash": "Хэш транзакции",
  "editor.publish.publishing.waitFinalize": "Публикация завершается в блокчейне...",
  "editor.publish.publishing.waitSignature": "Пожалуйста, подтвердите транзакцию в вашем кошельке.",
  "editor.publish.publishing.waitSignatureHelp": "Если окно кошелька не появилось, откройте расширение вашего кошелька, чтобы завершить подпись.",
  "editor.publish.rights.errorConfig": "Не удалось получить минимальные требования к ставке из контракта.",
  "editor.publish.rights.errorNoAuth": "Вы должны войти, чтобы опубликовать.",
  "editor.publish.rights.errorTitle": "Доступ запрещен",
  "editor.publish.steps.check_rights": "Проверка прав",
  "editor.publish.steps.check_rights.help": "Проверка ваших прав на публикацию",
  "editor.publish.steps.ipfs": "Загрузка в IPFS",
  "editor.publish.steps.ipfs.help": "Сохранение данных в IPFS",
  "editor.publish.steps.ipfs_publish": "Публикация в IPFS",
  "editor.publish.steps.ipfs_publish.help": "Ожидание доступности контента",
  "editor.publish.steps.publish": "Публикация",
  "editor.publish.steps.publish.help": "Публикация в ленту",
  "editor.publish.steps.validate": "Проверка поста",
  "editor.publish.steps.validate.help": "Проверка структуры поста",
  "editor.publish.success": "Успешно опубликовано!",
  "editor.publish.title": "Опубликовать пост",
  "editor.publish.uploadingDescriptor": "Загрузка описания поста",
  "editor.publish.uploadingToIpfs": "Загрузка в IPFS",
  "editor.publish.validation.backToEditor": "Назад к редактору",
  "editor.publish.validation.errorTitle": "Ошибка валидации",
  "editor.sidebar.files": "Файлы",
  "editor.sidebar.filesPlaceholder": "Диспетчер файлов скоро появится.",
  "editor.sidebar.language": "Язык",
  "editor.sidebar.thumbnail": "Миниатюра",
  "editor.sidebar.thumbnailPlaceholder": "Предварительный просмотр миниатюры",
  "editor.thumbnail.delete": "Удалить миниатюру",
  "editor.title": "Редактор постов",
  "editor.titleEditComment": "Редактировать комментарий",
  "editor.titleEditPost": "Редактировать пост",
  "editor.titleNewCommentFor": "Новый комментарий для:",
  "editor.titleNewPost": "Новый пост",
  "editor.titlePlaceholder": "Название поста",
  "editor.toolbar.bold": "Жирный",
  "editor.toolbar.files": "Файлы",
  "editor.toolbar.hidePreview": "Скрыть предварительный просмотр",
  "editor.toolbar.image": "Изображение",
  "editor.toolbar.italic": "Курсив",
  "editor.toolbar.link": "Ссылка",
  "editor.toolbar.maximize": "Развернуть",
  "editor.toolbar.minimize": "Свернуть",
  "editor.toolbar.showPreview": "Показать предварительный просмотр",
  "error.connection.message": "Приложение не смогло подключиться к серверу. Возможно, он временно недоступен. Пожалуйста, попробуйте позже.",
  "error.connection.retry": "Обновить страницу",
  "error.connection.title": "Ошибка подключения",
  "error.ws.message": "Не удалось подключиться. Пожалуйста, попробуйте еще раз.",
  "error.ws.title": "Ошибка подключения",
  "header.newPost": "Новый пост",
  "ipfs.diag.cors.error": "Проблема с конфигурацией CORS.",
  "ipfs.diag.cors.name": "Проверка CORS шлюза",
  "ipfs.diag.cors.ok": "CORS настроен правильно.",
  "ipfs.diag.fetch.errorFirewall": "Запрос не удался из-за брандмауэра.",
  "ipfs.diag.fetch.name": "Получение из живого шлюза",
  "ipfs.diag.fetch.ok": "Запрос успешен.",
  "ipfs.diag.fetch.warnSkipped": "Пропущено: ABI CID не найден в ответе /info.",
  "ipfs.diag.fix.browser": "Если он запущен, проверьте ваш браузер. Для Brave отключите щиты для этого сайта. Для других браузеров, таких как Chrome, возможно, вам нужно будет 'Разрешить небезопасный контент' в настройках сайта.",
  "ipfs.diag.fix.cors": "Если это не помогло, выполните эту команду, чтобы исправить политику CORS API:",
  "ipfs.diag.fix.daemon": "Сначала убедитесь, что ваш IPFS-демон запущен в терминале:",
  "ipfs.diag.fix.gatewaySingleOrigin": "Вариант 1 (Рекомендуется): Разрешить только текущий источник.",
  "ipfs.diag.fix.gatewayTitle": "Ваша конфигурация шлюза, вероятно, мешает браузеру получать данные. Попробуйте одну из этих команд:",
  "ipfs.diag.fix.gatewayWildcard": "Вариант 2 (Проще для разработчиков): Разрешить любой источник. Используйте с осторожностью на публичных узлах.",
  "ipfs.diag.fix.title": "Чтобы исправить, выполните это в вашем терминале (затем перезапустите демон):",
  "ipfs.diag.liveness.error": "Узел не отвечает.",
  "ipfs.diag.liveness.name": "Проверка работоспособности API",
  "ipfs.diag.liveness.ok": "Узел работает.",
  "ipfs.diag.run": "Запустить диагностику",
  "ipfs.diag.title": "Диагностика узла IPFS",
  "main.newContentAvailable": "Доступен новый контент!",
  "main.tabs.empty": "Эта вкладка пока пуста.",
  "main.tabs.loading": "Загрузка вкладок…",
  "main.tabs.untitled": "Без названия",
  "newTab.category": "Категория",
  "newTab.view.grid": "Сетка",
  "newTab.view.group": "Просмотреть группу",
  "newTab.view.list": "Список",
  "post.addComment": "Добавить комментарий...",
  "post.chapters.prologue": "Пролог",
  "post.chapters.title": "Содержание",
  "post.comments": "Комментарии",
  "post.loadMoreComments": "Загрузить больше комментариев",
  "post.noComments": "Пока нет комментариев.",
  "post.notFound.message": "Пост, который вы ищете, не существует или был удален.",
  "post.notFound.title": "Пост не найден",
  "postcard.copyDataCid": "Скопировать Data CID",
  "postcard.copyDescriptorCid": "Скопировать Descriptor CID",
  "postcard.copySavvaCid": "Скопировать SAVVA CID",
  "postcard.pin": "Закрепить пост",
  "postcard.unpin": "Открепить пост",
  "reactions.${reactionType()}": "Реакция с {reactionType}",
  "reactions.${type}": "Реакция {type}",
  "reactions.angry": "Злюсь",
  "reactions.clap": "👏 Аплодисменты",
  "reactions.dislike": "👎 Не нравится",
  "reactions.fire": "🔥",
  "reactions.ha_ha": "Ха-ха",
  "reactions.hot": "Горячо",
  "reactions.laugh": "Ха-ха",
  "reactions.like": "Нравится",
  "reactions.love": "Люблю",
  "reactions.sad": "Грустно",
  "reactions.star": "⭐",
  "reactions.super": "🌟 Супер",
  "reactions.trophy": "Трофей",
  "reactions.wow": "Ух ты",
  "rightPane.language": "Язык",
  "rightPane.settings": "Настройки",
  "rightPane.switch.backend.help": "Приложение получит /info с этого URL для отображения поддерживаемых доменов.",
  "rightPane.switch.backend.label": "URL бэкенда",
  "rightPane.switch.backend.placeholder": "https://example.com/api/",
  "rightPane.switch.domain.label": "Домен",
  "rightPane.switch.domain.website": "Вебсайт",
  "rightPane.switch.noDomains": "Бэкенд не вернул домены. Вы все равно можете подать заявку, но домен будет пустым.",
  "rightPane.switch.open": "Сменить бэкенд / домен",
  "rightPane.switch.reload": "Загрузить домены",
  "rightPane.switch.reload.title": "Получить /info и обновить список доменов",
  "rightPane.switch.reset": "Сбросить к настройкам по умолчанию",
  "rightPane.switch.reset.title": "Очистить локальное переопределение и перезагрузить настройки из default_connect.yaml",
  "rightPane.switch.title": "Сменить бэкенд / домен",
  "rightPane.switch.validation.protocol": "URL бэкенда должен начинаться с http:// или https://",
  "rightPane.theme": "Тема",
  "settings.back": "Назад",
  "settings.dev.assets.baseUrl": "Базовый URL активов",
  "settings.dev.assets.configUrl": "URL конфигурации",
  "settings.dev.assets.configUrl.computed": "Сгенерированный URL",
  "settings.dev.assets.configUrl.open": "Открыть URL конфигурации",
  "settings.dev.assets.diagnostics.default": "Конфигурация по умолчанию",
  "settings.dev.assets.diagnostics.error": "Ошибка диагностики",
  "settings.dev.assets.diagnostics.hasCategories": "Имеет категории",
  "settings.dev.assets.diagnostics.hasConfig": "Имеет конфигурацию",
  "settings.dev.assets.diagnostics.hasFavicon": "Обнаружен фавикон",
  "settings.dev.assets.diagnostics.hasLocales": "Имеет локали",
  "settings.dev.assets.diagnostics.hasLogos": "Имеет логотипы",
  "settings.dev.assets.diagnostics.hasTabs": "Имеет вкладки",
  "settings.dev.assets.diagnostics.noteNetwork": "Проверьте ваше сетевое соединение.",
  "settings.dev.assets.diagnostics.primary": "Основная конфигурация",
  "settings.dev.assets.diagnostics.run": "Запустить диагностику",
  "settings.dev.assets.diagnostics.sampleFetches": "Примеры выборок",
  "settings.dev.assets.diagnostics.title": "Диагностика активов",
  "settings.dev.assets.domain": "Домен",
  "settings.dev.assets.env": "Среда",
  "settings.dev.assets.env.prod": "Продакшн",
  "settings.dev.assets.env.test": "Тест",
  "settings.dev.assets.prefix.active": "Активный префикс",
  "settings.dev.assets.prefix.computed": "Вычисленный префикс",
  "settings.dev.assets.source": "Источник",
  "settings.dev.assets.title": "Активы",
  "settings.developer.debug.enable": "Включить отладочный логгинг",
  "settings.developer.showKeys": "Показать ключи перевода",
  "settings.developer.title": "Разработчик",
  "settings.ipfs.localDisabled": "Локальный IPFS отключен",
  "settings.localIpfs.apiUrl.label": "URL API локального IPFS",
  "settings.localIpfs.disable": "Отключить",
  "settings.localIpfs.enableCheckbox": "Использовать локальный узел IPFS",
  "settings.localIpfs.gateway.label": "Шлюз",
  "settings.localIpfs.status.label": "Статус",
  "settings.localIpfs.testEnable": "Тестировать и включить",
  "settings.localIpfs.title": "Локальный IPFS",
  "settings.title": "Настройки",
  "stakerLevels.${l.key}": "Уровень стейкера {l.key}",
  "stakerLevels.clam": "Моллюск",
  "stakerLevels.dolphin": "Дельфин",
  "stakerLevels.fish": "Рыба",
  "stakerLevels.guest": "Гость",
  "stakerLevels.orca": "Косатка",
  "stakerLevels.seahorse": "Морской конек",
  "stakerLevels.shark": "Акула",
  "stakerLevels.shrimp": "Креветка",
  "stakerLevels.stingray": "Скат",
  "stakerLevels.whale": "Кит",
  "tabs.aria": "Вкладки раздела",
  "tabs.title.${slug(tab.type)}": "Вкладка: {tab.type}",
  "tabs.title.actual": "Текущие",
  "tabs.title.comments": "Комментарии",
  "tabs.title.for-you": "Для вас",
  "tabs.title.leaders": "Лидеры",
  "tabs.title.new": "Новые",
  "time.day.plural": "{n} дней назад",
  "time.day.singular": "{n} день назад",
  "time.hour.plural": "{n} часов назад",
  "time.hour.singular": "{n} час назад",
  "time.minute.plural": "{n} минут назад",
  "time.minute.singular": "{n} минуту назад",
  "time.now": "Сейчас",
  "timeFrame.${frame}": "Период: {frame}",
  "timeFrame.all": "Все время",
  "timeFrame.month": "Месяц",
  "timeFrame.week": "Неделя",
  "timeFrame.year": "Год",
  "ui.mode.dark": "Тёмная тема",
  "ui.mode.light": "Светлая тема",
  "ui.toTop": "Наверх",
  "wallet.changeChain": "Сменить сеть",
  "wallet.connect": "Подключить кошелек",
  "wallet.copyAddress": "Скопировать адрес",
  "wallet.error.userCanceled": "Транзакция отменена.",
  "wallet.onRequiredNetwork": "В требуемой сети"
};
</file>

<file path="src/components/main/TabsBar.jsx">
// src/components/main/TabsBar.jsx
import { createResource, Show, createMemo, createSignal, createEffect, batch, For } from "solid-js";
import { useApp } from "../../context/AppContext";
import { useI18n } from "../../i18n/useI18n";
import { loadAssetResource } from "../../utils/assetLoader";
import { useHashRouter, navigate } from "../../routing/hashRouter";
import Tabs from "../ui/Tabs.jsx";
import { getTabComponent } from "../tabs";
import RightRailLayout from "../tabs/RightRailLayout.jsx";
import TabPanelScaffold from "../tabs/TabPanelScaffold.jsx";

const slug = (s) => String(s || "").trim().toLowerCase();
const firstSeg = (path) => {
  const p = String(path || "/");
  const s = p.startsWith("/") ? p.slice(1) : p;
  return s.split(/[?#/]/, 1)[0] || "";
};
const pathFor = (idOrType) => `/${encodeURIComponent(slug(idOrType)) || ""}`;

function SvgIcon(props) {
  return (
    <svg viewBox="0 0 24 24" class={props.class || "w-4 h-4"} fill="none" stroke="currentColor" stroke-width="1.75" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
      {props.children}
    </svg>
  );
}
const TrophyIcon = () => <SvgIcon><path d="M8 21h8M12 17v4M7 4h10M7 8a5 5 0 0010 0M7 4a4 4 0 01-4 4M17 4a4 4 0 004 4"/></SvgIcon>;
const BoltIcon = () => <SvgIcon><path d="M13 2L3 14h6l-2 8 10-12h-6l2-8z"/></SvgIcon>;
const CommentIcon = () => <SvgIcon><path d="M4 6h16v8a4 4 0 01-4 4h-3l-4 3v-3H8a4 4 0 01-4-4z"/></SvgIcon>;
const SparklesIcon = () => <SvgIcon><path d="M12 3l1.5 4.5L18 9l-4.5 1.5L12 15l-1.5-4.5L6 9l4.5-1.5zM6 16l.8 2.2L9 19l-2.2.8L6 22l-.8-2.2L3 19l2.2-.8z"/></SvgIcon>;
const HeartIcon = () => <SvgIcon><path d="M12 21s-8-7-8-13a5 5 0 019-3 5 5 0 019 3c0 6-8 13-8 13z"/></SvgIcon>;
const FallbackIcon = () => <SvgIcon><path d="M4 6h16v12H4zM8 10h8M8 14h5"/></SvgIcon>;

function iconForType(type) {
  const k = slug(type);
  if (k === "leaders") return <TrophyIcon />;
  if (k === "actual") return <BoltIcon />;
  if (k === "comments") return <CommentIcon />;
  if (k === "new") return <SparklesIcon />;
  if (k === "for-you" || k === "foryou") return <HeartIcon />;
  return <FallbackIcon />;
}

function iconFromSpec(spec) {
  if (!spec) return null;
  if (typeof spec === "string" && spec.startsWith("emoji:")) {
    const ch = spec.slice("emoji:".length);
    return <span aria-hidden="true" class="inline-block leading-none">{ch}</span>;
  }
  return null;
}

export default function TabsBar() {
  const app = useApp();
  const { t, domainAssetsConfig, setLastTabRoute } = app;
  const { lang } = useI18n();
  const { route } = useHashRouter();

  const tabsPath = createMemo(() => domainAssetsConfig?.()?.modules?.tabs || "modules/tabs.yaml");

  const [tabsRaw] = createResource(
    () => tabsPath(),
    async (relPath) => {
      if (!relPath) return [];
      const data = (await loadAssetResource(app, relPath, { type: "yaml" })) || {};
      const list = Array.isArray(data) ? data : Array.isArray(data.tabs) ? data.tabs : [];
      return list.map((x, i) => ({
        id: x?.id ?? x?.type ?? `tab_${i}`,
        type: x?.type ?? x?.id ?? `tab_${i}`,
        _raw: x,
      }));
    }
  );

  const [selectedId, setSelectedId] = createSignal("");
  const [activatedTabs, setActivatedTabs] = createSignal(new Set());
  const [isInitialized, setIsInitialized] = createSignal(false);

  const items = createMemo(() =>
    (tabsRaw() || []).map((tab) => {
      const label = t(`tabs.title.${slug(tab.type)}`) || t("main.tabs.untitled");
      const explicit = iconFromSpec(tab._raw.icon);
      const auto = iconForType(tab.type);
      return { id: tab.id, label, icon: explicit || auto, type: tab.type };
    })
  );

  createEffect(() => {
    const list = tabsRaw();
    if (tabsRaw.loading) return;
    if (!list || list.length === 0) return setSelectedId("");

    const key = firstSeg(route());
    const match = list.find(t => slug(t.id) === key || slug(t.type) === key);

    if (match) {
      if (selectedId() !== match.id) {
        batch(() => {
          setSelectedId(match.id);
          setLastTabRoute(route());
          setActivatedTabs(prev => new Set(prev).add(match.id));
        });
      }
    } else {
      const r = route();
      const isPageRoute = r.startsWith("/post/") || r.startsWith("/settings") || r.startsWith("/docs") || r.startsWith("/editor/");
      
      if (isPageRoute) {
        setSelectedId("");
      } else if (r === "/" && !isInitialized()) {
        const first = list[0];
        const defaultPath = pathFor(first.type || first.id);
        batch(() => {
          setSelectedId(first.id);
          navigate(defaultPath, { replace: true });
          setLastTabRoute(defaultPath);
          setActivatedTabs(prev => new Set(prev).add(first.id));
          setIsInitialized(true);
        });
      }
    }
  });

  function handleTabChange(nextId) {
    const entry = (tabsRaw() || []).find((t) => t.id === nextId);
    if (!entry) return;
    const newPath = pathFor(entry.type || entry.id);
    if (route() !== newPath) {
      navigate(newPath);
    }
  }
  
  return (
    <section class="w-full">
      <div class="sv-container sv-container--no-gutter">
        <Show when={!tabsRaw.loading} fallback={<div class="p-4 text-sm text-center">{t("main.tabs.loading")}</div>}>
          <Tabs items={items()} value={selectedId()} onChange={handleTabChange} compactWidth={768} />
        </Show>

        <div class="tabs_panel">
          <For each={tabsRaw()}>
            {(tab) => {
              const Comp = getTabComponent(tab.type);
              const title = t(`tabs.title.${slug(tab.type)}`) || t("main.tabs.untitled");
              const rightPanelConfig = tab._raw?.right_panel;
              const isRailVisible = rightPanelConfig?.available;

              return (
                <div style={{ display: tab.id === selectedId() ? 'block' : 'none' }}>
                  <RightRailLayout rightPanelConfig={rightPanelConfig}>
                    <Show when={Comp} fallback={<TabPanelScaffold title={title} />}>
                      <Comp 
                        title={title} 
                        tab={tab} 
                        isRailVisible={isRailVisible}
                        isActivated={activatedTabs().has(tab.id)}
                      />
                    </Show>
                  </RightRailLayout>
                </div>
              );
            }}
          </For>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/pages/PostPage.jsx">
// src/pages/PostPage.jsx
import { createMemo, createResource, Show, Match, Switch, createEffect, createSignal } from "solid-js";
import { createStore, reconcile } from "solid-js/store";
import { useHashRouter, navigate } from "../routing/hashRouter";
import { useApp } from "../context/AppContext.jsx";
import { ipfs } from "../ipfs/index.js";
import { parse } from "yaml";
import { dbg } from "../utils/debug.js";
import ClosePageButton from "../components/ui/ClosePageButton";
import Spinner from "../components/ui/Spinner.jsx";
import { toChecksumAddress } from "../blockchain/utils.js";
import LangSelector from "../components/ui/LangSelector.jsx";
import IpfsImage from "../components/ui/IpfsImage.jsx";
import UserCard from "../components/ui/UserCard.jsx";
import PostInfo from "../components/feed/PostInfo.jsx";
import MarkdownView from "../components/docs/MarkdownView.jsx";
import UnknownUserIcon from "../components/ui/icons/UnknownUserIcon.jsx";
import ChapterSelector from "../components/post/ChapterSelector.jsx";
import ChapterPager from "../components/post/ChapterPager.jsx";
import PostTags from "../components/post/PostTags.jsx";
import { getPostContentBaseCid, getPostDescriptorPath, resolvePostCidPath } from "../ipfs/utils.js";
import { rehypeRewriteLinks } from "../docs/rehype-rewrite-links.js";
import ContextMenu from "../components/ui/ContextMenu.jsx";
import { getPostAdminItems } from "../ui/contextMenuBuilder.js";
import PostControls from "../components/post/PostControls.jsx";
import PostComments from "../components/post/PostComments.jsx";


const getIdentifier = (route) => route().split('/')[2] || "";

async function fetchPostByIdentifier(params) {
  const { identifier, domain, app, lang } = params;
  if (!identifier || !domain || !app.wsMethod) return null;
  const contentList = app.wsMethod("content-list");
  const requestParams = {
    domain: domain,
    lang: lang,
    limit: 1,
  };
  if (identifier.startsWith("0x")) {
    requestParams.savva_cid = identifier;
  } else {
    requestParams.short_cid = identifier;
  }
  const user = app.authorizedUser();
  if (user?.address) {
    requestParams.my_addr = toChecksumAddress(user.address);
  }
  const res = await contentList(requestParams);
  const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];
  return arr[0] || null;
}

async function fetchPostDetails(mainPost, app) {
  if (!mainPost) return null;
  
  const descriptorPath = getPostDescriptorPath(mainPost);
  const dataCidForContent = getPostContentBaseCid(mainPost);

  dbg.log('PostPage', 'Determined paths', { descriptorPath, dataCidForContent });

  if (!descriptorPath) {
    return { descriptor: null, dataCidForContent };
  }

  try {
    const { res } = await ipfs.fetchBest(app, descriptorPath);
    const text = await res.text();
    const descriptor = parse(text) || null;
    return { descriptor, dataCidForContent };
  } catch (error) {
    dbg.error('PostPage', 'Failed to fetch or parse descriptor', { path: descriptorPath, error });
    return { descriptor: { error: error.message }, dataCidForContent };
  }
}

async function fetchMainContent(details, app, lang, chapterIndex) {
  if (!details?.descriptor || !lang) return "";

  const { descriptor, dataCidForContent } = details;
  const localizedDescriptor = descriptor.locales?.[lang];
  if (!localizedDescriptor) return "";

  let contentPath;
  if (chapterIndex === 0) { // Prologue (main content)
    if (localizedDescriptor.data) return localizedDescriptor.data;
    if (localizedDescriptor.data_path) {
      contentPath = `${dataCidForContent}/${localizedDescriptor.data_path}`;
    }
  } else { // A specific chapter
    const chapter = localizedDescriptor.chapters?.[chapterIndex - 1];
    if (chapter?.data_path) {
      contentPath = `${dataCidForContent}/${chapter.data_path}`;
    }
  }

  if (contentPath) {
    try {
      const postGateways = details.descriptor?.gateways || [];
      const { res } = await ipfs.fetchBest(app, contentPath, { postGateways });
      return await res.text();
    } catch (error) {
      dbg.error('PostPage', 'Failed to fetch main content', { path: contentPath, error });
      return `## Error loading content\n\n\`\`\`\n${error.message}\n\`\`\``;
    }
  }
  
  return "";
}

export default function PostPage() {
  const app = useApp();
  const { t } = app;
  const { route } = useHashRouter();
  const identifier = createMemo(() => getIdentifier(route));
  const uiLang = createMemo(() => (app.lang?.() || "en").toLowerCase());

  const [postResource] = createResource(
    () => ({
      identifier: identifier(),
      domain: app.selectedDomainName(),
      app,
      lang: uiLang()
    }),
    fetchPostByIdentifier
  );
  
  const [post, setPost] = createStore(null);

  createEffect(() => {
    const resourceData = postResource();
    if (resourceData) {
      setPost(reconcile(resourceData));
    }
  });

  const [details] = createResource(postResource, (p) => fetchPostDetails(p, app));
  const [postLang, setPostLang] = createSignal(null);
  const [selectedChapterIndex, setSelectedChapterIndex] = createSignal(0);

  const [mainContent] = createResource(
    () => ({ details: details(), lang: postLang(), chapterIndex: selectedChapterIndex() }), 
    ({ details, lang, chapterIndex }) => fetchMainContent(details, app, lang, chapterIndex)
  );

  createEffect(() => {
    const p = post;
    const id = identifier();
    if (p && id.startsWith("0x") && p.short_cid) {
      const newPath = `/post/${p.short_cid}`;
      navigate(newPath, { replace: true });
    }
  });

  createEffect(() => {
    const update = app.postUpdate();
    if (post && update && update.type === 'reactionsChanged' && update.cid === post.savva_cid) {
      setPost('reactions', update.data.reactions);
      if (app.authorizedUser()?.address?.toLowerCase() === update.data?.user?.toLowerCase()) {
        setPost('my_reaction', update.data.reaction);
      }
    }
  });

  createEffect(() => {
    if (post && !postLang()) {
      const availableLangs = Object.keys(details()?.descriptor?.locales || post.savva_content?.locales || {});
      if (availableLangs.length === 0) return;
      const currentUiLang = uiLang();
      let initialLang = availableLangs[0]; 
      if (availableLangs.includes(currentUiLang)) {
        initialLang = currentUiLang;
      } else if (availableLangs.includes('en')) {
        initialLang = 'en';
      }
      setPostLang(initialLang);
    }
  });

  const contextMenuItems = createMemo(() => {
    if (!post) return [];
    return getPostAdminItems(post, t);
  });

  const title = createMemo(() => details()?.descriptor?.locales?.[postLang()]?.title || post?.savva_content?.locales?.[postLang()]?.title || "");
  const thumbnail = createMemo(() => {
    if (!post) return null;
    const d = details();
    const thumbnailPath = d?.descriptor?.thumbnail || post.savva_content?.thumbnail;
    return resolvePostCidPath(post, thumbnailPath);
  });
  const availableLocales = createMemo(() => Object.keys(details()?.descriptor?.locales || post?.savva_content?.locales || {}));
  
  const chapterList = createMemo(() => {
    const prologue = { title: t("post.chapters.prologue"), data_path: null };
    const chapters = details()?.descriptor?.locales?.[postLang()]?.chapters || [];
    return [prologue, ...chapters];
  });

  const postSpecificGateways = createMemo(() => details()?.descriptor?.gateways || []);
  const localizedMainContent = createMemo(() => mainContent());
  const ipfsBaseUrl = createMemo(() => {
    const d = details();
    if (!d) return "";
    const dataCid = d.dataCidForContent;
    if (!dataCid) return "";
    
    let bestGateway;
    if (app.localIpfsEnabled() && app.localIpfsGateway()) {
      bestGateway = app.localIpfsGateway();
    } else if (Array.isArray(postSpecificGateways()) && postSpecificGateways().length > 0) {
      bestGateway = postSpecificGateways()[0];
    } else {
      bestGateway = app.remoteIpfsGateways()[0] || "https://ipfs.io/";
    }
    
    const gatewayUrl = bestGateway.endsWith("/") ? bestGateway : `${bestGateway}/`;
    return `${gatewayUrl}ipfs/${dataCid}`;
  });

  const markdownPlugins = createMemo(() => [
    [rehypeRewriteLinks, { base: ipfsBaseUrl() }]
  ]);

  const RightPanel = () => (
    <aside class="sticky top-16">
      <div 
        class="rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] overflow-hidden"
        style={{ "max-height": `calc(100vh - 5rem)` }}
      >
        <div class="p-4 space-y-3 overflow-y-auto h-full">
          <h4 class="font-semibold">Right Panel</h4>
          <p class="text-sm text-[hsl(var(--muted-foreground))]">
            This panel behaves like the main screen's right rail. It sticks to the top, and this content area will scroll if it's too long.
          </p>
        </div>
      </div>
    </aside>
  );

  return (
    <main class="sv-container p-4">
      <ClosePageButton />
      <Switch>
        <Match when={postResource.loading}>
          <div class="flex justify-center items-center h-64"><Spinner class="w-8 h-8" /></div>
        </Match>
        <Match when={postResource.error || details()?.descriptor?.error}>
          <div class="p-4 rounded border border-[hsl(var(--destructive))] bg-[hsl(var(--card))]">
            <h3 class="font-semibold text-[hsl(var(--destructive))]">{t("common.error")}</h3>
            <p class="text-sm mt-1">{postResource.error?.message || details()?.descriptor?.error}</p>
          </div>
        </Match>
        <Match when={!postResource.loading && !post}>
          <div class="p-4 rounded border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-center">
            <h3 class="font-semibold">{t("post.notFound.title")}</h3>
            <p class="text-sm mt-1 text-[hsl(var(--muted-foreground))]">{t("post.notFound.message")}</p>
          </div>
        </Match>
        <Match when={post}>
          <div class="max-w-5xl mx-auto">
            <article class="space-y-4">
              <header class="flex justify-between items-start gap-4">
                <div class="relative flex-1 min-w-0 space-y-3">
                  <h1 class="text-2xl lg:text-3xl font-bold break-words pr-12">{title() || t('common.loading')}</h1>
                  
                  <Show when={app.authorizedUser()?.isAdmin && contextMenuItems().length > 0}>
                    <ContextMenu 
                      items={contextMenuItems()}
                      positionClass="absolute top-0 right-0 z-20"
                    />
                  </Show>
                  <UserCard author={post.author} />
                </div>
                <div class="w-48 flex flex-col items-center flex-shrink-0 space-y-2">
                  <Show when={thumbnail()}>
                    {(src) => (
                      <IpfsImage 
                        src={src()} 
                        class="w-full aspect-video rounded-md object-cover border border-[hsl(var(--border))]" 
                        alt="Post thumbnail"
                        postGateways={postSpecificGateways()}
                        fallback={<UnknownUserIcon class="w-full h-full object-contain p-4 text-[hsl(var(--muted-foreground))]" />}
                      />
                    )}
                  </Show>
                  <LangSelector 
                    codes={availableLocales()}
                    value={postLang()}
                    onChange={setPostLang}
                  />
                </div>
              </header>

              <div class="pt-4 border-t border-[hsl(var(--border))]">
                <div class="grid grid-cols-[minmax(0,1fr)_12rem] gap-6 items-start">
                  <div>
                    <Show when={(chapterList()?.length || 0) > 1}>
                      <div class="flex justify-end mb-4">
                        <ChapterSelector 
                          chapters={chapterList()} 
                          selectedIndex={selectedChapterIndex()} 
                          onSelect={setSelectedChapterIndex}
                        />
                      </div>
                    </Show>
                    <Switch>
                      <Match when={details.loading || mainContent.loading}>
                        <div class="flex justify-center p-8"><Spinner /></div>
                      </Match>
                      <Match when={mainContent.error}>
                        <p class="text-sm text-[hsl(var(--destructive))]">Error loading content: {mainContent.error.message}</p>
                      </Match>
                      <Match when={localizedMainContent()}>
                        <MarkdownView 
                          markdown={localizedMainContent()} 
                          rehypePlugins={markdownPlugins()}
                        />
                        <Show when={(chapterList()?.length || 0) > 1}>
                          <ChapterPager 
                            chapters={chapterList()}
                            currentIndex={selectedChapterIndex()}
                            onSelect={setSelectedChapterIndex}
                          />
                        </Show>
                      </Match>
                    </Switch>
                    <PostControls post={post} />
                    <PostComments post={post} />
                  </div>
                  <RightPanel />
                </div>
              </div>
            </article>
          </div>
          
        </Match>
      </Switch>
    </main>
  );
}
</file>

<file path="src/version.js">
// src/version.js
export const APP_VERSION = "0.106";
</file>

<file path="src/components/feed/PostCard.jsx">
// src/components/feed/PostCard.jsx
import { Show, createMemo, createSignal, createEffect } from "solid-js";
import { useApp } from "../../context/AppContext.jsx";
import IpfsImage from "../ui/IpfsImage.jsx";
import UserCard from "../ui/UserCard.jsx";
import UnknownUserIcon from "../ui/icons/UnknownUserIcon.jsx";
import PostInfo from "./PostInfo.jsx";
import NftBadge from "../ui/icons/NftBadge.jsx";
import PostFundBadge from "../ui/PostFundBadge.jsx";
import { navigate } from "../../routing/hashRouter";
import ContextMenu from "../ui/ContextMenu.jsx";
import { getPostAdminItems } from "../../ui/contextMenuBuilder.js";
import { resolvePostCidPath } from "../../ipfs/utils.js";

function PinIcon(props) {
  return (
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class={`${props.class} scale-x-[-1]`}>
      <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
      <g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g>
      <g id="SVGRepo_iconCarrier">
        <path d="M19.1835 7.80516L16.2188 4.83755C14.1921 2.8089 13.1788 1.79457 12.0904 2.03468C11.0021 2.2748 10.5086 3.62155 9.5217 6.31506L8.85373 8.1381C8.59063 8.85617 8.45908 9.2152 8.22239 9.49292C8.11619 9.61754 7.99536 9.72887 7.86251 9.82451C7.56644 10.0377 7.19811 10.1392 6.46145 10.3423C4.80107 10.8 3.97088 11.0289 3.65804 11.5721C3.5228 11.8069 3.45242 12.0735 3.45413 12.3446C3.45809 12.9715 4.06698 13.581 5.28476 14.8L6.69935 16.2163L2.22345 20.6964C1.92552 20.9946 1.92552 21.4782 2.22345 21.7764C2.52138 22.0746 3.00443 22.0746 3.30236 21.7764L7.77841 17.2961L9.24441 18.7635C10.4699 19.9902 11.0827 20.6036 11.7134 20.6045C11.9792 20.6049 12.2404 20.5358 12.4713 20.4041C13.0192 20.0914 13.2493 19.2551 13.7095 17.5825C13.9119 16.8472 14.013 16.4795 14.2254 16.1835C14.3184 16.054 14.4262 15.9358 14.5468 15.8314C14.8221 15.593 15.1788 15.459 15.8922 15.191L17.7362 14.4981C20.4 13.4973 21.7319 12.9969 21.9667 11.9115C22.2014 10.826 21.1954 9.81905 19.1835 7.80516Z" fill="currentColor"></path>
      </g>
    </svg>
  );
}

function getLocalizedField(locales, fieldName, currentLang) {
  if (!locales || typeof locales !== 'object') return "";
  if (locales[currentLang]?.[fieldName]) return locales[currentLang][fieldName];
  if (locales.en?.[fieldName]) return locales.en[fieldName];
  const firstLocaleKey = Object.keys(locales)[0];
  if (firstLocaleKey && locales[firstLocaleKey]?.[fieldName]) {
    return locales[firstLocaleKey][fieldName];
  }
  return "";
}

export default function PostCard(props) {
  const app = useApp();
  const { t } = app;
  const [isHovered, setIsHovered] = createSignal(false);
  
  const item = createMemo(() => {
    const baseItem = props.item;
    const update = app.postUpdate();

    if (update && update.cid === baseItem.id) {
        let updatedRaw = { ...baseItem._raw };
        
        if (update.type === 'reactionsChanged') {
            updatedRaw.reactions = update.data.reactions;
            if (app.authorizedUser()?.address?.toLowerCase() === update.data?.user?.toLowerCase()) {
                updatedRaw.my_reaction = update.data.reaction;
            }
        } else if (update.type === 'commentCountChanged') {
            updatedRaw.total_childs = update.data.newTotal;
        }

        return { ...baseItem, _raw: updatedRaw };
    }
    
    return baseItem;
  });

  const author = () => item()._raw?.author;
  const content = () => item()._raw?.savva_content;
  const fund = () => item()._raw?.fund;
  const isListMode = () => props.mode === 'list';

  const displayImageSrc = createMemo(() => {
    const thumbnailPath = content()?.thumbnail;
    if (thumbnailPath) {
      return resolvePostCidPath(item()._raw, thumbnailPath);
    }
    return author()?.avatar;
  });

  const title = createMemo(() => {
    return getLocalizedField(content()?.locales, "title", app.lang());
  });

  const textPreview = createMemo(() => {
    return getLocalizedField(content()?.locales, "text_preview", app.lang());
  });

  const handleCardClick = (e) => {
    const postId = props.item.id;
    if (postId) {
      app.setSavedScrollY(window.scrollY);
      navigate(`/post/${postId}`);
    } else {
      console.warn("PostCard: Could not find post ID to navigate.", { item: props.item });
    }
  };

  const finalContextMenuItems = createMemo(() => {
    const propItems = props.contextMenuItems || [];
    const adminItems = getPostAdminItems(item()._raw, t);
    return [...propItems, ...adminItems];
  });

  const articleClasses = createMemo(() => {
    const base = "relative rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] text-[hsl(var(--card-foreground))] flex";
    if (isListMode()) {
      return `${base} flex-row ${props.compact ? 'h-20' : 'h-40'}`;
    }
    return `${base} flex-col`;
  });

  const imageContainerClasses = createMemo(() => {
    const listModeRounding = isListMode() ? "rounded-l-lg" : "rounded-t-lg";
    return `relative shrink-0 overflow-hidden ${listModeRounding} ${isListMode() ? "h-full aspect-video border-r" : "aspect-video w-full border-b"} border-[hsl(var(--border))]`;
  });
  
  const ImageBlock = () => {
    const roundingClass = isListMode() ? "rounded-l-lg" : "rounded-t-lg";
    return (
      <div class={imageContainerClasses()}>
        <IpfsImage
          src={displayImageSrc()}
          class={roundingClass}
          postGateways={item()?._raw?.gateways || []}
          fallback={<UnknownUserIcon class={`absolute inset-0 w-full h-full ${roundingClass}`} />}
        />
        <Show when={fund()?.amount > 0 && fund()?.round_time > 0}>
          <div class="absolute bottom-2 right-0 z-10">
            <PostFundBadge amount={fund()?.amount} />
          </div>
        </Show>
      </div>
    );
  };

  const contentContainerClasses = createMemo(() => {
    return isListMode()
      ? "px-3 py-2 flex-1 flex flex-col min-w-0"
      : "p-3 flex-1 flex flex-col";
  });

  const textPreviewClasses = createMemo(() => {
    const base = "text-xs leading-snug text-[hsl(var(--muted-foreground))]";
    if (isListMode()) {
      return `${base} ${props.compact ? 'line-clamp-1' : 'line-clamp-2'}`;
    }
    return `${base} line-clamp-3`;
  });

  const ContentBlock = () => (
    <div class={contentContainerClasses()}>
      <div class="flex-1 flex flex-col space-y-1 min-h-0">
        <div class="flex-1">
          <Show when={title()}>
            <h4 class={`font-semibold line-clamp-3 text-[hsl(var(--foreground))] ${props.compact ? 'text-xs' : 'text-sm'}`}>
              {title()}
            </h4>
          </Show>
          <Show when={textPreview() && !props.compact}>
            <p class={textPreviewClasses()}>
              {textPreview()}
            </p>
          </Show>
        </div>
        <div class="pt-1">
          <UserCard author={author()} compact={props.compact} />
        </div>
      </div>
      
      <Show when={!props.compact}>
        <PostInfo item={item()} mode={props.mode} timeFormat="long" />
      </Show>
    </div>
  );

  return (
    <article 
      class={articleClasses()} 
      onClick={handleCardClick} 
      style={{ cursor: 'pointer' }}
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <Show when={item()?._raw?.pinned}>
        <div class="absolute -top-2 -left-2 z-10">
          <PinIcon class="w-5 h-5 text-[hsl(var(--primary))]" />
        </div>
      </Show>

      <Show when={item()?._raw?.nft?.owner}>
        <div class="absolute -top-2 -right-2 z-10">
          <NftBadge />
        </div>
      </Show>

      <Show when={app.authorizedUser()?.isAdmin && isHovered() && finalContextMenuItems().length > 0}>
        <div class="context-menu-container">
          <ContextMenu items={finalContextMenuItems()} />
        </div>
      </Show>

      <Show
        when={isListMode()}
        fallback={
          <>
            <ImageBlock />
            <ContentBlock />
          </>
        }
      >
        {isListMode() ? (
          <>
            <ContentBlock />
            <ImageBlock />
          </>
        ) : (
          <>
            <ImageBlock />
            <ContentBlock />
          </>
        )}
      </Show>
    </article>
  );
}
</file>

<file path="src/context/AppContext.jsx">
// src/context/AppContext.jsx
import * as Solid from "solid-js";
import { getChainMeta } from "../blockchain/chains";
import { switchOrAddChain, walletAccount, isWalletAvailable } from "../blockchain/wallet";
import { useI18n } from "../i18n/useI18n";
import { useLocalIpfs } from "../hooks/useLocalIpfs.js";
import { useAppAuth } from "./useAppAuth.js";
import { useAppConnection } from "./useAppConnection.js";
import { useDomainAssets } from "./useDomainAssets.js";
import { pushToast, pushErrorToast } from "../ui/toast.js";
import { useHashRouter } from "../routing/hashRouter.js";
import { createWalletClient, custom } from "viem";
import { useTokenPrices } from "./useTokenPrices.js";

const AppContext = Solid.createContext();
const dn = (d) => (typeof d === "string" ? d : d?.name || "");
const eq = (a, b) => String(a || "").trim().toLowerCase() === String(b || "").trim().toLowerCase();

export function AppProvider(props) {
  const i18n = useI18n();
  const auth = useAppAuth();
  const conn = useAppConnection();
  const ipfs = useLocalIpfs({ pushToast, pushErrorToast, t: i18n.t });
  const [postUpdate, setPostUpdate] = Solid.createSignal(null);
  
  const [lastTabRoute, setLastTabRoute] = Solid.createSignal("/");
  const [savedScrollY, setSavedScrollY] = Solid.createSignal(0);

  const { route } = useHashRouter();
  Solid.createEffect(Solid.on(route, (nextRoute, prevRoute) => {
    if (!prevRoute) return;
    const isCurrentlyOnMainFeed = !/^\/(post|settings|docs|editor)/.test(prevRoute);
    const isNavigatingToPage = /^\/(post|settings|docs|editor)/.test(nextRoute);
    if (isCurrentlyOnMainFeed && isNavigatingToPage) {
      setSavedScrollY(window.scrollY);
    }
  }, { defer: true }));
  
  const [newFeedItems, setNewFeedItems] = Solid.createSignal([]);
  const [newContentAvailable, setNewContentAvailable] = Solid.createSignal(null);
  const [newTabRefreshKey, setNewTabRefreshKey] = Solid.createSignal(Date.now());

  const supportedDomains = Solid.createMemo(() => {
    const list = conn.info()?.domains || [];
    return [...new Set(list.map(d => (typeof d === "string" ? d : d?.name)).filter(Boolean))]
      .map(name => ({ name, website: list.find(d => d.name === name)?.website || "" }));
  });

  const selectedDomain = Solid.createMemo(() => {
    const explicit = String(conn.config()?.domain || "").trim();
    if (explicit) {
      return supportedDomains().find(d => eq(d.name, explicit)) || explicit;
    }
    return supportedDomains()[0] || "";
  });
  
  const selectedDomainName = Solid.createMemo(() => dn(selectedDomain()));
  const assets = useDomainAssets({ info: conn.info, selectedDomainName, i18n });
  const prices = useTokenPrices({ info: conn.info });

  Solid.createEffect(() => {
    const cfg = assets.domainAssetsConfig();
    const lang = i18n.lang();
    if (!cfg) return;

    const locales = Array.isArray(cfg.locales) ? cfg.locales : [];
    const currentLocale = locales.find(l => l.code === lang) || locales.find(l => l.code === 'en') || locales[0];
    
    if (currentLocale?.title) {
      document.title = currentLocale.title;
    }
  });

  const desiredChainId = Solid.createMemo(() => conn.info()?.blockchain_id ?? null);
  const desiredChain = Solid.createMemo(() => { const id = desiredChainId(); return id ? getChainMeta(id) : null; });
  async function ensureWalletOnDesiredChain() { const meta = desiredChain(); if (!meta) throw new Error("Unknown target chain"); await switchOrAddChain(meta); }
  
  const remoteIpfsGateways = Solid.createMemo(() => (conn.info()?.ipfs_gateways || []).map(g => g.trim().endsWith("/") ? g : `${g}/`));
  const activeIpfsGateways = Solid.createMemo(() => (ipfs.localIpfsEnabled() && ipfs.localIpfsGateway()) ? [ipfs.localIpfsGateway()] : remoteIpfsGateways());
  
  Solid.createEffect(() => {
    if (auth.authorizedUser() && conn.config() && auth.authorizedUser().domain !== conn.config().domain) {
      auth.logout();
      pushToast({ type: 'info', message: 'Logged out due to domain change.' });
    }
  });

  const [isSwitchAccountModalOpen, setIsSwitchAccountModalOpen] = Solid.createSignal(false);
  const [requiredAccount, setRequiredAccount] = Solid.createSignal(null);
  let switchAccountResolver = null;
  let switchAccountRejecter = null;

  function promptSwitchAccount(requiredAddress) {
    return new Promise((resolve, reject) => {
      setRequiredAccount(requiredAddress);
      setIsSwitchAccountModalOpen(true);
      switchAccountResolver = resolve;
      switchAccountRejecter = reject;
    });
  }

  const resolveSwitchAccountPrompt = () => {
    setIsSwitchAccountModalOpen(false);
    if (switchAccountResolver) switchAccountResolver();
  };

  const rejectSwitchAccountPrompt = () => {
    setIsSwitchAccountModalOpen(false);
    if (switchAccountRejecter) switchAccountRejecter(new Error("User canceled the action."));
  };

  function getRawWalletClient() {
    const walletAcc = walletAccount();
    if (!isWalletAvailable()) throw new Error("Wallet is not available.");
    if (!walletAcc) throw new Error("Wallet is not connected.");
    
    const chain = desiredChain();
    if (!chain) throw new Error("Target chain is not configured.");

    return createWalletClient({
      chain: chain,
      account: walletAcc,
      transport: custom(window.ethereum)
    });
  }
  
  async function getGuardedWalletClient() {
    const authorizedAcc = auth.authorizedUser()?.address;
    if (!authorizedAcc) throw new Error("User is not authorized.");
    
    const walletClient = getRawWalletClient(); // Uses the raw client internally
    const walletAcc = walletClient.account.address;

    if (walletAcc.toLowerCase() !== authorizedAcc.toLowerCase()) {
      try {
        await promptSwitchAccount(authorizedAcc);
        // After success, the walletAccount() signal is updated, so we need a fresh client.
        return getRawWalletClient();
      } catch (e) {
        throw new Error(i18n.t("wallet.error.userCanceled"));
      }
    }
    
    return walletClient;
  }

  const value = {
    ...conn, ...auth, ...assets, ...ipfs, ...prices,
    i18n, t: i18n.t, lang: i18n.lang, setLang: i18n.setLang,
    showKeys: i18n.showKeys, setShowKeys: i18n.setShowKeys,
    i18nAvailable: i18n.available,
    lastTabRoute, setLastTabRoute,
    savedScrollY, setSavedScrollY,
    newFeedItems, setNewFeedItems,
    newContentAvailable, setNewContentAvailable,
    newTabRefreshKey, setNewTabRefreshKey,
    supportedDomains, selectedDomain, selectedDomainName,
    desiredChainId, desiredChain, ensureWalletOnDesiredChain,
    remoteIpfsGateways, activeIpfsGateways,
    postUpdate, setPostUpdate,
    setDomain: (d) => { conn.setDomain(d); auth.logout(); },
    clearConnectOverride: () => { conn.clearConnectOverride(); auth.logout(); },
    getGuardedWalletClient,
    getRawWalletClient,
    isSwitchAccountModalOpen,
    requiredAccount,
    resolveSwitchAccountPrompt,
    rejectSwitchAccountPrompt,
  };

  return <AppContext.Provider value={value}>{props.children}</AppContext.Provider>;
}

export function useApp() {
  const ctx = Solid.useContext(AppContext);
  if (!ctx) throw new Error("useApp must be used inside <AppProvider>");
  if (typeof window !== "undefined") window.__app = ctx;
  return ctx;
}
</file>

<file path="src/pages/EditorPage.jsx">
// src/pages/EditorPage.jsx
import { createMemo, createSignal, Show, onMount, createEffect, on, onCleanup, batch } from "solid-js";
import { useApp } from "../context/AppContext.jsx";
import ClosePageButton from "../components/ui/ClosePageButton.jsx";
import { useHashRouter, navigate } from "../routing/hashRouter.js";
import MarkdownInput from "../components/editor/MarkdownInput.jsx";
import LangSelector from "../components/ui/LangSelector.jsx";
import EditorToolbar from "../components/editor/EditorToolbar.jsx";
import EditorFilesDrawer from "../components/editor/EditorFilesDrawer.jsx";
import { rehypeResolveDraftUrls } from "../docs/rehype-resolve-draft-urls.js";
import EditorFilesButton from "../components/editor/EditorFilesButton.jsx";
import { loadDraft, saveDraft, resolveDraftFileUrl, DRAFT_DIRS, clearDraft, addUploadedFile } from "../editor/storage.js";
import { dbg } from "../utils/debug.js";
import EditorChapterSelector from "../components/editor/EditorChapterSelector.jsx";
import EditorTocButton from "../components/editor/EditorTocButton.jsx";
import ConfirmModal from "../components/ui/ConfirmModal.jsx";
import { insertTextAtCursor } from "../editor/text-utils.js";
import EditorFullPreview from "../components/editor/EditorFullPreview.jsx";
import PostSubmissionWizard from "../components/editor/PostSubmissionWizard.jsx";
import { pushToast } from "../ui/toast.js";
import CommentEditor from "../components/editor/CommentEditor.jsx";
import { toChecksumAddress } from "../blockchain/utils.js";
import { whenWsOpen } from "../net/wsRuntime.js";
import { TrashIcon } from "../components/ui/icons/ActionIcons.jsx";

async function fetchPostByIdentifier(params) {
  const { identifier, domain, app, lang } = params;
  if (!identifier || !domain || !app.wsMethod) return null;
  
  await whenWsOpen();
  
  const contentList = app.wsMethod("content-list");
  const requestParams = {
    domain: domain,
    lang: lang,
    limit: 1,
  };
  if (identifier.startsWith("0x")) {
    requestParams.savva_cid = identifier;
  } else {
    requestParams.short_cid = identifier;
  }
  const user = app.authorizedUser();
  if (user?.address) {
    requestParams.my_addr = toChecksumAddress(user.address);
  }
  const res = await contentList(requestParams);
  const arr = Array.isArray(res) ? res : Array.isArray(res?.list) ? res.list : [];
  return arr[0] || null;
}

export default function EditorPage() {
  const app = useApp();
  const { t, domainAssetsConfig, lastTabRoute } = app;
  const { route } = useHashRouter();
  let textareaRef;

  const [postData, setPostData] = createSignal(null);
  const [postParams, setPostParams] = createSignal({});
  const [activeLang, setActiveLang] = createSignal("en");
  const [showPreview, setShowPreview] = createSignal(false);
  const [showFiles, setShowFiles] = createSignal(false);
  const [showChapters, setShowChapters] = createSignal(false);
  const [editingChapterIndex, setEditingChapterIndex] = createSignal(-1);
  const [showConfirmDelete, setShowConfirmDelete] = createSignal(false);
  const [showConfirmClear, setShowConfirmClear] = createSignal(false);
  const [thumbnailUrl, setThumbnailUrl] = createSignal(null);
  const [showFullPreview, setShowFullPreview] = createSignal(false);
  const [showPublishWizard, setShowPublishWizard] = createSignal(false);
  const [isFullScreen, setIsFullScreen] = createSignal(false);
  const [filesRevision, setFilesRevision] = createSignal(0);

  let autoSaveTimeoutId;
  onCleanup(() => clearTimeout(autoSaveTimeoutId));

  const routeParams = createMemo(() => {
    const path = route();
    if (path.startsWith("/editor/new-comment/")) return { mode: "new_comment", parent_savva_cid: path.split('/')[3] };
    if (path.startsWith("/editor/comment/")) return { mode: "edit_comment", id: path.split('/')[3] };
    if (path.startsWith("/editor/new")) return { mode: "new_post" };
    if (path.startsWith("/editor/edit/")) return { mode: "edit_post", id: path.split('/')[3] };
    return { mode: "unknown" };
  });

  const editorMode = () => routeParams().mode;
  
  const baseDir = createMemo(() => {
    const mode = editorMode();
    if (mode === "new_post") return DRAFT_DIRS.NEW_POST;
    if (mode === "new_comment") return DRAFT_DIRS.NEW_COMMENT;
    if (["edit_post", "edit_comment"].includes(mode)) return DRAFT_DIRS.EDIT;
    return "unknown";
  });

  const domainLangCodes = createMemo(() => {
    const fromDomain = (domainAssetsConfig?.()?.locales || []).map((l) => l.code).filter(Boolean);
    return fromDomain.length > 0 ? fromDomain : ["en"];
  });

  const loadEditorContent = async () => {
    try {
      const mode = editorMode();
      if (mode === "new_comment") {
        await clearDraft(baseDir());
        const parentCid = routeParams().parent_savva_cid;
        const parentObject = await fetchPostByIdentifier({
            identifier: parentCid,
            domain: app.selectedDomainName(),
            app,
            lang: app.lang()
        });
        if (!parentObject) throw new Error("Parent content not found.");
        
        const isReplyToComment = !!parentObject.parent_savva_cid;
        const newPostParams = { 
          locales: {}, 
          guid: crypto.randomUUID(),
          parent_savva_cid: parentObject.savva_cid,
          root_savva_cid: isReplyToComment ? (parentObject.root_savva_cid || parentObject.parent_savva_cid) : parentObject.savva_cid
        };

        const newPostData = {};
        for (const langCode of domainLangCodes()) {
            newPostData[langCode] = { title: "", body: "", chapters: [] };
            newPostParams.locales[langCode] = { chapters: [] };
        }
        batch(() => {
          setPostData(newPostData);
          setPostParams(newPostParams);
        });
      } else {
        const draft = await loadDraft(baseDir());
        if (draft && draft.content) {
            batch(() => {
              setPostData(draft.content);
              const params = draft.params || {};
              if (editorMode() === "new_post" && !params.guid) {
                  params.guid = crypto.randomUUID();
              }
              setPostParams(params);
            });
        } else if (editorMode() === "new_post") {
            const newPostData = {};
            const newPostParams = { locales: {}, guid: crypto.randomUUID() };
            for (const langCode of domainLangCodes()) {
                newPostData[langCode] = { title: "", body: "", chapters: [] };
                newPostParams.locales[langCode] = { chapters: [] };
            }
            batch(() => {
              setPostData(newPostData);
              setPostParams(newPostParams);
            });
        } else {
          dbg.error("EditorPage", `Draft not found for edit mode in '${baseDir()}', navigating back.`);
          navigate(lastTabRoute() || "/");
        }
      }
    } catch (error) {
      dbg.error("EditorPage", "Failed to load draft, navigating away.", error);
      navigate(lastTabRoute() || "/");
    }
  };

  createEffect(on(baseDir, (currentBaseDir) => {
    if (currentBaseDir && currentBaseDir !== "unknown") {
      loadEditorContent();
    }
  }));

  onMount(() => {
    const handleKeyDown = (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key) {
          case 'f': e.preventDefault(); setShowFiles(p => !p); break;
          case 'p': e.preventDefault(); setShowPreview(p => !p); break;
          case 'm': e.preventDefault(); setIsFullScreen(p => !p); break;
        }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    onCleanup(() => window.removeEventListener('keydown', handleKeyDown));
  });

  createEffect(on([postData, postParams], ([data, params]) => {
    if (data === null) return;
    clearTimeout(autoSaveTimeoutId);
    autoSaveTimeoutId = setTimeout(() => {
      saveDraft(baseDir(), { content: data, params: params });
    }, 500);
  }, { defer: true }));

  createEffect(async () => {
    const thumbPath = postParams()?.thumbnail;
    if (thumbPath) {
      const url = await resolveDraftFileUrl(baseDir(), thumbPath);
      setThumbnailUrl(url);
    } else {
      setThumbnailUrl(null);
    }
  });

  createEffect(on(activeLang, (lang) => {
    if (!postData()?.[lang]) {
        setPostData(p => ({...p, [lang]: { title: "", body: "", chapters: [] }}));
        setPostParams(p => {
            const locales = {...(p.locales || {})};
            if (!locales[lang]) locales[lang] = { chapters: [] };
            return {...p, locales};
        });
    }
    const chapters = postData()?.[lang]?.chapters || [];
    setShowChapters(chapters.length > 0);
    setEditingChapterIndex(-1);
  }));

  const handlePaste = async (e) => {
    const items = e.clipboardData?.items;
    if (!items) return;

    let imagePasted = false;
    for (const item of items) {
      if (item.kind === 'file' && item.type.startsWith('image/')) {
        e.preventDefault();
        imagePasted = true;

        const file = item.getAsFile();
        const extension = file.type.split('/')[1] || 'png';
        const fileName = `pasted-image-${Date.now()}.${extension}`;
        const newFile = new File([file], fileName, { type: file.type });

        try {
          await addUploadedFile(baseDir(), newFile);
          const markdownText = `![${fileName}](uploads/${fileName})`;
          insertTextAtCursor(textareaRef, markdownText, handleEditorInput);
        } catch (err) {
          dbg.error("EditorPage:Paste", "Failed to save pasted image", err);
        }
      }
    }

    if (imagePasted) {
      setFilesRevision(r => r + 1);
    }
  };

  const handlePublishSuccess = () => {
    pushToast({ type: "success", message: t("editor.publish.success") });
    setShowPublishWizard(false);
    navigate(lastTabRoute() || "/");
  };

  const currentLangData = createMemo(() => postData()?.[activeLang()] || { title: "", body: "", chapters: [] });

  const updateField = (field, value) => {
    setPostData(prev => ({
      ...prev,
      [activeLang()]: {
        ...(prev?.[activeLang()] || { chapters: [] }),
        [field]: value
      }
    }));
  };

  const updateParam = (field, value) => {
    setPostParams(prev => ({ ...prev, [field]: value }));
  };
  
  const handleConfirmClear = () => {
    const newPostData = {};
    const newPostParams = {
      guid: editorMode() === 'new_post' ? crypto.randomUUID() : postParams().guid,
      publishAsNewPost: editorMode() === 'edit_post' ? false : undefined,
      locales: {}
    };

    if (editorMode() === 'new_comment') {
        newPostParams.parent_savva_cid = routeParams().parent_savva_cid;
    }

    for (const langCode of domainLangCodes()) {
        newPostData[langCode] = { title: "", body: "", chapters: [] };
        newPostParams.locales[langCode] = { chapters: [] };
    }

    batch(() => {
        setPostData(newPostData);
        setPostParams(newPostParams);
        setEditingChapterIndex(-1);
        setShowChapters(false);
        setThumbnailUrl(null);
    });
  };

  const updateChapterTitle = (index, newTitle) => {
    setPostParams(prev => {
      const lang = activeLang();
      const locales = { ...(prev.locales || {}) };
      const langParams = locales[lang] || { chapters: [] };
      const chapters = [...(langParams.chapters || [])];
      if (index >= 0 && index < chapters.length) {
        chapters[index] = { ...chapters[index], title: newTitle };
      }
      locales[lang] = { ...langParams, chapters };
      return { ...prev, locales };
    });
  };

  const handleAddChapter = () => {
    const newChapterContent = { body: "" };
    const newChapterParams = { title: t("editor.chapters.newChapterTitle") || "New Chapter" };
    const newIndex = (postData()[activeLang()]?.chapters || []).length;

    batch(() => {
      setPostData(prev => {
        const lang = activeLang();
        const langData = prev[lang] || { title: "", body: "", chapters: [] };
        const chapters = [...(langData.chapters || []), newChapterContent];
        return { ...prev, [lang]: { ...langData, chapters } };
      });

      setPostParams(prev => {
        const lang = activeLang();
        const locales = { ...(prev.locales || {}) };
        const langParams = locales[lang] || { chapters: [] };
        const chapters = [...(langParams.chapters || []), newChapterParams];
        locales[lang] = { ...langParams, chapters };
        return { ...prev, locales };
      });
    });
    setEditingChapterIndex(newIndex);
  };

  const handleRemoveChapter = () => {
    if (editingChapterIndex() === -1) return;
    setShowConfirmDelete(true);
  };
  
  const confirmRemoveChapter = () => {
    const indexToRemove = editingChapterIndex();
    
    batch(() => {
      setPostData(prev => {
        const lang = activeLang();
        const chapters = (prev[lang]?.chapters || []).filter((_, i) => i !== indexToRemove);
        return { ...prev, [lang]: { ...prev[lang], chapters } };
      });

      setPostParams(prev => {
        const lang = activeLang();
        const newLocales = { ...(prev.locales || {}) };
        if (newLocales[lang]?.chapters) {
          const chapters = (newLocales[lang].chapters || []).filter((_, i) => i !== indexToRemove);
          newLocales[lang] = { ...newLocales[lang], chapters };
        }
        return { ...prev, locales: newLocales };
      });
    });

    setEditingChapterIndex(indexToRemove >= 1 ? indexToRemove - 1 : -1);
    if (postData()[activeLang()]?.chapters.length === 0) {
      setShowChapters(false);
    }
  };

  const currentEditorContent = createMemo(() => {
    const langData = currentLangData();
    const index = editingChapterIndex();
    if (index === -1) return langData.body;
    return langData.chapters?.[index]?.body || "";
  });
  
  const handleEditorInput = (value) => {
    const index = editingChapterIndex();
    if (index === -1) {
      updateField('body', value);
    } else {
        const lang = activeLang();
        const chapters = [...(postData()[lang]?.chapters || [])];
        chapters[index] = { ...chapters[index], body: value };
        updateField('chapters', chapters);
    }
  };

  const handleInsertFile = (fileName, fileType) => {
    const url = `uploads/${fileName}`;
    let markdown;
    if (fileType === 'image') {
      markdown = `![${fileName}](${url})`;
    } else {
      markdown = `[${fileName}](${url})`;
    }
    insertTextAtCursor(textareaRef, markdown, handleEditorInput);
  };

  const handleSetThumbnail = (fileName) => {
    const relativePath = `uploads/${fileName}`;
    setPostParams(prev => ({ ...prev, thumbnail: relativePath }));
  };

  const handleDeleteThumbnail = () => {
    setPostParams(prev => {
      const { thumbnail, ...rest } = prev;
      return rest;
    });
  };

  const handleInsertUrl = (fileName) => {
    insertTextAtCursor(textareaRef, `uploads/${fileName}`, handleEditorInput);
  };

  const title = createMemo(() => {
    switch (editorMode()) {
      case "new_post": return t("editor.titleNewPost");
      case "edit_post": return t("editor.titleEditPost");
      case "new_comment": return t("editor.titleNewCommentFor");
      case "edit_comment": return t("editor.titleEditComment");
      default: return t("editor.title");
    }
  });

  const markdownPlugins = createMemo(() => [[rehypeResolveDraftUrls, { baseDir: baseDir() }]]);

  const combinedChapters = createMemo(() => {
    const contentChapters = currentLangData().chapters || [];
    const paramChapters = postParams()?.locales?.[activeLang()]?.chapters || [];
    return contentChapters.map((c, i) => ({
      ...c,
      title: paramChapters?.[i]?.title || ""
    }));
  });

  const filledLangs = createMemo(() => {
    const data = postData();
    if (!data) return [];
    return domainLangCodes().filter(langCode => {
        const langData = data[langCode];
        return langData && langData.title?.trim() && (langData.body?.trim() || langData.chapters?.some(c => c.body?.trim()));
    });
  });

  return (
    <main classList={{
      "p-4 max-w-7xl mx-auto space-y-4": !isFullScreen(),
      "h-[calc(100vh-3rem)] flex flex-col": isFullScreen()
    }}>
      <Show
        when={!showFullPreview()}
        fallback={
          <EditorFullPreview 
            postData={postData()}
            postParams={postParams()}
            activeLang={activeLang()}
            thumbnailUrl={thumbnailUrl()}
            chapters={combinedChapters()}
            filledLangs={filledLangs()}
            onBack={() => setShowFullPreview(false)}
            onContinue={() => {
              setShowFullPreview(false);
              setShowPublishWizard(true);
            }}
            baseDir={baseDir()}
          />
        }
      >
        <>
          <Show when={!isFullScreen()}>
             <ClosePageButton mode="close" />
            <header class="flex justify-between items-start gap-4">
              <h2 class="text-2xl font-semibold flex-1 min-w-0">{title()}</h2>
              <Show when={editorMode() === 'new_post' || editorMode() === 'edit_post'}>
                <div class="w-48 flex-shrink-0 space-y-2">
                  <div class="relative group aspect-video rounded bg-[hsl(var(--muted))] flex items-center justify-center overflow-hidden">
                    <Show when={thumbnailUrl()}
                      fallback={<span class="text-xs text-[hsl(var(--muted-foreground))]">{t("editor.sidebar.thumbnailPlaceholder")}</span>}
                    >
                      <img src={thumbnailUrl()} alt="Thumbnail preview" class="w-full h-full object-cover" />
                      <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                        <button 
                          onClick={handleDeleteThumbnail}
                          title={t("editor.thumbnail.delete")}
                          class="p-2 rounded-full bg-black/70 text-white hover:bg-red-600"
                        >
                          <TrashIcon class="w-5 h-5" />
                        </button>
                      </div>
                    </Show>
                  </div>
                  <div class="flex justify-center">
                    <LangSelector
                        codes={domainLangCodes()}
                        value={activeLang()}
                        onChange={setActiveLang}
                    />
                  </div>
                </div>
              </Show>
            </header>
          </Show>

          <Show when={postData() !== null} fallback={<div>{t("common.loading")}</div>}>
            <div classList={{ "h-full flex flex-col": isFullScreen() }}>
              <Show when={!isFullScreen()}>
                <>
                  <Show when={editorMode() === 'new_comment' || editorMode() === 'edit_comment'}>
                    <div class="mt-4">
                      <CommentEditor savva_cid={routeParams().parent_savva_cid || routeParams().id} />
                      <div class="flex justify-end items-center gap-2 my-4">
                        <LangSelector
                          codes={domainLangCodes()}
                          value={activeLang()}
                          onChange={setActiveLang}
                        />
                        <EditorFilesButton onClick={() => setShowFiles(true)} />
                      </div>
                    </div>
                  </Show>
                  
                  <Show when={editorMode() === 'new_post' || editorMode() === 'edit_post'}>
                    <div class="flex items-center gap-4 mb-4">
                      <input
                        type="text"
                        value={currentLangData().title}
                        onInput={(e) => updateField('title', e.currentTarget.value)}
                        placeholder={t("editor.titlePlaceholder")}
                        class="flex-1 w-full text-2xl font-bold px-2 py-1 bg-transparent border-b border-[hsl(var(--border))] focus:outline-none focus:border-[hsl(var(--primary))]"
                      />
                      <div class="flex-shrink-0 flex items-center gap-2">
                        <Show when={!showChapters()}>
                          <EditorTocButton onClick={() => { handleAddChapter(); setShowChapters(true); }} />
                        </Show>
                        <Show when={!showFiles()}>
                          <EditorFilesButton onClick={() => setShowFiles(true)} />
                        </Show>
                      </div>
                    </div>
                  </Show>
                  
                  <Show when={showChapters() && editorMode() !== 'new_comment' && editorMode() !== 'edit_comment'}>
                    <div class="mb-4">
                        <EditorChapterSelector
                            chapters={combinedChapters()}
                            activeIndex={editingChapterIndex()}
                            onSelectIndex={setEditingChapterIndex}
                            onAdd={handleAddChapter}
                            onRemove={handleRemoveChapter}
                            onTitleChange={(newTitle) => updateChapterTitle(editingChapterIndex(), newTitle)}
                        />
                    </div>
                  </Show>
                </>
              </Show>
              
              <EditorToolbar
                isPreview={showPreview()}
                onTogglePreview={() => setShowPreview(!showPreview())}
                getTextareaRef={() => textareaRef}
                onValueChange={handleEditorInput}
                isFullScreen={isFullScreen()}
                onToggleFullScreen={() => setIsFullScreen(p => !p)}
              />
              <MarkdownInput
                editorRef={(el) => (textareaRef = el)}
                value={currentEditorContent()}
                onInput={handleEditorInput}
                onPaste={handlePaste}
                placeholder={t("editor.bodyPlaceholder")}
                showPreview={showPreview()}
                rehypePlugins={markdownPlugins()}
                isFullScreen={isFullScreen()}
              />

              <Show when={!isFullScreen()}>
                <>
                  <div class="mt-6 p-4 rounded-lg border border-[hsl(var(--border))] bg-[hsl(var(--card))] space-y-4">
                    <h3 class="text-lg font-semibold">{t("editor.params.title")}</h3>
                    <div class="grid grid-cols-[24rem_auto] items-center gap-x-4 gap-y-4">
                      <div class="justify-self-start self-start">
                        <label for="nsfw-checkbox" class="font-medium">{t("editor.params.nsfw.label")}</label>
                        <p class="text-xs text-[hsl(var(--muted-foreground))]">
                          {t("editor.params.nsfw.help")}
                        </p>
                      </div>
                      <div class="justify-self-start">
                        <input
                          id="nsfw-checkbox"
                          type="checkbox"
                          class="h-5 w-5"
                          checked={postParams().nsfw || false}
                          onInput={(e) => updateParam('nsfw', e.currentTarget.checked)}
                        />
                      </div>
                      <Show when={editorMode() !== 'new_comment' && editorMode() !== 'edit_comment'}>
                        <label class="font-medium" for="fundraiser-id">{t("editor.params.fundraiser.label")}</label>
                        <div class="justify-self-start">
                          <input
                            id="fundraiser-id"
                            type="number"
                            value={postParams().fundraiser || 0}
                            onInput={(e) => updateParam('fundraiser', parseInt(e.currentTarget.value, 10) || 0)}
                            class="w-24 text-left px-3 py-2 rounded border bg-[hsl(var(--background))] text-[hsl(var(--foreground))] border-[hsl(var(--input))]"
                            min="0"
                          />
                        </div>
                      </Show>
                      <Show when={editorMode() === 'edit_post'}>
                        <div class="justify-self-start self-start">
                          <label for="publish-as-new-checkbox" class="font-medium">{t("editor.params.publishAsNew.label")}</label>
                          <p class="text-xs text-[hsl(var(--muted-foreground))]">
                            {t("editor.params.publishAsNew.help")}
                          </p>
                        </div>
                        <div class="justify-self-start">
                          <input
                            id="publish-as-new-checkbox"
                            type="checkbox"
                            class="h-5 w-5"
                            checked={postParams().publishAsNewPost || false}
                            onInput={(e) => updateParam('publishAsNewPost', e.currentTarget.checked)}
                          />
                        </div>
                      </Show>
                    </div>
                  </div>

                  <div class="mt-6 flex justify-end items-center gap-4">
                    <button 
                      onClick={() => setShowConfirmClear(true)}
                      title={t("editor.clearDraft")}
                      class="p-2 rounded-md border border-[hsl(var(--destructive))] text-[hsl(var(--destructive))] hover:bg-[hsl(var(--destructive))] hover:text-[hsl(var(--destructive-foreground))]"
                    >
                      <TrashIcon />
                    </button>
                    <button 
                      onClick={() => setShowFullPreview(true)}
                      class="px-6 py-3 text-lg rounded-lg bg-[hsl(var(--primary))] text-[hsl(var(--primary-foreground))] font-bold hover:opacity-90"
                    >
                      {t("editor.previewPost")}
                    </button>
                  </div>
                </>
              </Show>
            </div>
          </Show>
        </>
      </Show>

      <EditorFilesDrawer 
        isOpen={showFiles()}
        onClose={() => setShowFiles(false)}
        baseDir={baseDir()}
        onInsert={handleInsertFile}
        onSetThumbnail={handleSetThumbnail}
        onInsertUrl={handleInsertUrl}
        filesRevision={filesRevision()}
      />
      <ConfirmModal
        isOpen={showConfirmDelete()}
        onClose={() => setShowConfirmDelete(false)}
        onConfirm={confirmRemoveChapter}
        title={t("editor.chapters.confirmDeleteTitle")}
        message={t("editor.chapters.confirmDeleteMessage")}
      />
       <ConfirmModal
        isOpen={showConfirmClear()}
        onClose={() => setShowConfirmClear(false)}
        onConfirm={handleConfirmClear}
        title={t("editor.clearDraftTitle")}
        message={t("editor.clearDraftMessage")}
      />
      <PostSubmissionWizard 
        isOpen={showPublishWizard()}
        onClose={() => setShowPublishWizard(false)}
        onSuccess={handlePublishSuccess}
        postData={postData}
        postParams={postParams}
        editorMode={editorMode()}
      />
    </main>
  );
}
</file>

<file path="src/i18n/en.js">
// Auto-generated by scripts/i18n.mjs. Do not edit by hand.
export default {
  "app.versionLabel": "Version",
  "brand.name": "SAVVA",
  "categories.all": "All Categories",
  "clipboard.copied": "Copied to clipboard!",
  "clipboard.copy": "Copy",
  "comment.reply": "Reply",
  "comment.showLess": "Show Less",
  "comment.showMore": "Show More",
  "commentsTab.replyTo": "In reply to:",
  "common.apply": "Apply",
  "common.applying": "Applying…",
  "common.cancel": "Cancel",
  "common.checking": "Checking…",
  "common.confirm": "Confirm",
  "common.error": "Error",
  "common.exists": "Exists",
  "common.fail": "Fail",
  "common.loading": "Loading…",
  "common.notFound": "Not found",
  "common.ok": "OK",
  "common.remove": "Remove",
  "common.retry": "Retry",
  "default.avatar": "avatar",
  "default.user": "user",
  "delete.confirm.${type}.title": "Confirm Deletion",
  "delete.confirm.confirm": "Delete",
  "delete.confirm.deleting": "Deleting...",
  "delete.confirm.message": "This will hide the content from view, but it cannot be removed from the blockchain. This action cannot be undone. Are you sure?",
  "delete.toast.error": "Failed to submit deletion transaction.",
  "delete.toast.success": "Deletion submitted. It will be hidden after the backend processes the transaction.",
  "docs.article": "Documentation article",
  "docs.nav": "Developer Docs",
  "docs.next": "Next",
  "docs.prev": "Previous",
  "docs.section": "Section",
  "docs.sidebar.empty": "No docs yet. Add sidebar.yaml under dev_docs/<lang>/",
  "docs.title": "Developer Docs",
  "editor.bodyPlaceholder": "Start writing your post content here...",
  "editor.chapters.add": "Add Chapter",
  "editor.chapters.confirmDeleteMessage": "Are you sure you want to delete this chapter? This action cannot be undone.",
  "editor.chapters.confirmDeleteTitle": "Delete Chapter",
  "editor.chapters.newChapterTitle": "New Chapter",
  "editor.chapters.remove": "Delete Chapter",
  "editor.chapters.title": "Chapters",
  "editor.chapters.titlePlaceholder": "Enter chapter title",
  "editor.clearDraft": "Clear Draft",
  "editor.clearDraftMessage": "Are you sure you want to clear this draft?",
  "editor.clearDraftTitle": "Confirm Clear Draft",
  "editor.files.confirmDeleteTitle": "Delete File",
  "editor.files.empty": "No files uploaded yet. Use the buttons above to add files to your post.",
  "editor.files.menu.delete": "Delete",
  "editor.files.menu.insert": "Insert",
  "editor.files.menu.insertUrl": "Insert URL",
  "editor.files.menu.setThumbnail": "Set as Thumbnail",
  "editor.files.uploadError": "Upload failed. Please try again.",
  "editor.files.uploadFromDisk": "Upload from Disk",
  "editor.files.uploadFromUrl": "Upload from URL",
  "editor.files.uploadModalConfirm": "Confirm Upload",
  "editor.files.uploadModalPlaceholder": "Drag and drop files here or click to select.",
  "editor.files.uploadModalTitle": "Upload Files",
  "editor.files.uploading": "Uploading...",
  "editor.fullPreview.back": "Back to Editing",
  "editor.fullPreview.help": "This is a preview of how your post will look once published. Review it carefully before proceeding.",
  "editor.fullPreview.publish": "Publish",
  "editor.fullPreview.title": "Final Check",
  "editor.params.fundraiser.label": "Promoted Fundrising Campaign ID",
  "editor.params.nsfw.help": "Content contains explicit language or images.",
  "editor.params.nsfw.label": "NSFW",
  "editor.params.publishAsNew.help": "If checked, this will be published as a new post with an updated timestamp, appearing at the top of feeds.",
  "editor.params.publishAsNew.label": "Publish as new post",
  "editor.params.title": "Additional Parameters",
  "editor.previewPost": "Preview Post",
  "editor.publish.descriptor.errorTitle": "Descriptor Upload Failed",
  "editor.publish.draftCleared": "Draft cleared.",
  "editor.publish.ipfs.errorNetworkOrTooLarge": "A network error occurred. This can happen if the post is too large for the server to accept. If you want to post very large content, please consider using your own PIN services.",
  "editor.publish.ipfs.errorTitle": "IPFS Upload Failed",
  "editor.publish.ipfs.errorTooLarge": "This is too big post, if you want to post very large content please consider using your own PIN services.",
  "editor.publish.publishing.errorTitle": "Publishing Failed",
  "editor.publish.publishing.txHash": "Transaction Hash",
  "editor.publish.publishing.waitFinalize": "Publishing is being finalized on the blockchain...",
  "editor.publish.publishing.waitSignature": "Please confirm the transaction in your wallet.",
  "editor.publish.publishing.waitSignatureHelp": "If the wallet window doesn't appear, open your wallet extension to complete the signature.",
  "editor.publish.rights.errorConfig": "Could not retrieve the minimum staking requirement from the contract.",
  "editor.publish.rights.errorNoAuth": "You must be logged in to post.",
  "editor.publish.rights.errorTitle": "Permission Denied",
  "editor.publish.steps.check_rights": "Checking Rights",
  "editor.publish.steps.check_rights.help": "Verifying your posting permissions",
  "editor.publish.steps.ipfs": "Upload to IPFS",
  "editor.publish.steps.ipfs.help": "Saving data to IPFS",
  "editor.publish.steps.ipfs_publish": "IPFS Publishing",
  "editor.publish.steps.ipfs_publish.help": "Waiting for content availability",
  "editor.publish.steps.publish": "Publishing",
  "editor.publish.steps.publish.help": "Publishing to feed",
  "editor.publish.steps.validate": "Validating Post",
  "editor.publish.steps.validate.help": "Checking post structure",
  "editor.publish.success": "Successfully published!",
  "editor.publish.title": "Publish Post",
  "editor.publish.uploadingDescriptor": "Uploading post descriptor",
  "editor.publish.uploadingToIpfs": "Uploading to IPFS",
  "editor.publish.validation.backToEditor": "Back to Editor",
  "editor.publish.validation.errorTitle": "Validation Error",
  "editor.sidebar.files": "Files",
  "editor.sidebar.filesPlaceholder": "File manager coming soon.",
  "editor.sidebar.language": "Language",
  "editor.sidebar.thumbnail": "Thumbnail",
  "editor.sidebar.thumbnailPlaceholder": "Thumbnail preview",
  "editor.thumbnail.delete": "Delete thumbnail",
  "editor.title": "Post Editor",
  "editor.titleEditComment": "Edit Comment",
  "editor.titleEditPost": "Edit Post",
  "editor.titleNewCommentFor": "New Comment For:",
  "editor.titleNewPost": "New Post",
  "editor.titlePlaceholder": "Post Title",
  "editor.toolbar.bold": "Bold",
  "editor.toolbar.files": "Files",
  "editor.toolbar.hidePreview": "Hide Preview",
  "editor.toolbar.image": "Image",
  "editor.toolbar.italic": "Italic",
  "editor.toolbar.link": "Link",
  "editor.toolbar.maximize": "Maximize",
  "editor.toolbar.minimize": "Minimize",
  "editor.toolbar.showPreview": "Show Preview",
  "error.connection.message": "Unable to connect. Check your internet connection.",
  "error.connection.retry": "Retry",
  "error.connection.title": "Connection Error",
  "error.ws.message": "Connection lost. Please refresh the page.",
  "error.ws.title": "WebSocket Error",
  "header.logout": "Logout",
  "header.myProfile": "My Profile",
  "header.newPost": "New Post",
  "ipfs.diag.cors.error": "CORS configuration issue.",
  "ipfs.diag.cors.name": "Gateway CORS Check",
  "ipfs.diag.cors.ok": "CORS is configured correctly.",
  "ipfs.diag.fetch.errorFirewall": "Fetch failed due to firewall.",
  "ipfs.diag.fetch.name": "Live Gateway Fetch",
  "ipfs.diag.fetch.ok": "Fetch successful.",
  "ipfs.diag.fetch.warnSkipped": "Skipped: ABI CID not found in /info response.",
  "ipfs.diag.fix.browser": "If it's running, check your browser. For Brave, disable Shields for this site. For other browsers like Chrome, you may need to 'Allow Insecure content' in Site Settings.",
  "ipfs.diag.fix.cors": "If it still fails, run this command to fix the API CORS policy:",
  "ipfs.diag.fix.daemon": "First, ensure your IPFS daemon is running in a terminal:",
  "ipfs.diag.fix.gatewaySingleOrigin": "Option 1 (Recommended): Allow only the current origin.",
  "ipfs.diag.fix.gatewayTitle": "Your Gateway config is likely preventing the browser from fetching. Try one of these commands:",
  "ipfs.diag.fix.gatewayWildcard": "Option 2 (Easier for Dev): Allow any origin. Use with caution on public nodes.",
  "ipfs.diag.fix.title": "To fix, run this in your terminal (then restart the daemon):",
  "ipfs.diag.liveness.error": "Node is not responding.",
  "ipfs.diag.liveness.name": "API Liveness Check",
  "ipfs.diag.liveness.ok": "Node is live.",
  "ipfs.diag.run": "Run Diagnostics",
  "ipfs.diag.title": "IPFS Node Diagnostics",
  "main.newContentAvailable": "New content is available!",
  "main.tabs.empty": "This tab is empty for now.",
  "main.tabs.loading": "Loading tabs…",
  "main.tabs.untitled": "Untitled",
  "newTab.category": "Category",
  "newTab.view.grid": "Grid View",
  "newTab.view.group": "View Group",
  "newTab.view.list": "List View",
  "post.addComment": "Add a comment...",
  "post.chapters.prologue": "Prologue",
  "post.chapters.title": "Table of Contents",
  "post.comments": "Comments",
  "post.loadMoreComments": "Load more comments",
  "post.noComments": "No comments yet.",
  "post.notFound.message": "The post you're looking for doesn't exist or has been removed.",
  "post.notFound.title": "Post Not Found",
  "postcard.copyDataCid": "Copy Data CID",
  "postcard.copyDescriptorCid": "Copy Descriptor CID",
  "postcard.copySavvaCid": "Copy SAVVA CID",
  "postcard.pin": "Pin Post",
  "postcard.unpin": "Unpin Post",
  "profile.addressCopied": "Address copied to clipboard",
  "profile.error.title": "Could Not Load Profile",
  "profile.stats.nfts": "NFTs",
  "profile.stats.paysForSubscriptions": "!Pays to subscriptions",
  "profile.stats.receivedFromSubscribers": "!Receives from subscribers",
  "profile.stats.sponsoring": "Sponsoring",
  "profile.stats.staking": "Staking",
  "profile.stats.subscribers": "Subscribers",
  "profile.stats.subscriptions": "Subscriptions",
  "profile.subscribe": "Subscribe",
  "profile.subscribers.noResults": "No subscribers found.",
  "profile.subscribers.showActiveOnly": "Show only active",
  "profile.subscribers.table.amount": "Weekly Amount",
  "profile.subscribers.table.domain": "Domain",
  "profile.subscribers.table.expired": "Expired",
  "profile.subscribers.table.user": "User",
  "profile.subscribers.table.weeks": "Weeks Left",
  "profile.tabs.posts": "Posts",
  "profile.tabs.subscribers": "Subscribers",
  "profile.tabs.subscriptions": "Subscriptions",
  "profile.tabs.tags": "Tags",
  "profile.tabs.wallet": "Wallet",
  "reactions.${reactionType()}": "React with {reactionType}",
  "reactions.${type}": "{type} Reaction",
  "reactions.angry": "Angry",
  "reactions.clap": "👏 Clap",
  "reactions.dislike": "👎 Dislike",
  "reactions.fire": "🔥 Fire",
  "reactions.ha_ha": "Ha Ha",
  "reactions.hot": "Hot",
  "reactions.laugh": "😂 Laugh",
  "reactions.like": "Like",
  "reactions.love": "❤️ Love",
  "reactions.sad": "Sad",
  "reactions.star": "⭐ Star",
  "reactions.super": "🌟 Super",
  "reactions.trophy": "Trophy",
  "reactions.wow": "Wow",
  "rightPane.language": "Language",
  "rightPane.settings": "Settings",
  "rightPane.switch.backend.help": "The app will fetch /info from this URL to list supported domains.",
  "rightPane.switch.backend.label": "Backend URL",
  "rightPane.switch.backend.placeholder": "https://example.com/api/",
  "rightPane.switch.domain.label": "Domain",
  "rightPane.switch.domain.website": "Website",
  "rightPane.switch.noDomains": "Backend returned no domains. You can still apply, but the domain will be empty.",
  "rightPane.switch.open": "Switch backend / domain",
  "rightPane.switch.reload": "Load domains",
  "rightPane.switch.reload.title": "Fetch /info and refresh the domain list",
  "rightPane.switch.reset": "Reset to defaults",
  "rightPane.switch.reset.title": "Clear local override and reload defaults from default_connect.yaml",
  "rightPane.switch.title": "Switch backend / domain",
  "rightPane.switch.validation.protocol": "Backend URL must start with http:// or https://",
  "rightPane.theme": "Theme",
  "settings.back": "Back",
  "settings.dev.assets.baseUrl": "Assets base URL",
  "settings.dev.assets.configUrl": "Config URL",
  "settings.dev.assets.configUrl.computed": "Computed URL",
  "settings.dev.assets.configUrl.open": "Open Config URL",
  "settings.dev.assets.diagnostics.default": "Default config",
  "settings.dev.assets.diagnostics.error": "Diagnostics error",
  "settings.dev.assets.diagnostics.hasCategories": "Has categories",
  "settings.dev.assets.diagnostics.hasConfig": "Has config",
  "settings.dev.assets.diagnostics.hasFavicon": "Favicon detected",
  "settings.dev.assets.diagnostics.hasLocales": "Has locales",
  "settings.dev.assets.diagnostics.hasLogos": "Has logos",
  "settings.dev.assets.diagnostics.hasTabs": "Has tabs",
  "settings.dev.assets.diagnostics.noteNetwork": "Check your network connection.",
  "settings.dev.assets.diagnostics.primary": "Primary config",
  "settings.dev.assets.diagnostics.run": "Run diagnostics",
  "settings.dev.assets.diagnostics.sampleFetches": "Sample fetches",
  "settings.dev.assets.diagnostics.title": "Asset diagnostics",
  "settings.dev.assets.domain": "Domain",
  "settings.dev.assets.env": "Environment",
  "settings.dev.assets.env.prod": "Production",
  "settings.dev.assets.env.test": "Test",
  "settings.dev.assets.prefix.active": "Active prefix",
  "settings.dev.assets.prefix.computed": "Computed prefix",
  "settings.dev.assets.source": "Source",
  "settings.dev.assets.title": "Assets",
  "settings.developer.debug.enable": "Enable debug logging",
  "settings.developer.showKeys": "Show API Keys",
  "settings.developer.title": "Developer Settings",
  "settings.ipfs.localDisabled": "Local IPFS disabled",
  "settings.localIpfs.apiUrl.label": "Local IPFS API URL",
  "settings.localIpfs.disable": "Disable",
  "settings.localIpfs.enableCheckbox": "Use local IPFS node",
  "settings.localIpfs.gateway.label": "Gateway",
  "settings.localIpfs.status.label": "Status",
  "settings.localIpfs.testEnable": "Test & enable",
  "settings.localIpfs.title": "Local IPFS",
  "settings.title": "Settings",
  "stakerLevels.${l.key}": "Staker Level {l.key}",
  "stakerLevels.clam": "Clam",
  "stakerLevels.dolphin": "Dolphin",
  "stakerLevels.fish": "Fish",
  "stakerLevels.guest": "Guest",
  "stakerLevels.orca": "Orca",
  "stakerLevels.seahorse": "Seahorse",
  "stakerLevels.shark": "Shark",
  "stakerLevels.shrimp": "Shrimp",
  "stakerLevels.stingray": "Stingray",
  "stakerLevels.whale": "Whale",
  "tabs.aria": "Section tabs",
  "tabs.title.${slug(tab.type)}": "Tab: {tab.type}",
  "tabs.title.actual": "Current",
  "tabs.title.comments": "Comments",
  "tabs.title.for-you": "For You",
  "tabs.title.leaders": "Leaders",
  "tabs.title.new": "New",
  "time.day.plural": "{n} days ago",
  "time.day.singular": "{n} day ago",
  "time.hour.plural": "{n} hours ago",
  "time.hour.singular": "{n} hour ago",
  "time.minute.plural": "{n} minutes ago",
  "time.minute.singular": "{n} minute ago",
  "time.now": "Now",
  "timeFrame.${frame}": "Time Frame: {frame}",
  "timeFrame.all": "All Time",
  "timeFrame.month": "Month",
  "timeFrame.week": "Week",
  "timeFrame.year": "Year",
  "ui.mode.dark": "Dark mode",
  "ui.mode.light": "Light mode",
  "ui.toTop": "Back to Top",
  "wallet.changeChain": "Change network",
  "wallet.connect": "Connect wallet",
  "wallet.copyAddress": "Copy address",
  "wallet.error.userCanceled": "Transaction canceled.",
  "wallet.onRequiredNetwork": "On required network",
  "profile.unsubscribe": "Unsubscribe",
  "profile.stats.perWeek": "per week",
  "profile.wallet.savva.title": "SAVVA",
"profile.wallet.balances.title": "Balances",
"profile.wallet.nft.title": "NFT",
"profile.wallet.savva.description": "SAVVA transferable tokens. You can use them for sponsoring authors and other operations on the platform.",
"profile.wallet.savva.title": "SAVVA",
"profile.wallet.pls.description": "The blockchain's main token. These tokens are required for paying transaction fees and other network operations.",
"profile.wallet.pls.title": "PLS",
"profile.wallet.nftEarnings.description": "NFT owner's proceeds from post sponsors.",
"profile.wallet.nftEarnings.title": "NFT Owner Earnings",
"profile.wallet.staking.title": "Staking",
"profile.wallet.staked.description": "The amount of tokens staked by you on the platform. The more you stake, the more voting weight and rewards you get.",
"profile.wallet.staked.title": "Staked",
"profile.wallet.reward.description": "Reward for staking, accrued periodically upon completion of donation rounds.",
"profile.wallet.reward.title": "Reward",

"profile.wallet.savva.description": "SAVVA transferable tokens. You can use them for sponsoring authors and other operations on the platform.",
"profile.wallet.pls.description": "The blockchain's main token. These tokens are required for paying transaction fees and other network operations.",
"profile.wallet.nftEarnings.title": "NFT Owner Earnings",
"profile.wallet.nftEarnings.description": "NFT owner's proceeds from post sponsors.",
"profile.wallet.staking.title": "Staking",
"profile.wallet.staked.title": "Staked",
"profile.wallet.staked.description": "The amount of tokens staked by you on the platform. The more you stake, the more voting weight and rewards you get.",
"profile.wallet.reward.title": "Reward",
"profile.wallet.reward.description": "Reward for staking, accrued periodically upon completion of donation rounds.",
"profile.wallet.balances.title": "Balances",
"profile.wallet.nft.title": "NFT",
"profile.wallet.savva.description": "SAVVA transferable tokens. You can use them for sponsoring authors and other operations on the platform.",
"profile.wallet.savva.title": "SAVVA",
"profile.wallet.pls.description": "The blockchain's main token. These tokens are required for paying transaction fees and other network operations.",
"profile.wallet.pls.title": "PLS",
"profile.wallet.nftEarnings.description": "NFT owner's proceeds from post sponsors.",
"profile.wallet.nftEarnings.title": "NFT Owner Earnings",
"profile.wallet.staking.title": "Staking",
"profile.wallet.staked.description": "The amount of tokens staked by you on the platform. The more you stake, the more voting weight and rewards you get.",
"profile.wallet.staked.title": "Staked",
"profile.wallet.reward.description": "Reward for staking, accrued periodically upon completion of donation rounds.",
"profile.wallet.reward.title": "Reward",
"settings.pinning.title": "IPFS Pinning Services",
"settings.pinning.description": "Configure external pinning services to ensure your content remains available on IPFS. For each service, you need an API key and the URL of a public gateway that can access its content.",
"settings.pinning.add": "Add Service",
"settings.pinning.edit": "Edit",
"settings.pinning.delete": "Delete",
"settings.pinning.test": "Test",
"settings.pinning.testing": "Testing...",
"settings.pinning.modal.addTitle": "Add Pinning Service",
"settings.pinning.modal.editTitle": "Edit Pinning Service",
"settings.pinning.modal.name.label": "Service Name",
"settings.pinning.modal.name.placeholder": "e.g., My Pinata Account",
"settings.pinning.modal.apiUrl.label": "Pinning API URL",
"settings.pinning.modal.apiUrl.placeholder": "https://api.pinata.cloud/pinning/pinJSONToIPFS",
"settings.pinning.modal.apiKey.label": "API Key (JWT)",
"settings.pinning.modal.gatewayUrl.label": "Public Gateway URL",
"settings.pinning.modal.gatewayUrl.placeholder": "https://gateway.pinata.cloud",
"settings.pinning.modal.gatewayUrl.help": "A public gateway that can resolve CIDs pinned by this service.",
"settings.pinning.modal.save": "Save",
"settings.pinning.test.success": "Connection successful!",
"settings.pinning.test.error": "Test failed",
"settings.pinning.confirmDelete.title": "Delete Pinning Service",
"settings.pinning.confirmDelete.message": "Are you sure you want to remove this service configuration?",
"settings.pinning.preset": "Select a preset...",
"settings.pinning.preset.4everland": "4EVERLAND",
"settings.pinning.preset.filebase": "Filebase",
"settings.pinning.preset.pinata": "Pinata",
"settings.pinning.preset.custom": "Custom",
  "settings.pinning.enable.label": "Store the content of my posts on my pin services",
  "settings.pinning.enable.help": "If enabled, you can publish posts without size limitations, but you are responsible for keeping the files available. If your pin services are not available, your posts will not be accessible to readers.",
  "editor.publish.ipfs.errorNoServices": "Pinning is enabled, but no pinning services are configured. Please add and test a service in Settings.",
  "settings.pinning.test.errorDetails": "Test failed: {details}",
  "editor.publish.uploadingToPinServices": "Uploading to pinning services...",
  "settings.pinning.test.step.create_file": "Create Test File",
"settings.pinning.test.step.pinning": "Pin File via API",
"settings.pinning.test.step.get_cid": "Receive Content ID (CID)",
"settings.pinning.test.step.verify": "Verify on Gateway",
"settings.pinning.test.status.pending": "Pending...",
"settings.pinning.test.status.success": "Success",
"settings.pinning.test.status.error": "Error",
"settings.pinning.test.details.create_file_ok": "In-memory file created ({bytes} bytes).",
"settings.pinning.test.details.pinning_ok": "API responded with HTTP {status}.",
"settings.pinning.test.details.get_cid_ok": "Received CID: {cid}",
"settings.pinning.test.details.verify_ok": "Content verified successfully.",
"settings.pinning.test.hide_details": "Hide Details",
"settings.pinning.test.show_details": "Show Details",
"settings.pinning.test.errorDetails": "Test failed: {details}"
};
</file>

</files>
